import { IApplicationInsights } from "@microsoft/applicationinsights-web";
import BigStorage from "./bigstorage/bigstorage";
import Brotli from "./brotli";
import { GpxHost } from "./host";
import LibGamepix from "./libgamepix";
import { hideLoadingUi, showLoadingCoundown, showLoadingUi } from "./loader-ui";
import runtimeProvider from "./runtimes/autogenerated-runtime";

import wasmInstantiate from "./loader-wasm";

import {
    LoaderResourceSize,
    LoaderRequestOptions, LoaderRequestProgress, LoaderRequestResponseType,
    LoaderXhrData, LoaderXhrDataGzipped, LoaderXhrDataBrotlied
} from "./loader-options";
import LoaderRequest from "./loader-request";
import { wrl } from "./wrl/autogenerated-wrl-loader";

import { getSize } from "./dimensions";
import { IRuntime } from "./runtimes/runtime";

/* tslint:disable:no-namespace */
export interface GpxModule {
    loader?: Loader;
    canvas: HTMLCanvasElement;
    preRun?: (() => void)[];
    postRun?: (() => void)[];
    useIndexedDb?: boolean;
    wasm?: boolean;
    brotli?: boolean;
    debug?: boolean;
    maxResolution?: number;
    width?: number;
    height?: number;
    aspect?: number;
    appInsights?: IApplicationInsights;
    workers?: string;
    showLoadingUi?: () => boolean;
    showLoadingCoundown?: (countdown: number) => number;
    hideLoadingUi?: () => void;
    log?: (message: string, ...args: any[]) => void;
    mapping?: (url: string) => any;
    onresize?: () => void;
    onerror?: (msg: string) => void;
    progress?: (stage: string, current: number, total: number, time: number) => void;
    mainReady?: (timingsReport: string[]) => void;
    ready?: (ready: (...args: string[]) => void) => void;
}

export interface InternalModule extends GpxModule {
    runtime: IRuntime;
    scriptFileName: string;
    dataFileName: string;
    name: string;
    version: string;
    projectVersion: string;
    engineVersion: string;
    symbolsVersion: string;
    gpxWasmTableSize: string;
    startedAt: number;
    noImageDecoding: boolean;
    noAudioDecoding: boolean;
    legacyVm: boolean;
    eval: boolean;
    stages: { [key: string]: number };
    mainStartedAt: number;
    argv: string[];
    dpi: number;
    libgamepix: LibGamepix;
    onRuntimeInitialized: () => void;
    getDpi: () => number;
    print: (msg: string) => void;
    printErr: (msg: string) => void;
    setStatus: () => void;
    run: () => void;
    instantiateWasm: (
        imports: WebAssembly.Imports,
        successCallback: (instance: WebAssembly.Instance, module: WebAssembly.Module) => Promise<WebAssembly.Exports>,
    ) => void;
    loadResource: (resource: string, url: string,
        responseType?: XMLHttpRequestResponseType,
        progress?: LoaderRequestProgress) => Promise<any>;
    idle: () => boolean;

    HEAP8: Int8Array;
    _malloc: (size: number) => number;
    _free: (ptr: number) => number;
}

// Loader
// ======
// 'Loader' is class for loading and bootstrapping game.
export default class Loader {

    private startedAt = 0;
    private wasmCompileTime = 0;
    private wasmInstantiateTime = 0;
    private libStartupTime = 0;
    private module: InternalModule;

    private moduleReady = false;
    private binReady = false;
    private memReady = false;
    private dataReady = false;
    private runReady = false;
    private runtimeReady = false;
    private dataFileReady = false;

    private bin: any;
    private data: any;

    private binfile: string;
    private datajs: string;
    private datafile: string;
    private mem: string;
    private wasmjs: string;
    private wasm: string;

    // Constructor:
    // * bin - url to js file with game binary
    // * data - url to binary game data
    // * module - emscripten module at least canvas should be defined
    constructor(binUrl: string, dataUrl: string, module: GpxModule) {
        module.loader = this;

        this.binfile = binUrl;
        this.datajs = dataUrl;
        this.module = module as InternalModule;
        this.startedAt = Date.now();
        this.module.scriptFileName = dataUrl;
        this.module.dataFileName = dataUrl;
        (this.module as any).noInitialRun = true;
        if (!this.module.showLoadingUi) {
            this.module.showLoadingUi = showLoadingUi;
            this.module.showLoadingCoundown = showLoadingCoundown;
            this.module.hideLoadingUi = hideLoadingUi;
        }
        if (!this.module.preRun) {
            this.module.preRun = [];
        }
        if (!this.module.postRun) {
            this.module.postRun = [];
        }
        if (!this.module.log) {
            /* tslint:disable:no-console */
            this.module.log = function() {
                const verbose = (typeof (window as any).vConsole === "object") ||
                    window.location.href.indexOf("ngrok.io") >= 0 ||
                    window.location.href.indexOf("localhost") >= 0 ||
                    window.location.href.indexOf("127.0.0.1") >= 0;
                const args = [(Date.now() - this.startedAt) + "ms | "];
                for (const next of arguments) {
                    args.push(next);
                }
                if (arguments.length > 0 && typeof arguments[0] === "string") {
                    if (arguments[0].indexOf("ERR!") === 0) {
                        console.error.apply(console, args);
                    } else if (verbose) {
                        if (arguments[0].indexOf("WARN!") === 0) {
                            console.warn.apply(console, args);
                        } else {
                            console.log.apply(console, args);
                        }
                    }
                } else if (verbose) {
                    console.log.apply(console, args);
                }
            }.bind(this);
            /* tslint:enable:no-console */
        }

        this.module.idle = () => {
            const emModule: any = this.module;
            if (emModule._image_direct2_idle !== undefined) {
                return emModule._image_direct2_idle();
            }

            return (Date.now() - this.startedAt) > 15000;
        }

        if (!this.module.mapping) {
            this.module.mapping = (url) => url;
        }
        LoaderRequest.mapping = this.module.mapping;

        if (typeof this.module.useIndexedDb === "undefined") {
            this.module.useIndexedDb = true;
        }

        if (!this.module.useIndexedDb) {
            this.module.log("WARN! IndexedDb is disabled");
        }

        // WebAssembly initialization.
        // We assume that WebAssembly is always good, so we try to use it
        // if host is support it

        if (typeof this.module.wasm === "undefined") {
            this.module.wasm = true;
        }

        if (this.module.wasm && !GpxHost.wasmSupported) {
            this.module.wasm = false;

            this.module.log("WARN! WASM is diabled because host does not support it");
        }

        if (!this.module.wasm && GpxHost.wasmSupported) {
            this.module.log("ERR! VM SUPPORTS WASM, BUT IT IS DISABLED");
        }

        this.wasmCompileTime = 0;
        this.wasmInstantiateTime = 0;

        // Main loading logic

        this.datafile = this.datajs.replace("\.js", "._.js");
        this.mem = this.binfile.replace("\.js", ".mem.js");
        this.wasmjs = `w${this.binfile}`;
        this.wasm = this.wasmjs.replace("\.js", "._.js");

        this.module.name = "flip-goal";
        this.module.version = "flip-goal.5 2020-07-15 05:30:58 (4297a55)";
        this.module.projectVersion = "5";
        this.module.engineVersion = "2019.3.15f1";
        this.module.symbolsVersion = "5";
        this.module.gpxWasmTableSize = "90265";
        if (this.module.wasm) { this.module.version += " [wasm]"; }
        if (this.module.brotli) { this.module.version += " [brotli]"; }
        if (this.module.debug) { document.title = this.module.version; }
        this.module.startedAt = Date.now();
        this.module.noImageDecoding = true;
        this.module.noAudioDecoding = true;
        this.module.legacyVm = GpxHost.legacyVm;
        this.module.eval = true;
        this.module.stages = {};
        if (!this.module.maxResolution) {
            if (this.datajs.indexOf(".hd.") > 0) {
                this.module.maxResolution = 960 * 2;
            } else {
                this.module.maxResolution = 960;
            }
        }
        this.module.onRuntimeInitialized = () => {
            this.runtimeReady = true;
            return this.tryRun();
        };

        if ((this.module.width) || (this.module.height)) {
            this.module.log("WARN! Setting Module.width or Module.height is deprecated please use Module.aspect");
            this.module.aspect = this.module.width / this.module.height;
        }

        let canvasSize = getSize(this.module.canvas);

        if (canvasSize == null) {
            this.module.log("ERR! Unable to find element dimensions using innerWidth/innerHeight");
            canvasSize = {
                width: window.innerWidth,
                height: window.innerHeight,
            };
        }

        const canvasAspect = canvasSize.width / canvasSize.height;
        this.module.log("Detected canvas size: " + canvasSize.width + "x" + canvasSize.height + ", aspect: " + canvasAspect);

        if (!(this.module.aspect)) {
            this.module.aspect = canvasAspect;
            this.module.log("Module.aspect set to match canvas " + canvasAspect);
        }

        if (this.module.aspect !== canvasAspect) {
            this.module.log("ERR! Canvas.aspect !== Module.aspect " + canvasAspect + " !== " + this.module.aspect);
        }

        this.module.width = canvasSize.width;
        if (this.module.width < 160) {
            this.module.log("ERR! canvas width is too small," +
                ` using default resolution: ${this.module.maxResolution}`);
            this.module.width = this.module.maxResolution;
        }
        this.module.height = this.module.width / this.module.aspect;
        this.module.getDpi = () => {
            return this.module.dpi;
        };

        this.module.loadResource = this.loadResource.bind(this);

        const mainReadyFn = this.module.mainReady;
        (this.module as any).mainReady = (framesCount: number, startedAt: number, mainReadyAt: number,
                webPTime: number, webPCallback: number, normalTask: number, lowTask: number) => {
            // startedAt += @module.mainStartedAt
            // mainReadyAt += @module.mainStartedAt

            let row;
            const now = Date.now();
            const totalTime = now - this.module.startedAt;
            const maxXhrTime = Math.max(this.module.stages.bin, this.module.stages.datafile,
                this.module.stages.datajs, this.module.stages.mem);
            const evalTime = this.module.stages["eval.bin"] + this.module.stages["eval.data"];
            const evalMainTime = startedAt - this.module.mainStartedAt;
            const frameTime = now - startedAt;

            const diffTime = totalTime - maxXhrTime - Brotli.brotliTime -
                evalTime - evalMainTime - frameTime - this.wasmInstantiateTime;

            const format2f = (num: number) => Math.round(num * 100) / 100;

            /* tslint:disable:max-line-length */
            const bufferWidth = parseFloat(this.module.argv[0]);
            const bufferHeight = parseFloat(this.module.argv[1]);
            const dpiX = bufferWidth / this.module.canvas.width;
            const dpiY = bufferHeight / this.module.canvas.height;
            const timings = [
                ["--"],
                ["    Version: ", this.module.version, " ", this.module.runtime.name],
                ["       Size: ", format2f(LoaderRequest.bytesReceived / 1024.0 / 1024), " Mb", " idb: ", this.module.useIndexedDb],
                ["     Canvas: ", format2f(bufferWidth) + "x" + format2f(bufferHeight) + " (" + format2f(bufferWidth / bufferHeight) + "), dpi: " + format2f(dpiX) + "x" + format2f(dpiY)],
                ["    Workers: ", JSON.stringify(this.module.workers || "") + " [" + this.module.libgamepix.mode + "] queue " + this.module.libgamepix.queueSize()],
                [" Total time: ", totalTime, ` ms, (${totalTime - maxXhrTime} ms)`],
                ["        XHR: ", maxXhrTime, ` ms, (${LoaderRequest.xhrTime} ms)`],
                ["   lib time: ", this.libStartupTime, " ms"],
                ["  wasm load: ", (this.wasmCompileTime + this.wasmInstantiateTime), ` ms, (compile ${this.wasmCompileTime} ms)`],
                ["       eval: ", evalTime, " ms"],
                ["  eval main: ", evalMainTime, " ms"],
                ["      frame: ", frameTime, ` ms, main: ${mainReadyAt - startedAt} ms`],
                ["     brotli: ", Brotli.brotliTime, " ms"],
                ["       webp: ", (webPTime + webPCallback), ` ms, callbackTime: ${webPCallback} ms`, GpxHost.webpSupported ? " [native]" : " [js]"],
                ["       task: ", (normalTask + lowTask), ` ms, lowTime: ${lowTask} ms`],
                ["frame count: ", framesCount],
                ["       diff: ", diffTime, " ms"],
            ];
            /* tslint:enable:max-line-length */
            if (this.module.debug) { document.title += " - mainReady"; }

            if (this.module.appInsights) {
                const properties = this.getGameProperties();
                const measurements: { [name: string]: number } = {};
                for (row of Array.from(timings)) {
                    if (row.length > 1) {
                        if (typeof row[1] === "number") {
                            const value = row[1] as number;
                            measurements[(row[0] + "").trim()] = Number.isNaN(value) ? 0 : value;
                        } else {
                            properties[(row[0] + "").trim()] = row.slice(1).join("");
                        }
                    }
                }
                this.module.appInsights.trackEvent({
                    name: "mainReady",
                    properties,
                    measurements,
                });
                this.module.appInsights.flush();
                this.module.log("Telemtry sent to application insights");
            }

            const timingsReport: string[] = [];
            for (let i = 0; i < timings.length; ++i) {
                timingsReport[i] = timings[i].join("");
            }

            this.module.log(location.href);
            this.module.log(`Host: ${JSON.stringify(GpxHost)}`);
            for (row of Array.from(timingsReport)) {
                this.module.log(row);
            }
            if (typeof mainReadyFn === "function") {
                mainReadyFn(timingsReport);
            }

            setTimeout((() => (typeof this.module.onresize === "function" ? this.module.onresize() : undefined)), 1);
            wrl.loadBufferOnIdle();
        };

        if (this.module.brotli) {
            this.module.log("WARN! brotli is now deprecated, forced to false");
            this.module.brotli = false;
        }

        if (this.module.debug || !this.module.progress) {
            let lastReport = 0;
            const progress = this.module.progress;
            this.module.progress = (stage, current, total, time) => {
                let message = `Progress(${Date.now() - this.module.startedAt}ms): ${stage}`;
                if (total === current) {
                    message += " 100%";
                    this.module.stages[stage] = time;
                } else {
                    message += ` ${((current / total) * 100).toFixed(2)}%`;
                }
                if (time > 0) { message += ` (Total: ${time}ms)`; }
                this.module.log(message);

                const now = Date.now();
                if (((now - lastReport) > 1000) && ((now - lastReport) < 30000)) {
                    this.module.log(`WARN: Hang on progress for ${now - lastReport}ms`);
                }
                lastReport = now;

                return (typeof progress === "function" ? progress(stage, current, total, time) : undefined);
            };
        }

        this.module.print = this.module.log;
        this.module.printErr = this.module.log;
        /* tslint:disable:no-empty */
        this.module.setStatus = () => { };
        /* tslint:enable:no-empty */

        LoaderRequest.brotli = this.module.brotli;
        LoaderRequest.log = this.module.log;

        if (this.module.useIndexedDb === true) {
            BigStorage(this.module, (bs) => {
                LoaderRequest.cache = bs;
                this.doLoad();
            });
        } else {
            this.doLoad();
        }

        wrl.loadMeta(this.module);
    }

    public evalBin() {
        if (!(this.bin) || !(this.memReady) || this.binReady) { return; }

        const startedAt = Date.now();
        if (this.module.eval) {
            this.binReady = true;
            if (typeof this.bin !== "function") {
                this.bin = new (Function as any)(["Module"], this.bin);
            }
            this.module.progress("eval.bin", 1, 2, Date.now() - startedAt);

            const apply = () => {
                this.bin(this.module);
                delete this.bin;
                this.module.progress("eval.bin", 2, 2, Date.now() - startedAt);
                (this.module as any).Browser?.resizeListeners.push(() => this.onResize());
                this.moduleReady = true;
                return this.tryRun();
            };

            return setTimeout(apply, 0);
        } else {
            /* tslint:disable:max-line-length */
            const url = URL.createObjectURL(new Blob([this.bin], { type: "text/javascript" }));
            /* tslint:enable:max-line-length */
            delete this.bin;
            this.module.progress("eval.bin", 1, 2, Date.now() - startedAt);

            const script = document.createElement("script");
            script.onload = () => {
                this.binReady = true;
                this.module.progress("eval.bin", 2, 2, Date.now() - startedAt);
                (this.module as any).Browser?.resizeListeners.push(() => this.onResize());
                this.moduleReady = true;
                return this.tryRun();
            };
            script.src = url;
            return document.head.appendChild(script);
        }
    }

    public evalData() {
        if (!(this.dataFileReady) || !(this.data) || this.dataReady) { return; }

        const startedAt = Date.now();

        if (this.module.eval) {
            this.dataReady = true;

            if (typeof this.data === "function") {
                this.data();
            } else {
                const Module = this.module;
                /* tslint:disable:no-eval */
                eval(this.data);
            }

            delete this.data;

            this.module.progress("eval.data", 0, 0, Date.now() - startedAt);
            return this.tryRun();
        } else {
            const url = URL.createObjectURL(new Blob([this.data], { type: "text/javascript" }));
            delete this.data;

            const script = document.createElement("script");
            script.onload = () => {
                this.dataReady = true;
                this.module.progress("eval.data", 0, 0, Date.now() - startedAt);
                return this.tryRun();
            };
            script.src = url;
            return document.head.appendChild(script);
        }
    }


    private shouldWaitForDependencies() {
        const notReady: string[] = [];
        const ready: string[] = [];

        function push(depReady: boolean, name: string) {
            depReady ? ready.push(name) : notReady.push(name);
        }

        push(this.moduleReady, "Module");
        push(this.binReady, "Binary");
        push(this.memReady, "Memory");
        push(this.dataReady, "Data");
        push(this.runtimeReady, "Runtime");

        this.module.log("run, waiting for [" + notReady.join(", ") +
            "], ready [" + ready.join(", ") + "]");

        return notReady.length > 0;
    }

    public tryRun() {
        if (this.runReady) {
            this.module.log("ERR! requested run, but already runned");
            return;
        }

        if (this.shouldWaitForDependencies()) {
            return;
        }

        this.module.log("starting...");
        this.runReady = true;
        this.libStartupTime = Date.now();
        return this.module.libgamepix = new LibGamepix(this.module as any, () => {
            this.libStartupTime = Date.now() - this.libStartupTime;
            return this.run();
        });
    }

    public run() {
        let startedAt = Date.now();
        this.module.run();
        this.module.progress("module.run", 0, 0, Date.now() - startedAt);

        const callMain = function() {
            this.module.dpi = Math.min(window.devicePixelRatio, 2);

            if (this.module.runtime.name.indexOf("Unity") === 0) {
                this.module.log("WARN! Unity does not support devicePixelRatio != 1, forcing to full width & height");
                this.module.dpi = 1;
            } else if (this.module.fixedWidth != null) {
                this.module.width = this.module.fixedWidth;
                this.module.height = this.module.width / this.module.aspect;
                this.module.dpi = 1;
            } else if (this.module.fixedHeight != null) {
                this.module.height = this.module.fixedHeight;
                this.module.width = this.module.height * this.module.aspect;
                this.module.dpi = 1;
            } else {
                const aspect = this.module.width / this.module.height;
                const maxSideResolution = Math.max(this.module.width, this.module.height) * this.module.dpi;
                if (maxSideResolution > this.module.maxResolution) {
                    const width = this.module.width;
                    const height = this.module.height;
                    const scale = this.module.maxResolution / maxSideResolution;
                    this.module.width = this.module.width * scale;
                    this.module.height = this.module.height * scale;
                    /* tslint:disable:max-line-length */
                    this.module.log(`WARN! canvas size is too big, resized from ${width * this.module.dpi}x${height * this.module.dpi} to ${this.module.width * this.module.dpi}x${this.module.height * this.module.dpi}`);
                    /* tslint:enable:max-line-length */
                }

                if (this.module.height < (this.module.minHeight || 0)) {
                    this.module.height = this.module.minHeight;
                    this.module.width = this.module.height * aspect;
                }

                if (this.module.width < (this.module.minWidth || 0)) {
                    this.module.width = this.module.minWidth;
                    this.module.height = this.module.width / aspect;
                }
            }

            const argv = [(this.module.width * this.module.dpi) + "", (this.module.height * this.module.dpi) + ""];
            for (const next of arguments) {
                argv.push(next + "");
            }

            // Unity compability
            GpxHost.systemInfo.width = this.module.width * this.module.dpi;
            GpxHost.systemInfo.height = this.module.height * this.module.dpi;
            this.module.webglContextAttributes = GpxHost.systemInfo.webglContextAttributes;
            this.module.canvas.style.width = GpxHost.systemInfo.width + "px";
            this.module.canvas.style.height = GpxHost.systemInfo.height + "px";

            startedAt = Date.now();
            this.module.mainStartedAt = startedAt;
            this.module.argv = argv;
            this.module.log("main(", argv, ")");
            this.module.callMain(argv);
            return this.module.progress("module.main", 0, 0, Date.now() - startedAt);
        }.bind(this);

        if (this.module.ready) {
            const readyFn = (...topArgs: string[]) => {
                const fn = () => {
                    callMain.apply(this, topArgs);
                };
                return setTimeout(fn, 0);
            };
            return this.module.ready(readyFn);
        } else {
            return setTimeout(callMain, 0);
        }
    }

    public width() {
        this.module.log("WARN! Module.width is legacy and will be removed");
        return this.module.canvas.width / this.module.dpi;
    }

    public height() {
         this.module.log("WARN! Module.height is legacy and will be removed");
         return this.module.canvas.height / this.module.dpi;
    }

    public ratio() {
        return this.module.canvas.width / this.module.canvas.height;
    }

    public onResize() {
        return (typeof this.module.onresize === "function" ? this.module.onresize() : undefined);
    }

    public getGameProperties(): { [name: string]: string } {
        const device = GpxHost.getParameterByName("device") || "Browser";
        return {
            "Game: ":           this.module.name,
            "ProjectVersion: ": this.module.projectVersion,
            "Version: ":        this.module.version.substr(0, this.module.version.indexOf(" ")),
            "Engine: ":         this.module.engineVersion,
            "Navigator: ":      (typeof navigator !== "undefined" && navigator !== null ?
                        navigator.userAgent : undefined) || "unknown",
            "Device: ":         device,
            "Wasm: ":           this.module.wasm + "",
            "Webp: ":           GpxHost.webpSupported + "",
            "OS: ":             GpxHost.systemInfo.os,
            "OSVersion: ":      GpxHost.systemInfo.osVersion,
            "GPU: ":            GpxHost.systemInfo.gpu,
            "Device model: ":   GpxHost.systemInfo.deviceModel,
            "CPU cores: ":      GpxHost.systemInfo.logicalCores.toString(),
            "Screen width: ":   GpxHost.systemInfo.screenWidth.toString(),
            "Screen height: ":  GpxHost.systemInfo.screenHeight.toString(),
        };
    }

    private doLoad() {
        const doWasmLoad = () => {
            const wasm2asm = (e: any) => {
                /* tslint:disable:max-line-length */
                this.module.log(`ERR! instaniate(${e.fileName}:${e.lineNumber}:${e.columnNumber}): ${e.name} - ${e.message}`);
                /* tslint:enable:max-line-length */
                this.module.log("ERR!", e.stack);
                this.module.log("ERR! Starting asm.js");
                this.module.wasm = false;
                this.memReady = false;
                this.binReady = false;
                this.module.version += "{fallback to asm.js}";
                delete this.bin;
                doAsmLoad();
            };

            // no mem in wasm
            this.memReady = true;
            this.module.progress("mem", 1, 1, Date.now() - this.startedAt);

            this.loadResource("bin", this.wasm,
                GpxHost.wasmStreaming ? "response" : "arraybuffer").then((wasmdata) => {
                this.module.instantiateWasm = (info, receiveInstance) => {
                    wrl.init(info, this.module.gpxWasmTableSize);
                    // tslint:disable-next-line:no-shadowed-variable
                    return runtimeProvider(this.module)
                        .then((runtime) => {
                            (info as any).env = (info as any).env || {};
                            (info as any).env.logcall = runtime.logcall;
                            (info as any).env.wipedcall = runtime.wipedcall;
                            (info as any).env.globalscall = runtime.globalscall;
                            (window as any).runtime = runtime;
                            this.module.runtime = runtime;
                            return info;
                        })
                        // tslint:disable-next-line:no-shadowed-variable
                        .then((info) => {
                            const wrlPromise = wrl.ready.then(() => this.module.log("WRL is ready"));
                            const waitForWrl = this.module.runtime.waitForWrl || ((window as any).GamePix?.wrlSync === true);
                            if (waitForWrl) {
                                this.module.log("WARN! Runtime requires wrl, waiting when it's ready");
                                wrl.loadBufferNow();
                                return wrlPromise.then(() => wasmInstantiate(wasmdata, info));
                            } else {
                                return wasmInstantiate(wasmdata, info);
                            }
                        })
                        .then((instaniated) => {
                            this.wasmCompileTime = instaniated.compileTime;
                            this.wasmInstantiateTime = instaniated.instantiateTime;
                            const WM = this.module;
                            const WE = instaniated.instance.exports;
                            wrl.bind(WM, WE);
                            return receiveInstance(instaniated.instance, instaniated.wasmModule);
                        })
                        .catch(wasm2asm);
                };

                return this.loadResource("", this.wasmjs).then((script) => {
                    this.bin = script;
                    return this.evalBin();
                });
            }).catch(wasm2asm);
        };

        const doAsmLoad = () => {
            this.loadResource("bin", this.binfile).then((script) => {
                this.bin = script;
                return this.evalBin();
            });

            this.loadResource("mem", this.mem, "arraybuffer").then((data) => {
                (this.module as any).memoryInitializerRequest = {
                    status: 200,
                    response: data,
                };
                this.memReady = true;
                return this.evalBin();
            });

            runtimeProvider(this.module).then((runtime) => {
                (window as any).runtime = runtime;
                this.module.runtime = runtime;
            });
        };

        if (this.module.wasm) {
            doWasmLoad();
        } else {
            doAsmLoad();
        }

        this.loadResource("datafile", this.datafile, "arraybuffer").then((data) => {
            (this.module as any).getPreloadedPackage = (name: any, size: any) => data;
            this.dataFileReady = true;
            return this.evalData();
        });

        this.loadResource("datajs", this.datajs).then((script) => {
            this.data = script;
            return this.evalData();
        });
    }

    private loadResource(resource: string, url: string,
        responseType?: LoaderRequestResponseType,
        progress?: LoaderRequestProgress): Promise<any> {
        return Promise.all([GpxHost.caniuseBrotli(url), GpxHost.caniuseGzip(url)]).then((resolved) => {
            const [brotli, gzip] = resolved;

            if (brotli) {
                return LoaderRequest.changeToCompressedUrl(url, "br");
            } else if (gzip) {
                return LoaderRequest.changeToCompressedUrl(url, "gz");
            }

            return url;
        // tslint:disable-next-line:no-shadowed-variable
        }).then((url) => {
            return new Promise<any>((success, fail) => {
                const options: LoaderRequestOptions = {
                    // tslint:disable-next-line:no-shadowed-variable
                    fail: (url, status, message) => {
                        const error = "ERR! Can't download " + url + ", status: " + status + ", context: " + message;
                        this.module.log(error);
                        if (this.module.onerror) {
                            this.module.onerror(error);
                        }
                        fail(url);
                    },
                    progress: (total, current) => {
                        total = LoaderResourceSize(url, current, total);
                        this.module.progress(resource, current, total, 0);
                        if (progress) {
                            progress(total, current);
                        }
                    },
                    success: (response, origin) => {
                        this.module.progress(resource, 1, 1, Date.now() - this.startedAt);
                        success(response);
                    },
                    responseType,
                };

                new LoaderRequest(url, options);
            });
        });
    }
}

// export to global scope
(window as any).LoaderRequest = LoaderRequest;
(window as any).LoaderResourceSize = LoaderResourceSize;

(window as any).GpxHost = GpxHost;
(window as any).Brotli = Brotli;
(window as any).Loader = Loader;

// backward compability
(window as any).LoaderXhr = LoaderRequest;
(window as any).LoaderXhrData = LoaderXhrData;
(window as any).LoaderXhrDataGzipped = LoaderXhrDataGzipped;
(window as any).LoaderXhrDataBrotlied = LoaderXhrDataBrotlied;

// wrl
(window as any).wrl = wrl;
(window as any).FUNCTION_TABLE = {};
(window as any).WM = {};
(window as any).WE = {};
(window as any).i64toi32_i32$HIGH_BITS = {};
