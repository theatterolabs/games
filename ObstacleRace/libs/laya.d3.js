function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}

function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
        set = Reflect.set;
    } else {
        set = function set(target, property, value, receiver) {
            var base = _superPropBase(target, property);
            var desc;
            if (base) {
                desc = Object.getOwnPropertyDescriptor(base, property);
                if (desc.set) {
                    desc.set.call(receiver, value);
                    return true;
                } else if (!desc.writable) {
                    return false;
                }
            }
            desc = Object.getOwnPropertyDescriptor(receiver, property);
            if (desc) {
                if (!desc.writable) {
                    return false;
                }
                desc.value = value;
                Object.defineProperty(receiver, property, desc);
            } else {
                _defineProperty(receiver, property, value);
            }
            return true;
        };
    }
    return set(target, property, value, receiver);
}

function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
        throw new Error("failed to set property");
    }
    return value;
}

function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}

function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}

function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
    } else {
        _get = function _get(target, property, receiver) {
            var base = _superPropBase(target, property);
            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.get) {
                return desc.get.call(receiver);
            }
            return desc.value;
        };
    }
    return _get(target, property, receiver || target);
}

function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null) break;
    }
    return object;
}

function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}

function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}

! function(e, t) {
    "use strict";
    var r = /* */ function() {
        function r() {
            _classCallCheck(this, r);
        }
        _createClass(r, null, [{
            key: "isZero",
            value: function isZero(e) {
                return Math.abs(e) < r.zeroTolerance;
            }
        }, {
            key: "nearEqual",
            value: function nearEqual(e, t) {
                return !!r.isZero(e - t);
            }
        }, {
            key: "fastInvSqrt",
            value: function fastInvSqrt(e) {
                return r.isZero(e) ? e : 1 / Math.sqrt(e);
            }
        }]);
        return r;
    }();
    r.zeroTolerance = 1e-6, r.MaxValue = 3.40282347e38, r.MinValue = -3.40282347e38;
    var i = /* */ function() {
        function i() {
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            _classCallCheck(this, i);
            this.x = e, this.y = t;
        }
        _createClass(i, [{
            key: "setValue",
            value: function setValue(e, t) {
                this.x = e, this.y = t;
            }
        }, {
            key: "fromArray",
            value: function fromArray(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                this.x = e[t + 0], this.y = e[t + 1];
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t.x = this.x, t.y = this.y;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new i();
                return this.cloneTo(e), e;
            }
        }, {
            key: "forNativeElement",
            value: function forNativeElement() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y) : this.elements = new Float32Array([this.x, this.y]),
                    i.rewriteNumProperty(this, "x", 0), i.rewriteNumProperty(this, "y", 1);
            }
        }], [{
            key: "scale",
            value: function scale(e, t, r) {
                r.x = e.x * t, r.y = e.y * t;
            }
        }, {
            key: "dot",
            value: function dot(e, t) {
                return e.x * t.x + e.y * t.y;
            }
        }, {
            key: "normalize",
            value: function normalize(e, t) {
                var r = e.x,
                    i = e.y,
                    a = r * r + i * i;
                a > 0 && (a = 1 / Math.sqrt(a), t.x = r * a, t.y = i * a);
            }
        }, {
            key: "scalarLength",
            value: function scalarLength(e) {
                var t = e.x,
                    r = e.y;
                return Math.sqrt(t * t + r * r);
            }
        }, {
            key: "rewriteNumProperty",
            value: function rewriteNumProperty(e, t, r) {
                Object.defineProperty(e, t, {
                    get: function get() {
                        return this.elements[r];
                    },
                    set: function set(e) {
                        this.elements[r] = e;
                    }
                });
            }
        }]);
        return i;
    }();
    i.ZERO = new i(0, 0), i.ONE = new i(1, 1);
    var a = /* */ function() {
        function a() {
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            _classCallCheck(this, a);
            this.x = e, this.y = t, this.z = r, this.w = i;
        }
        _createClass(a, [{
            key: "setValue",
            value: function setValue(e, t, r, i) {
                this.x = e, this.y = t, this.z = r, this.w = i;
            }
        }, {
            key: "fromArray",
            value: function fromArray(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3];
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t.x = this.x, t.y = this.y, t.z = this.z, t.w = this.w;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new a();
                return this.cloneTo(e), e;
            }
        }, {
            key: "length",
            value: function length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
        }, {
            key: "lengthSquared",
            value: function lengthSquared() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
        }, {
            key: "forNativeElement",
            value: function forNativeElement() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z,
                        this.elements[3] = this.w) : this.elements = new Float32Array([this.x, this.y, this.z, this.w]),
                    i.rewriteNumProperty(this, "x", 0), i.rewriteNumProperty(this, "y", 1), i.rewriteNumProperty(this, "z", 2),
                    i.rewriteNumProperty(this, "w", 3);
            }
        }], [{
            key: "lerp",
            value: function lerp(e, t, r, i) {
                var a = e.x,
                    n = e.y,
                    s = e.z,
                    o = e.w;
                i.x = a + r * (t.x - a), i.y = n + r * (t.y - n), i.z = s + r * (t.z - s), i.w = o + r * (t.w - o);
            }
        }, {
            key: "transformByM4x4",
            value: function transformByM4x4(e, t, r) {
                var i = e.x,
                    a = e.y,
                    n = e.z,
                    s = e.w,
                    o = t.elements;
                r.x = i * o[0] + a * o[4] + n * o[8] + s * o[12], r.y = i * o[1] + a * o[5] + n * o[9] + s * o[13],
                    r.z = i * o[2] + a * o[6] + n * o[10] + s * o[14], r.w = i * o[3] + a * o[7] + n * o[11] + s * o[15];
            }
        }, {
            key: "equals",
            value: function equals(e, t) {
                return r.nearEqual(Math.abs(e.x), Math.abs(t.x)) && r.nearEqual(Math.abs(e.y), Math.abs(t.y)) && r.nearEqual(Math.abs(e.z), Math.abs(t.z)) && r.nearEqual(Math.abs(e.w), Math.abs(t.w));
            }
        }, {
            key: "normalize",
            value: function normalize(e, t) {
                var r = e.length();
                if (r > 0) {
                    var i = 1 / r;
                    t.x = e.x * i, t.y = e.y * i, t.z = e.z * i, t.w = e.w * i;
                }
            }
        }, {
            key: "add",
            value: function add(e, t, r) {
                r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z, r.w = e.w + t.w;
            }
        }, {
            key: "subtract",
            value: function subtract(e, t, r) {
                r.x = e.x - t.x, r.y = e.y - t.y, r.z = e.z - t.z, r.w = e.w - t.w;
            }
        }, {
            key: "multiply",
            value: function multiply(e, t, r) {
                r.x = e.x * t.x, r.y = e.y * t.y, r.z = e.z * t.z, r.w = e.w * t.w;
            }
        }, {
            key: "scale",
            value: function scale(e, t, r) {
                r.x = e.x * t, r.y = e.y * t, r.z = e.z * t, r.w = e.w * t;
            }
        }, {
            key: "Clamp",
            value: function Clamp(e, t, r, i) {
                var a = e.x,
                    n = e.y,
                    s = e.z,
                    o = e.w,
                    l = t.x,
                    _ = t.y,
                    h = t.z,
                    c = t.w,
                    d = r.x,
                    u = r.y,
                    m = r.z,
                    f = r.w;
                a = (a = a > d ? d : a) < l ? l : a, n = (n = n > u ? u : n) < _ ? _ : n, s = (s = s > m ? m : s) < h ? h : s,
                    o = (o = o > f ? f : o) < c ? c : o, i.x = a, i.y = n, i.z = s, i.w = o;
            }
        }, {
            key: "distanceSquared",
            value: function distanceSquared(e, t) {
                var r = e.x - t.x,
                    i = e.y - t.y,
                    a = e.z - t.z,
                    n = e.w - t.w;
                return r * r + i * i + a * a + n * n;
            }
        }, {
            key: "distance",
            value: function distance(e, t) {
                var r = e.x - t.x,
                    i = e.y - t.y,
                    a = e.z - t.z,
                    n = e.w - t.w;
                return Math.sqrt(r * r + i * i + a * a + n * n);
            }
        }, {
            key: "dot",
            value: function dot(e, t) {
                return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w;
            }
        }, {
            key: "min",
            value: function min(e, t, r) {
                r.x = Math.min(e.x, t.x), r.y = Math.min(e.y, t.y), r.z = Math.min(e.z, t.z), r.w = Math.min(e.w, t.w);
            }
        }, {
            key: "max",
            value: function max(e, t, r) {
                r.x = Math.max(e.x, t.x), r.y = Math.max(e.y, t.y), r.z = Math.max(e.z, t.z), r.w = Math.max(e.w, t.w);
            }
        }]);
        return a;
    }();
    a.ZERO = new a(), a.ONE = new a(1, 1, 1, 1), a.UnitX = new a(1, 0, 0, 0), a.UnitY = new a(0, 1, 0, 0),
        a.UnitZ = new a(0, 0, 1, 0), a.UnitW = new a(0, 0, 0, 1);
    var n = /* */ function() {
        function n() {
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
            _classCallCheck(this, n);
            this.x = e, this.y = t, this.z = r;
        }
        _createClass(n, [{
            key: "setValue",
            value: function setValue(e, t, r) {
                this.x = e, this.y = t, this.z = r;
            }
        }, {
            key: "fromArray",
            value: function fromArray(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2];
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t.x = this.x, t.y = this.y, t.z = this.z;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new n();
                return this.cloneTo(e), e;
            }
        }, {
            key: "toDefault",
            value: function toDefault() {
                this.x = 0, this.y = 0, this.z = 0;
            }
        }, {
            key: "forNativeElement",
            value: function forNativeElement() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z) : this.elements = new Float32Array([this.x, this.y, this.z]),
                    i.rewriteNumProperty(this, "x", 0), i.rewriteNumProperty(this, "y", 1), i.rewriteNumProperty(this, "z", 2);
            }
        }], [{
            key: "distanceSquared",
            value: function distanceSquared(e, t) {
                var r = e.x - t.x,
                    i = e.y - t.y,
                    a = e.z - t.z;
                return r * r + i * i + a * a;
            }
        }, {
            key: "distance",
            value: function distance(e, t) {
                var r = e.x - t.x,
                    i = e.y - t.y,
                    a = e.z - t.z;
                return Math.sqrt(r * r + i * i + a * a);
            }
        }, {
            key: "min",
            value: function min(e, t, r) {
                r.x = Math.min(e.x, t.x), r.y = Math.min(e.y, t.y), r.z = Math.min(e.z, t.z);
            }
        }, {
            key: "max",
            value: function max(e, t, r) {
                r.x = Math.max(e.x, t.x), r.y = Math.max(e.y, t.y), r.z = Math.max(e.z, t.z);
            }
        }, {
            key: "transformQuat",
            value: function transformQuat(e, t, r) {
                var i = e.x,
                    a = e.y,
                    n = e.z,
                    s = t.x,
                    o = t.y,
                    l = t.z,
                    _ = t.w,
                    h = _ * i + o * n - l * a,
                    c = _ * a + l * i - s * n,
                    d = _ * n + s * a - o * i,
                    u = -s * i - o * a - l * n;
                r.x = h * _ + u * -s + c * -l - d * -o, r.y = c * _ + u * -o + d * -s - h * -l,
                    r.z = d * _ + u * -l + h * -o - c * -s;
            }
        }, {
            key: "scalarLength",
            value: function scalarLength(e) {
                var t = e.x,
                    r = e.y,
                    i = e.z;
                return Math.sqrt(t * t + r * r + i * i);
            }
        }, {
            key: "scalarLengthSquared",
            value: function scalarLengthSquared(e) {
                var t = e.x,
                    r = e.y,
                    i = e.z;
                return t * t + r * r + i * i;
            }
        }, {
            key: "normalize",
            value: function normalize(e, t) {
                var r = e.x,
                    i = e.y,
                    a = e.z,
                    n = r * r + i * i + a * a;
                n > 0 && (n = 1 / Math.sqrt(n), t.x = r * n, t.y = i * n, t.z = a * n);
            }
        }, {
            key: "multiply",
            value: function multiply(e, t, r) {
                r.x = e.x * t.x, r.y = e.y * t.y, r.z = e.z * t.z;
            }
        }, {
            key: "scale",
            value: function scale(e, t, r) {
                r.x = e.x * t, r.y = e.y * t, r.z = e.z * t;
            }
        }, {
            key: "lerp",
            value: function lerp(e, t, r, i) {
                var a = e.x,
                    n = e.y,
                    s = e.z;
                i.x = a + r * (t.x - a), i.y = n + r * (t.y - n), i.z = s + r * (t.z - s);
            }
        }, {
            key: "transformV3ToV3",
            value: function transformV3ToV3(e, t, r) {
                var i = n._tempVector4;
                n.transformV3ToV4(e, t, i), r.x = i.x, r.y = i.y, r.z = i.z;
            }
        }, {
            key: "transformV3ToV4",
            value: function transformV3ToV4(e, t, r) {
                var i = e.x,
                    a = e.y,
                    n = e.z,
                    s = t.elements;
                r.x = i * s[0] + a * s[4] + n * s[8] + s[12], r.y = i * s[1] + a * s[5] + n * s[9] + s[13],
                    r.z = i * s[2] + a * s[6] + n * s[10] + s[14], r.w = i * s[3] + a * s[7] + n * s[11] + s[15];
            }
        }, {
            key: "TransformNormal",
            value: function TransformNormal(e, t, r) {
                var i = e.x,
                    a = e.y,
                    n = e.z,
                    s = t.elements;
                r.x = i * s[0] + a * s[4] + n * s[8], r.y = i * s[1] + a * s[5] + n * s[9], r.z = i * s[2] + a * s[6] + n * s[10];
            }
        }, {
            key: "transformCoordinate",
            value: function transformCoordinate(e, t, r) {
                var i = e.x,
                    a = e.y,
                    n = e.z,
                    s = t.elements,
                    o = i * s[3] + a * s[7] + n * s[11] + s[15];
                r.x = i * s[0] + a * s[4] + n * s[8] + s[12] / o, r.y = i * s[1] + a * s[5] + n * s[9] + s[13] / o,
                    r.z = i * s[2] + a * s[6] + n * s[10] + s[14] / o;
            }
        }, {
            key: "Clamp",
            value: function Clamp(e, t, r, i) {
                var a = e.x,
                    n = e.y,
                    s = e.z,
                    o = t.x,
                    l = t.y,
                    _ = t.z,
                    h = r.x,
                    c = r.y,
                    d = r.z;
                a = (a = a > h ? h : a) < o ? o : a, n = (n = n > c ? c : n) < l ? l : n, s = (s = s > d ? d : s) < _ ? _ : s,
                    i.x = a, i.y = n, i.z = s;
            }
        }, {
            key: "add",
            value: function add(e, t, r) {
                r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z;
            }
        }, {
            key: "subtract",
            value: function subtract(e, t, r) {
                r.x = e.x - t.x, r.y = e.y - t.y, r.z = e.z - t.z;
            }
        }, {
            key: "cross",
            value: function cross(e, t, r) {
                var i = e.x,
                    a = e.y,
                    n = e.z,
                    s = t.x,
                    o = t.y,
                    l = t.z;
                r.x = a * l - n * o, r.y = n * s - i * l, r.z = i * o - a * s;
            }
        }, {
            key: "dot",
            value: function dot(e, t) {
                return e.x * t.x + e.y * t.y + e.z * t.z;
            }
        }, {
            key: "equals",
            value: function equals(e, t) {
                return r.nearEqual(e.x, t.x) && r.nearEqual(e.y, t.y) && r.nearEqual(e.z, t.z);
            }
        }]);
        return n;
    }();
    var s, o;
    n._tempVector4 = new a(), n._ZERO = new n(0, 0, 0), n._ONE = new n(1, 1, 1), n._NegativeUnitX = new n(-1, 0, 0),
        n._UnitX = new n(1, 0, 0), n._UnitY = new n(0, 1, 0), n._UnitZ = new n(0, 0, 1),
        n._ForwardRH = new n(0, 0, -1), n._ForwardLH = new n(0, 0, 1), n._Up = new n(0, 1, 0),
        (s = e.PBRRenderQuality || (e.PBRRenderQuality = {}))[s.High = 0] = "High", s[s.Low = 1] = "Low";
    var l = /* */ function() {
        function l() {
            _classCallCheck(this, l);
            this._defaultPhysicsMemory = 16, this._maxLightCount = 32, this._lightClusterCount = new n(12, 12, 12),
                this._editerEnvironment = !1, this.isAntialias = !0, this.isAlpha = !1, this.premultipliedAlpha = !0,
                this.isStencil = !0, this.enableMultiLight = !0, this.octreeCulling = !1, this.octreeInitialSize = 64,
                this.octreeInitialCenter = new n(0, 0, 0), this.octreeMinNodeSize = 2, this.octreeLooseness = 1.25,
                this.debugFrustumCulling = !1, this.pbrRenderQuality = e.PBRRenderQuality.High,
                this._maxAreaLightCountPerClusterAverage = Math.min(4 * Math.floor(2048 / this._lightClusterCount.z - 1), this._maxLightCount);
        }
        _createClass(l, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t._defaultPhysicsMemory = this._defaultPhysicsMemory, t._editerEnvironment = this._editerEnvironment,
                    t.isAntialias = this.isAntialias, t.isAlpha = this.isAlpha, t.premultipliedAlpha = this.premultipliedAlpha,
                    t.isStencil = this.isStencil, t.octreeCulling = this.octreeCulling, this.octreeInitialCenter.cloneTo(t.octreeInitialCenter),
                    t.octreeInitialSize = this.octreeInitialSize, t.octreeMinNodeSize = this.octreeMinNodeSize,
                    t.octreeLooseness = this.octreeLooseness, t.debugFrustumCulling = this.debugFrustumCulling,
                    t.maxLightCount = this.maxLightCount, t.enableMultiLight = this.enableMultiLight;
                var r = t.lightClusterCount;
                this.lightClusterCount.cloneTo(r), t.lightClusterCount = r, t.pbrRenderQuality = this.pbrRenderQuality;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new l();
                return this.cloneTo(e), e;
            }
        }, {
            key: "defaultPhysicsMemory",
            get: function get() {
                return this._defaultPhysicsMemory;
            },
            set: function set(e) {
                if (e < 16) throw "defaultPhysicsMemory must large than 16M";
                this._defaultPhysicsMemory = e;
            }
        }, {
            key: "maxLightCount",
            get: function get() {
                return this._maxLightCount;
            },
            set: function set(e) {
                e > 2048 ? (this._maxLightCount = 2048, console.warn("Config3D: maxLightCount must less equal 2048.")) : this._maxLightCount = e;
            }
        }, {
            key: "lightClusterCount",
            get: function get() {
                return this._lightClusterCount;
            },
            set: function set(e) {
                e.x > 128 || e.y > 128 || e.z > 128 ? (this._lightClusterCount.setValue(Math.min(e.x, 128), Math.min(e.y, 128), Math.min(e.z, 128)),
                    console.warn("Config3D: lightClusterCount X and Y、Z must less equal 128.")) : e.cloneTo(this._lightClusterCount);
                var t = 4 * Math.floor(2048 / this._lightClusterCount.z - 1);
                t < this._maxLightCount && console.warn("Config3D: if the area light(PointLight、SpotLight) count is large than " + t + ",maybe the far away culster will ingonre some light."),
                    this._maxAreaLightCountPerClusterAverage = Math.min(t, this._maxLightCount);
            }
        }]);
        return l;
    }();
    l._config = new l(), window.Config3D = l;
    var _ = function _() {
        _classCallCheck(this, _);
    };
    _.Shader3D = null, _.Scene3D = null, _.MeshRenderStaticBatchManager = null, _.MeshRenderDynamicBatchManager = null,
        _.SubMeshDynamicBatch = null, _.Laya3D = null, _.Matrix4x4 = null;
    var h = /* */ function() {
        function h() {
            _classCallCheck(this, h);
            this._ownerPath = [], this._propertys = [], this._keyFrames = [];
        }
        _createClass(h, [{
            key: "_setOwnerPathCount",
            value: function _setOwnerPathCount(e) {
                this._ownerPath.length = e;
            }
        }, {
            key: "_setOwnerPathByIndex",
            value: function _setOwnerPathByIndex(e, t) {
                this._ownerPath[e] = t;
            }
        }, {
            key: "_joinOwnerPath",
            value: function _joinOwnerPath(e) {
                return this._ownerPath.join(e);
            }
        }, {
            key: "_setPropertyCount",
            value: function _setPropertyCount(e) {
                this._propertys.length = e;
            }
        }, {
            key: "_setPropertyByIndex",
            value: function _setPropertyByIndex(e, t) {
                this._propertys[e] = t;
            }
        }, {
            key: "_joinProperty",
            value: function _joinProperty(e) {
                return this._propertys.join(e);
            }
        }, {
            key: "_setKeyframeCount",
            value: function _setKeyframeCount(e) {
                this._keyFrames.length = e;
            }
        }, {
            key: "_setKeyframeByIndex",
            value: function _setKeyframeByIndex(e, t) {
                this._keyFrames[e] = t;
            }
        }, {
            key: "getOwnerPathByIndex",
            value: function getOwnerPathByIndex(e) {
                return this._ownerPath[e];
            }
        }, {
            key: "getPropertyByIndex",
            value: function getPropertyByIndex(e) {
                return this._propertys[e];
            }
        }, {
            key: "getKeyframeByIndex",
            value: function getKeyframeByIndex(e) {
                return this._keyFrames[e];
            }
        }, {
            key: "ownerPathCount",
            get: function get() {
                return this._ownerPath.length;
            }
        }, {
            key: "propertyCount",
            get: function get() {
                return this._propertys.length;
            }
        }, {
            key: "keyFramesCount",
            get: function get() {
                return this._keyFrames.length;
            }
        }]);
        return h;
    }();
    var c = function c() {
        _classCallCheck(this, c);
    };
    var d = /* */ function() {
        function d() {
            _classCallCheck(this, d);
        }
        _createClass(d, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                e.time = this.time;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new d();
                return this.cloneTo(e), e;
            }
        }]);
        return d;
    }();
    var u = /* */ function(_d) {
        _inherits(u, _d);

        function u() {
            _classCallCheck(this, u);
            return _possibleConstructorReturn(this, _getPrototypeOf(u).call(this));
        }
        _createClass(u, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                _get(_getPrototypeOf(u.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.inTangent = this.inTangent, t.outTangent = this.outTangent, t.value = this.value;
            }
        }]);
        return u;
    }(d);
    var m = /* */ function() {
        function m() {
            _classCallCheck(this, m);
            var e = this.elements = new Float32Array(9);
            e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0,
                e[8] = 1;
        }
        _createClass(m, [{
            key: "determinant",
            value: function determinant() {
                var e = this.elements,
                    t = e[0],
                    r = e[1],
                    i = e[2],
                    a = e[3],
                    n = e[4],
                    s = e[5],
                    o = e[6],
                    l = e[7],
                    _ = e[8];
                return t * (_ * n - s * l) + r * (-_ * a + s * o) + i * (l * a - n * o);
            }
        }, {
            key: "translate",
            value: function translate(e, t) {
                var r = t.elements,
                    i = this.elements,
                    a = i[0],
                    n = i[1],
                    s = i[2],
                    o = i[3],
                    l = i[4],
                    _ = i[5],
                    h = i[6],
                    c = i[7],
                    d = i[8],
                    u = e.x,
                    m = e.y;
                r[0] = a, r[1] = n, r[2] = s, r[3] = o, r[4] = l, r[5] = _, r[6] = u * a + m * o + h,
                    r[7] = u * n + m * l + c, r[8] = u * s + m * _ + d;
            }
        }, {
            key: "rotate",
            value: function rotate(e, t) {
                var r = t.elements,
                    i = this.elements,
                    a = i[0],
                    n = i[1],
                    s = i[2],
                    o = i[3],
                    l = i[4],
                    _ = i[5],
                    h = i[6],
                    c = i[7],
                    d = i[8],
                    u = Math.sin(e),
                    m = Math.cos(e);
                r[0] = m * a + u * o, r[1] = m * n + u * l, r[2] = m * s + u * _, r[3] = m * o - u * a,
                    r[4] = m * l - u * n, r[5] = m * _ - u * s, r[6] = h, r[7] = c, r[8] = d;
            }
        }, {
            key: "scale",
            value: function scale(e, t) {
                var r = t.elements,
                    i = this.elements,
                    a = e.x,
                    n = e.y;
                r[0] = a * i[0], r[1] = a * i[1], r[2] = a * i[2], r[3] = n * i[3], r[4] = n * i[4],
                    r[5] = n * i[5], r[6] = i[6], r[7] = i[7], r[8] = i[8];
            }
        }, {
            key: "invert",
            value: function invert(e) {
                var t = e.elements,
                    r = this.elements,
                    i = r[0],
                    a = r[1],
                    n = r[2],
                    s = r[3],
                    o = r[4],
                    l = r[5],
                    _ = r[6],
                    h = r[7],
                    c = r[8],
                    d = c * o - l * h,
                    u = -c * s + l * _,
                    m = h * s - o * _,
                    f = i * d + a * u + n * m;
                f || (e = null), f = 1 / f, t[0] = d * f, t[1] = (-c * a + n * h) * f, t[2] = (l * a - n * o) * f,
                    t[3] = u * f, t[4] = (c * i - n * _) * f, t[5] = (-l * i + n * s) * f, t[6] = m * f,
                    t[7] = (-h * i + a * _) * f, t[8] = (o * i - a * s) * f;
            }
        }, {
            key: "transpose",
            value: function transpose(e) {
                var t = e.elements,
                    r = this.elements;
                if (e === this) {
                    var i = r[1],
                        a = r[2],
                        n = r[5];
                    t[1] = r[3], t[2] = r[6], t[3] = i, t[5] = r[7], t[6] = a, t[7] = n;
                } else t[0] = r[0], t[1] = r[3], t[2] = r[6], t[3] = r[1], t[4] = r[4], t[5] = r[7],
                    t[6] = r[2], t[7] = r[5], t[8] = r[8];
            }
        }, {
            key: "identity",
            value: function identity() {
                var e = this.elements;
                e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0,
                    e[8] = 1;
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t, r, i;
                if ((r = this.elements) !== (i = e.elements))
                    for (t = 0; t < 9; ++t) {
                        i[t] = r[t];
                    }
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new m();
                return this.cloneTo(e), e;
            }
        }], [{
            key: "createRotationQuaternion",
            value: function createRotationQuaternion(e, t) {
                var r = e.x,
                    i = e.y,
                    a = e.z,
                    n = e.w,
                    s = r * r,
                    o = i * i,
                    l = a * a,
                    _ = r * i,
                    h = a * n,
                    c = a * r,
                    d = i * n,
                    u = i * a,
                    m = r * n,
                    f = t.elements;
                f[0] = 1 - 2 * (o + l), f[1] = 2 * (_ + h), f[2] = 2 * (c - d), f[3] = 2 * (_ - h),
                    f[4] = 1 - 2 * (l + s), f[5] = 2 * (u + m), f[6] = 2 * (c + d), f[7] = 2 * (u - m),
                    f[8] = 1 - 2 * (o + s);
            }
        }, {
            key: "createFromTranslation",
            value: function createFromTranslation(e, t) {
                var r = t.elements;
                r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 1, r[5] = 0, r[6] = e.x, r[7] = e.y,
                    r[8] = 1;
            }
        }, {
            key: "createFromRotation",
            value: function createFromRotation(e, t) {
                var r = t.elements,
                    i = Math.sin(e),
                    a = Math.cos(e);
                r[0] = a, r[1] = i, r[2] = 0, r[3] = -i, r[4] = a, r[5] = 0, r[6] = 0, r[7] = 0,
                    r[8] = 1;
            }
        }, {
            key: "createFromScaling",
            value: function createFromScaling(e, t) {
                var r = t.elements;
                r[0] = e.x, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = e.y, r[5] = 0, r[6] = 0, r[7] = 0,
                    r[8] = e.z;
            }
        }, {
            key: "createFromMatrix4x4",
            value: function createFromMatrix4x4(e, t) {
                var r = e.elements,
                    i = t.elements;
                i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[4], i[4] = r[5], i[5] = r[6], i[6] = r[8],
                    i[7] = r[9], i[8] = r[10];
            }
        }, {
            key: "multiply",
            value: function multiply(e, t, r) {
                var i = e.elements,
                    a = t.elements,
                    n = r.elements,
                    s = i[0],
                    o = i[1],
                    l = i[2],
                    _ = i[3],
                    h = i[4],
                    c = i[5],
                    d = i[6],
                    u = i[7],
                    m = i[8],
                    f = a[0],
                    E = a[1],
                    T = a[2],
                    p = a[3],
                    g = a[4],
                    S = a[5],
                    R = a[6],
                    v = a[7],
                    x = a[8];
                n[0] = f * s + E * _ + T * d, n[1] = f * o + E * h + T * v, n[2] = f * l + E * c + T * m,
                    n[3] = p * s + g * _ + S * d, n[4] = p * o + g * h + S * u, n[5] = p * l + g * c + S * m,
                    n[6] = R * s + v * _ + x * d, n[7] = R * o + v * h + x * u, n[8] = R * l + v * c + x * m;
            }
        }, {
            key: "lookAt",
            value: function lookAt(e, t, r, i) {
                n.subtract(e, t, m._tempV30), n.normalize(m._tempV30, m._tempV30), n.cross(r, m._tempV30, m._tempV31),
                    n.normalize(m._tempV31, m._tempV31), n.cross(m._tempV30, m._tempV31, m._tempV32);
                var a = m._tempV30,
                    s = m._tempV31,
                    o = m._tempV32,
                    l = i.elements;
                l[0] = s.x, l[3] = s.y, l[6] = s.z, l[1] = o.x, l[4] = o.y, l[7] = o.z, l[2] = a.x,
                    l[5] = a.y, l[8] = a.z;
            }
        }]);
        return m;
    }();
    m.DEFAULT = new m(), m._tempV30 = new n(), m._tempV31 = new n(), m._tempV32 = new n();
    var f = /* */ function() {
        function f() {
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
            _classCallCheck(this, f);
            this.x = e, this.y = t, this.z = r, this.w = i;
        }
        _createClass(f, [{
            key: "scaling",
            value: function scaling(e, t) {
                t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t.w = this.w * e;
            }
        }, {
            key: "normalize",
            value: function normalize(e) {
                var t = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
                t > 0 && (t = 1 / Math.sqrt(t), e.x = this.x * t, e.y = this.y * t, e.z = this.z * t,
                    e.w = this.w * t);
            }
        }, {
            key: "length",
            value: function length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
        }, {
            key: "rotateX",
            value: function rotateX(e, t) {
                e *= .5;
                var r = Math.sin(e),
                    i = Math.cos(e);
                t.x = this.x * i + this.w * r, t.y = this.y * i + this.z * r, t.z = this.z * i - this.y * r,
                    t.w = this.w * i - this.x * r;
            }
        }, {
            key: "rotateY",
            value: function rotateY(e, t) {
                e *= .5;
                var r = Math.sin(e),
                    i = Math.cos(e);
                t.x = this.x * i - this.z * r, t.y = this.y * i + this.w * r, t.z = this.z * i + this.x * r,
                    t.w = this.w * i - this.y * r;
            }
        }, {
            key: "rotateZ",
            value: function rotateZ(e, t) {
                e *= .5;
                var r = Math.sin(e),
                    i = Math.cos(e);
                t.x = this.x * i + this.y * r, t.y = this.y * i - this.x * r, t.z = this.z * i + this.w * r,
                    t.w = this.w * i - this.z * r;
            }
        }, {
            key: "getYawPitchRoll",
            value: function getYawPitchRoll(e) {
                n.transformQuat(n._ForwardRH, this, f.TEMPVector31), n.transformQuat(n._Up, this, f.TEMPVector32);
                var t = f.TEMPVector32;
                f.angleTo(n._ZERO, f.TEMPVector31, f.TEMPVector33);
                var r = f.TEMPVector33;
                r.x == Math.PI / 2 ? (r.y = f.arcTanAngle(t.z, t.x), r.z = 0) : r.x == -Math.PI / 2 ? (r.y = f.arcTanAngle(-t.z, -t.x),
                        r.z = 0) : (_.Matrix4x4.createRotationY(-r.y, _.Matrix4x4.TEMPMatrix0), _.Matrix4x4.createRotationX(-r.x, _.Matrix4x4.TEMPMatrix1),
                        n.transformCoordinate(f.TEMPVector32, _.Matrix4x4.TEMPMatrix0, f.TEMPVector32),
                        n.transformCoordinate(f.TEMPVector32, _.Matrix4x4.TEMPMatrix1, f.TEMPVector32),
                        r.z = f.arcTanAngle(t.y, -t.x)), r.y <= -Math.PI && (r.y = Math.PI), r.z <= -Math.PI && (r.z = Math.PI),
                    r.y >= Math.PI && r.z >= Math.PI && (r.y = 0, r.z = 0, r.x = Math.PI - r.x);
                var i = e;
                i.x = r.y, i.y = r.x, i.z = r.z;
            }
        }, {
            key: "invert",
            value: function invert(e) {
                var t = this.x,
                    r = this.y,
                    i = this.z,
                    a = this.w,
                    n = t * t + r * r + i * i + a * a,
                    s = n ? 1 / n : 0;
                e.x = -t * s, e.y = -r * s, e.z = -i * s, e.w = a * s;
            }
        }, {
            key: "identity",
            value: function identity() {
                this.x = 0, this.y = 0, this.z = 0, this.w = 1;
            }
        }, {
            key: "fromArray",
            value: function fromArray(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3];
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                this !== e && (e.x = this.x, e.y = this.y, e.z = this.z, e.w = this.w);
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new f();
                return this.cloneTo(e), e;
            }
        }, {
            key: "equals",
            value: function equals(e) {
                return r.nearEqual(this.x, e.x) && r.nearEqual(this.y, e.y) && r.nearEqual(this.z, e.z) && r.nearEqual(this.w, e.w);
            }
        }, {
            key: "lengthSquared",
            value: function lengthSquared() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
        }, {
            key: "forNativeElement",
            value: function forNativeElement() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z,
                        this.elements[3] = this.w) : this.elements = new Float32Array([this.x, this.y, this.z, this.w]),
                    i.rewriteNumProperty(this, "x", 0), i.rewriteNumProperty(this, "y", 1), i.rewriteNumProperty(this, "z", 2),
                    i.rewriteNumProperty(this, "w", 3);
            }
        }], [{
            key: "createFromYawPitchRoll",
            value: function createFromYawPitchRoll(e, t, r, i) {
                var a = .5 * r,
                    n = .5 * t,
                    s = .5 * e,
                    o = Math.sin(a),
                    l = Math.cos(a),
                    _ = Math.sin(n),
                    h = Math.cos(n),
                    c = Math.sin(s),
                    d = Math.cos(s);
                i.x = d * _ * l + c * h * o, i.y = c * h * l - d * _ * o, i.z = d * h * o - c * _ * l,
                    i.w = d * h * l + c * _ * o;
            }
        }, {
            key: "multiply",
            value: function multiply(e, t, r) {
                var i = e.x,
                    a = e.y,
                    n = e.z,
                    s = e.w,
                    o = t.x,
                    l = t.y,
                    _ = t.z,
                    h = t.w,
                    c = a * _ - n * l,
                    d = n * o - i * _,
                    u = i * l - a * o,
                    m = i * o + a * l + n * _;
                r.x = i * h + o * s + c, r.y = a * h + l * s + d, r.z = n * h + _ * s + u, r.w = s * h - m;
            }
        }, {
            key: "arcTanAngle",
            value: function arcTanAngle(e, t) {
                return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
            }
        }, {
            key: "angleTo",
            value: function angleTo(e, t, r) {
                n.subtract(t, e, f.TEMPVector30), n.normalize(f.TEMPVector30, f.TEMPVector30), r.x = Math.asin(f.TEMPVector30.y),
                    r.y = f.arcTanAngle(-f.TEMPVector30.z, -f.TEMPVector30.x);
            }
        }, {
            key: "createFromAxisAngle",
            value: function createFromAxisAngle(e, t, r) {
                t *= .5;
                var i = Math.sin(t);
                r.x = i * e.x, r.y = i * e.y, r.z = i * e.z, r.w = Math.cos(t);
            }
        }, {
            key: "createFromMatrix4x4",
            value: function createFromMatrix4x4(e, t) {
                var r, i, a = e.elements,
                    n = a[0] + a[5] + a[10];
                n > 0 ? (r = Math.sqrt(n + 1), t.w = .5 * r, r = .5 / r, t.x = (a[6] - a[9]) * r,
                    t.y = (a[8] - a[2]) * r, t.z = (a[1] - a[4]) * r) : a[0] >= a[5] && a[0] >= a[10] ? (i = .5 / (r = Math.sqrt(1 + a[0] - a[5] - a[10])),
                    t.x = .5 * r, t.y = (a[1] + a[4]) * i, t.z = (a[2] + a[8]) * i, t.w = (a[6] - a[9]) * i) : a[5] > a[10] ? (i = .5 / (r = Math.sqrt(1 + a[5] - a[0] - a[10])),
                    t.x = (a[4] + a[1]) * i, t.y = .5 * r, t.z = (a[9] + a[6]) * i, t.w = (a[8] - a[2]) * i) : (i = .5 / (r = Math.sqrt(1 + a[10] - a[0] - a[5])),
                    t.x = (a[8] + a[2]) * i, t.y = (a[9] + a[6]) * i, t.z = .5 * r, t.w = (a[1] - a[4]) * i);
            }
        }, {
            key: "slerp",
            value: function slerp(e, t, r, i) {
                var a, n, s, o, l, _ = e.x,
                    h = e.y,
                    c = e.z,
                    d = e.w,
                    u = t.x,
                    m = t.y,
                    f = t.z,
                    E = t.w;
                return (n = _ * u + h * m + c * f + d * E) < 0 && (n = -n, u = -u, m = -m, f = -f,
                        E = -E), 1 - n > 1e-6 ? (a = Math.acos(n), s = Math.sin(a), o = Math.sin((1 - r) * a) / s,
                        l = Math.sin(r * a) / s) : (o = 1 - r, l = r), i.x = o * _ + l * u, i.y = o * h + l * m,
                    i.z = o * c + l * f, i.w = o * d + l * E, i;
            }
        }, {
            key: "lerp",
            value: function lerp(e, t, r, i) {
                var a = 1 - r;
                f.dot(e, t) >= 0 ? (i.x = a * e.x + r * t.x, i.y = a * e.y + r * t.y, i.z = a * e.z + r * t.z,
                    i.w = a * e.w + r * t.w) : (i.x = a * e.x - r * t.x, i.y = a * e.y - r * t.y, i.z = a * e.z - r * t.z,
                    i.w = a * e.w - r * t.w), i.normalize(i);
            }
        }, {
            key: "add",
            value: function add(e, t, r) {
                r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z, r.w = e.w + t.w;
            }
        }, {
            key: "dot",
            value: function dot(e, t) {
                return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w;
            }
        }, {
            key: "rotationLookAt",
            value: function rotationLookAt(e, t, r) {
                f.lookAt(n._ZERO, e, t, r);
            }
        }, {
            key: "lookAt",
            value: function lookAt(e, t, r, i) {
                m.lookAt(e, t, r, f._tempMatrix3x3), f.rotationMatrix(f._tempMatrix3x3, i);
            }
        }, {
            key: "invert",
            value: function invert(e, t) {
                var i = e.lengthSquared();
                r.isZero(i) || (i = 1 / i, t.x = -e.x * i, t.y = -e.y * i, t.z = -e.z * i, t.w = e.w * i);
            }
        }, {
            key: "rotationMatrix",
            value: function rotationMatrix(e, t) {
                var r, i, a = e.elements,
                    n = a[0],
                    s = a[1],
                    o = a[2],
                    l = a[3],
                    _ = a[4],
                    h = a[5],
                    c = a[6],
                    d = a[7],
                    u = a[8],
                    m = n + _ + u;
                m > 0 ? (r = Math.sqrt(m + 1), t.w = .5 * r, r = .5 / r, t.x = (h - d) * r, t.y = (c - o) * r,
                    t.z = (s - l) * r) : n >= _ && n >= u ? (i = .5 / (r = Math.sqrt(1 + n - _ - u)),
                    t.x = .5 * r, t.y = (s + l) * i, t.z = (o + c) * i, t.w = (h - d) * i) : _ > u ? (i = .5 / (r = Math.sqrt(1 + _ - n - u)),
                    t.x = (l + s) * i, t.y = .5 * r, t.z = (d + h) * i, t.w = (c - o) * i) : (i = .5 / (r = Math.sqrt(1 + u - n - _)),
                    t.x = (c + o) * i, t.y = (d + h) * i, t.z = .5 * r, t.w = (s - l) * i);
            }
        }]);
        return f;
    }();
    f.TEMPVector30 = new n(), f.TEMPVector31 = new n(), f.TEMPVector32 = new n(), f.TEMPVector33 = new n(),
        f._tempMatrix3x3 = new m(), f.DEFAULT = new f(), f.NAN = new f(NaN, NaN, NaN, NaN);
    var E = /* */ function(_d2) {
        _inherits(E, _d2);

        function E() {
            var _this;
            _classCallCheck(this, E);
            _this = _possibleConstructorReturn(this, _getPrototypeOf(E).call(this)), _this.inTangent = new a(),
                _this.outTangent = new a(), _this.value = new f();
            return _this;
        }
        _createClass(E, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                _get(_getPrototypeOf(E.prototype), "cloneTo", this).call(this, e);
                var t = e;
                this.inTangent.cloneTo(t.inTangent), this.outTangent.cloneTo(t.outTangent), this.value.cloneTo(t.value);
            }
        }]);
        return E;
    }(d);
    var T = /* */ function(_d3) {
        _inherits(T, _d3);

        function T() {
            var _this2;
            _classCallCheck(this, T);
            _this2 = _possibleConstructorReturn(this, _getPrototypeOf(T).call(this)), _this2.inTangent = new n(),
                _this2.outTangent = new n(), _this2.value = new n();
            return _this2;
        }
        _createClass(T, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                _get(_getPrototypeOf(T.prototype), "cloneTo", this).call(this, e);
                var t = e;
                this.inTangent.cloneTo(t.inTangent), this.outTangent.cloneTo(t.outTangent), this.value.cloneTo(t.value);
            }
        }]);
        return T;
    }(d);
    var p = /* */ function() {
        function p() {
            _classCallCheck(this, p);
        }
        _createClass(p, null, [{
            key: "READ_DATA",
            value: function READ_DATA() {
                p._DATA.offset = p._reader.getUint32(), p._DATA.size = p._reader.getUint32();
            }
        }, {
            key: "READ_BLOCK",
            value: function READ_BLOCK() {
                for (var e = p._BLOCK.count = p._reader.getUint16(), t = p._BLOCK.blockStarts = [], r = p._BLOCK.blockLengths = [], i = 0; i < e; i++) {
                    t.push(p._reader.getUint32()), r.push(p._reader.getUint32());
                }
            }
        }, {
            key: "READ_STRINGS",
            value: function READ_STRINGS() {
                var e = p._reader.getUint32(),
                    t = p._reader.getUint16(),
                    r = p._reader.pos;
                p._reader.pos = e + p._DATA.offset;
                for (var i = 0; i < t; i++) {
                    p._strings[i] = p._reader.readUTFString();
                }
                p._reader.pos = r;
            }
        }, {
            key: "parse",
            value: function parse(e, t) {
                p._animationClip = e, p._reader = t;
                t.__getBuffer();
                p.READ_DATA(), p.READ_BLOCK(), p.READ_STRINGS();
                for (var r = 0, i = p._BLOCK.count; r < i; r++) {
                    var a = t.getUint16(),
                        n = p._strings[a],
                        s = p["READ_" + n];
                    if (null == s) throw new Error("model file err,no this function:" + a + " " + n);
                    s.call(null);
                }
            }
        }, {
            key: "READ_ANIMATIONS",
            value: function READ_ANIMATIONS() {
                var e, r, i, a = p._reader,
                    n = (a.__getBuffer(), []),
                    s = a.getUint16();
                for (n.length = s, e = 0; e < s; e++) {
                    n[e] = a.getFloat32();
                }
                var o = p._animationClip;
                o.name = p._strings[a.getUint16()];
                var l = o._duration = a.getFloat32();
                o.islooping = !!a.getByte(), o._frameRate = a.getInt16();
                var _ = a.getInt16(),
                    d = o._nodes;
                d.count = _;
                var m = o._nodesMap = {},
                    f = o._nodesDic = {};
                for (e = 0; e < _; e++) {
                    i = new h(), d.setNodeByIndex(e, i), i._indexInList = e;
                    var g = i.type = a.getUint8(),
                        S = a.getUint16();
                    for (i._setOwnerPathCount(S), r = 0; r < S; r++) {
                        i._setOwnerPathByIndex(r, p._strings[a.getUint16()]);
                    }
                    var R = i._joinOwnerPath("/"),
                        v = m[R];
                    v || (m[R] = v = []), v.push(i), i.propertyOwner = p._strings[a.getUint16()];
                    var x = a.getUint16();
                    for (i._setPropertyCount(x), r = 0; r < x; r++) {
                        i._setPropertyByIndex(r, p._strings[a.getUint16()]);
                    }
                    var I = R + "." + i.propertyOwner + "." + i._joinProperty(".");
                    f[I] = i, i.fullPath = I;
                    var A = a.getUint16();
                    for (i._setKeyframeCount(A), r = 0; r < A; r++) {
                        switch (g) {
                            case 0:
                                var M = new u();
                                i._setKeyframeByIndex(r, M), M.time = n[a.getUint16()], M.inTangent = a.getFloat32(),
                                    M.outTangent = a.getFloat32(), M.value = a.getFloat32();
                                break;

                            case 1:
                            case 3:
                            case 4:
                                var D = new T();
                                if (i._setKeyframeByIndex(r, D), D.time = n[a.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                    for (var L = D.data = new Float32Array(9), y = 0; y < 3; y++) {
                                        L[y] = a.getFloat32();
                                    }
                                    for (y = 0; y < 3; y++) {
                                        L[3 + y] = a.getFloat32();
                                    }
                                    for (y = 0; y < 3; y++) {
                                        L[6 + y] = a.getFloat32();
                                    }
                                } else {
                                    var C = D.inTangent,
                                        O = D.outTangent,
                                        N = D.value;
                                    C.x = a.getFloat32(), C.y = a.getFloat32(), C.z = a.getFloat32(), O.x = a.getFloat32(),
                                        O.y = a.getFloat32(), O.z = a.getFloat32(), N.x = a.getFloat32(), N.y = a.getFloat32(),
                                        N.z = a.getFloat32();
                                }
                                break;

                            case 2:
                                var P = new E();
                                if (i._setKeyframeByIndex(r, P), P.time = n[a.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                    for (L = P.data = new Float32Array(12), y = 0; y < 4; y++) {
                                        L[y] = a.getFloat32();
                                    }
                                    for (y = 0; y < 4; y++) {
                                        L[4 + y] = a.getFloat32();
                                    }
                                    for (y = 0; y < 4; y++) {
                                        L[8 + y] = a.getFloat32();
                                    }
                                } else {
                                    var b = P.inTangent,
                                        V = P.outTangent,
                                        w = P.value;
                                    b.x = a.getFloat32(), b.y = a.getFloat32(), b.z = a.getFloat32(), b.w = a.getFloat32(),
                                        V.x = a.getFloat32(), V.y = a.getFloat32(), V.z = a.getFloat32(), V.w = a.getFloat32(),
                                        w.x = a.getFloat32(), w.y = a.getFloat32(), w.z = a.getFloat32(), w.w = a.getFloat32();
                                }
                                break;

                            default:
                                throw "AnimationClipParser03:unknown type.";
                        }
                    }
                }
                var F = a.getUint16();
                for (e = 0; e < F; e++) {
                    var B, U = new c();
                    U.time = Math.min(l, a.getFloat32()), U.eventName = p._strings[a.getUint16()];
                    var G = a.getUint16();
                    for (G > 0 && (U.params = B = []), r = 0; r < G; r++) {
                        switch (a.getByte()) {
                            case 0:
                                B.push(!!a.getByte());
                                break;

                            case 1:
                                B.push(a.getInt32());
                                break;

                            case 2:
                                B.push(a.getFloat32());
                                break;

                            case 3:
                                B.push(p._strings[a.getUint16()]);
                                break;

                            default:
                                throw new Error("unknown type.");
                        }
                    }
                    o.addEvent(U);
                }
            }
        }]);
        return p;
    }();
    p._strings = [], p._BLOCK = {
        count: 0
    }, p._DATA = {
        offset: 0,
        size: 0
    };
    var g = /* */ function() {
        function g() {
            _classCallCheck(this, g);
        }
        _createClass(g, null, [{
            key: "__init__",
            value: function __init__() {
                for (var e = 0; e < 256; ++e) {
                    var t = e - 127;
                    t < -27 ? (g._baseTable[0 | e] = 0, g._baseTable[256 | e] = 32768, g._shiftTable[0 | e] = 24,
                        g._shiftTable[256 | e] = 24) : t < -14 ? (g._baseTable[0 | e] = 1024 >> -t - 14,
                        g._baseTable[256 | e] = 1024 >> -t - 14 | 32768, g._shiftTable[0 | e] = -t - 1,
                        g._shiftTable[256 | e] = -t - 1) : t <= 15 ? (g._baseTable[0 | e] = t + 15 << 10,
                        g._baseTable[256 | e] = t + 15 << 10 | 32768, g._shiftTable[0 | e] = 13, g._shiftTable[256 | e] = 13) : t < 128 ? (g._baseTable[0 | e] = 31744,
                        g._baseTable[256 | e] = 64512, g._shiftTable[0 | e] = 24, g._shiftTable[256 | e] = 24) : (g._baseTable[0 | e] = 31744,
                        g._baseTable[256 | e] = 64512, g._shiftTable[0 | e] = 13, g._shiftTable[256 | e] = 13);
                }
                for (g._mantissaTable[0] = 0, e = 1; e < 1024; ++e) {
                    var r = e << 13;
                    for (t = 0; 0 == (8388608 & r);) {
                        t -= 8388608, r <<= 1;
                    }
                    r &= -8388609, t += 947912704, g._mantissaTable[e] = r | t;
                }
                for (e = 1024; e < 2048; ++e) {
                    g._mantissaTable[e] = 939524096 + (e - 1024 << 13);
                }
                for (g._exponentTable[0] = 0, e = 1; e < 31; ++e) {
                    g._exponentTable[e] = e << 23;
                }
                for (g._exponentTable[31] = 1199570944, g._exponentTable[32] = 2147483648, e = 33; e < 63; ++e) {
                    g._exponentTable[e] = 2147483648 + (e - 32 << 23);
                }
                for (g._exponentTable[63] = 3347054592, g._offsetTable[0] = 0, e = 1; e < 64; ++e) {
                    g._offsetTable[e] = 32 === e ? 0 : 1024;
                }
            }
        }, {
            key: "roundToFloat16Bits",
            value: function roundToFloat16Bits(e) {
                g._floatView[0] = e;
                var t = g._uint32View[0],
                    r = t >> 23 & 511;
                return g._baseTable[r] + ((8388607 & t) >> g._shiftTable[r]);
            }
        }, {
            key: "convertToNumber",
            value: function convertToNumber(e) {
                var t = e >> 10;
                return g._uint32View[0] = g._mantissaTable[g._offsetTable[t] + (1023 & e)] + g._exponentTable[t],
                    g._floatView[0];
            }
        }]);
        return g;
    }();
    g._buffer = new ArrayBuffer(4), g._floatView = new Float32Array(g._buffer), g._uint32View = new Uint32Array(g._buffer),
        g._baseTable = new Uint32Array(512), g._shiftTable = new Uint32Array(512), g._mantissaTable = new Uint32Array(2048),
        g._exponentTable = new Uint32Array(64), g._offsetTable = new Uint32Array(64);
    var S = /* */ function() {
        function S() {
            _classCallCheck(this, S);
        }
        _createClass(S, null, [{
            key: "READ_DATA",
            value: function READ_DATA() {
                S._DATA.offset = S._reader.getUint32(), S._DATA.size = S._reader.getUint32();
            }
        }, {
            key: "READ_BLOCK",
            value: function READ_BLOCK() {
                for (var e = S._BLOCK.count = S._reader.getUint16(), t = S._BLOCK.blockStarts = [], r = S._BLOCK.blockLengths = [], i = 0; i < e; i++) {
                    t.push(S._reader.getUint32()), r.push(S._reader.getUint32());
                }
            }
        }, {
            key: "READ_STRINGS",
            value: function READ_STRINGS() {
                var e = S._reader.getUint32(),
                    t = S._reader.getUint16(),
                    r = S._reader.pos;
                S._reader.pos = e + S._DATA.offset;
                for (var i = 0; i < t; i++) {
                    S._strings[i] = S._reader.readUTFString();
                }
                S._reader.pos = r;
            }
        }, {
            key: "parse",
            value: function parse(e, t, r) {
                S._animationClip = e, S._reader = t, S._version = r, S.READ_DATA(), S.READ_BLOCK(),
                    S.READ_STRINGS();
                for (var i = 0, a = S._BLOCK.count; i < a; i++) {
                    var n = t.getUint16(),
                        s = S._strings[n],
                        o = S["READ_" + s];
                    if (null == o) throw new Error("model file err,no this function:" + n + " " + s);
                    o.call(null);
                }
                S._version = null, S._reader = null, S._animationClip = null;
            }
        }, {
            key: "READ_ANIMATIONS",
            value: function READ_ANIMATIONS() {
                var e, r, i, a = S._reader,
                    n = (a.__getBuffer(), []),
                    s = a.getUint16();
                for (n.length = s, e = 0; e < s; e++) {
                    n[e] = a.getFloat32();
                }
                var o = S._animationClip;
                o.name = S._strings[a.getUint16()];
                var l = o._duration = a.getFloat32();
                o.islooping = !!a.getByte(), o._frameRate = a.getInt16();
                var _ = a.getInt16(),
                    d = o._nodes;
                d.count = _;
                var m = o._nodesMap = {},
                    f = o._nodesDic = {};
                for (e = 0; e < _; e++) {
                    i = new h(), d.setNodeByIndex(e, i), i._indexInList = e;
                    var p = i.type = a.getUint8(),
                        R = a.getUint16();
                    for (i._setOwnerPathCount(R), r = 0; r < R; r++) {
                        i._setOwnerPathByIndex(r, S._strings[a.getUint16()]);
                    }
                    var v = i._joinOwnerPath("/"),
                        x = m[v];
                    x || (m[v] = x = []), x.push(i), i.propertyOwner = S._strings[a.getUint16()];
                    var I = a.getUint16();
                    for (i._setPropertyCount(I), r = 0; r < I; r++) {
                        i._setPropertyByIndex(r, S._strings[a.getUint16()]);
                    }
                    var A = v + "." + i.propertyOwner + "." + i._joinProperty(".");
                    f[A] = i, i.fullPath = A;
                    var M = a.getUint16();
                    switch (i._setKeyframeCount(M), S._version) {
                        case "LAYAANIMATION:04":
                            for (r = 0; r < M; r++) {
                                switch (p) {
                                    case 0:
                                        var D = new u();
                                        i._setKeyframeByIndex(r, D), D.time = n[a.getUint16()], D.inTangent = a.getFloat32(),
                                            D.outTangent = a.getFloat32(), D.value = a.getFloat32();
                                        break;

                                    case 1:
                                    case 3:
                                    case 4:
                                        var L = new T();
                                        if (i._setKeyframeByIndex(r, L), L.time = n[a.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                            for (var y = L.data = new Float32Array(9), C = 0; C < 3; C++) {
                                                y[C] = a.getFloat32();
                                            }
                                            for (C = 0; C < 3; C++) {
                                                y[3 + C] = a.getFloat32();
                                            }
                                            for (C = 0; C < 3; C++) {
                                                y[6 + C] = a.getFloat32();
                                            }
                                        } else {
                                            var O = L.inTangent,
                                                N = L.outTangent,
                                                P = L.value;
                                            O.x = a.getFloat32(), O.y = a.getFloat32(), O.z = a.getFloat32(), N.x = a.getFloat32(),
                                                N.y = a.getFloat32(), N.z = a.getFloat32(), P.x = a.getFloat32(), P.y = a.getFloat32(),
                                                P.z = a.getFloat32();
                                        }
                                        break;

                                    case 2:
                                        var b = new E();
                                        if (i._setKeyframeByIndex(r, b), b.time = n[a.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                            for (y = b.data = new Float32Array(12), C = 0; C < 4; C++) {
                                                y[C] = a.getFloat32();
                                            }
                                            for (C = 0; C < 4; C++) {
                                                y[4 + C] = a.getFloat32();
                                            }
                                            for (C = 0; C < 4; C++) {
                                                y[8 + C] = a.getFloat32();
                                            }
                                        } else {
                                            var V = b.inTangent,
                                                w = b.outTangent,
                                                F = b.value;
                                            V.x = a.getFloat32(), V.y = a.getFloat32(), V.z = a.getFloat32(), V.w = a.getFloat32(),
                                                w.x = a.getFloat32(), w.y = a.getFloat32(), w.z = a.getFloat32(), w.w = a.getFloat32(),
                                                F.x = a.getFloat32(), F.y = a.getFloat32(), F.z = a.getFloat32(), F.w = a.getFloat32();
                                        }
                                        break;

                                    default:
                                        throw "AnimationClipParser04:unknown type.";
                                }
                            }
                            break;

                        case "LAYAANIMATION:COMPRESSION_04":
                            for (r = 0; r < M; r++) {
                                switch (p) {
                                    case 0:
                                        D = new u(), i._setKeyframeByIndex(r, D), D.time = n[a.getUint16()], D.inTangent = g.convertToNumber(a.getUint16()),
                                            D.outTangent = g.convertToNumber(a.getUint16()), D.value = g.convertToNumber(a.getUint16());
                                        break;

                                    case 1:
                                    case 3:
                                    case 4:
                                        if (L = new T(), i._setKeyframeByIndex(r, L), L.time = n[a.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                            for (y = L.data = new Float32Array(9), C = 0; C < 3; C++) {
                                                y[C] = g.convertToNumber(a.getUint16());
                                            }
                                            for (C = 0; C < 3; C++) {
                                                y[3 + C] = g.convertToNumber(a.getUint16());
                                            }
                                            for (C = 0; C < 3; C++) {
                                                y[6 + C] = g.convertToNumber(a.getUint16());
                                            }
                                        } else O = L.inTangent, N = L.outTangent, P = L.value, O.x = g.convertToNumber(a.getUint16()),
                                            O.y = g.convertToNumber(a.getUint16()), O.z = g.convertToNumber(a.getUint16()),
                                            N.x = g.convertToNumber(a.getUint16()), N.y = g.convertToNumber(a.getUint16()),
                                            N.z = g.convertToNumber(a.getUint16()), P.x = g.convertToNumber(a.getUint16()),
                                            P.y = g.convertToNumber(a.getUint16()), P.z = g.convertToNumber(a.getUint16());
                                        break;

                                    case 2:
                                        if (b = new E(), i._setKeyframeByIndex(r, b), b.time = n[a.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                            for (y = b.data = new Float32Array(12), C = 0; C < 4; C++) {
                                                y[C] = g.convertToNumber(a.getUint16());
                                            }
                                            for (C = 0; C < 4; C++) {
                                                y[4 + C] = g.convertToNumber(a.getUint16());
                                            }
                                            for (C = 0; C < 4; C++) {
                                                y[8 + C] = g.convertToNumber(a.getUint16());
                                            }
                                        } else V = b.inTangent, w = b.outTangent, F = b.value, V.x = g.convertToNumber(a.getUint16()),
                                            V.y = g.convertToNumber(a.getUint16()), V.z = g.convertToNumber(a.getUint16()),
                                            V.w = g.convertToNumber(a.getUint16()), w.x = g.convertToNumber(a.getUint16()),
                                            w.y = g.convertToNumber(a.getUint16()), w.z = g.convertToNumber(a.getUint16()),
                                            w.w = g.convertToNumber(a.getUint16()), F.x = g.convertToNumber(a.getUint16()),
                                            F.y = g.convertToNumber(a.getUint16()), F.z = g.convertToNumber(a.getUint16()),
                                            F.w = g.convertToNumber(a.getUint16());
                                        break;

                                    default:
                                        throw "AnimationClipParser04:unknown type.";
                                }
                            }
                    }
                }
                var B = a.getUint16();
                for (e = 0; e < B; e++) {
                    var U, G = new c();
                    G.time = Math.min(l, a.getFloat32()), G.eventName = S._strings[a.getUint16()];
                    var z = a.getUint16();
                    for (z > 0 && (G.params = U = []), r = 0; r < z; r++) {
                        switch (a.getByte()) {
                            case 0:
                                U.push(!!a.getByte());
                                break;

                            case 1:
                                U.push(a.getInt32());
                                break;

                            case 2:
                                U.push(a.getFloat32());
                                break;

                            case 3:
                                U.push(S._strings[a.getUint16()]);
                                break;

                            default:
                                throw new Error("unknown type.");
                        }
                    }
                    o.addEvent(G);
                }
            }
        }]);
        return S;
    }();
    S._strings = [], S._BLOCK = {
        count: 0
    }, S._DATA = {
        offset: 0,
        size: 0
    };
    var R = /* */ function() {
        function R() {
            _classCallCheck(this, R);
            this._nodes = [];
        }
        _createClass(R, [{
            key: "getNodeByIndex",
            value: function getNodeByIndex(e) {
                return this._nodes[e];
            }
        }, {
            key: "setNodeByIndex",
            value: function setNodeByIndex(e, t) {
                this._nodes[e] = t;
            }
        }, {
            key: "count",
            get: function get() {
                return this._nodes.length;
            },
            set: function set(e) {
                this._nodes.length = e;
            }
        }]);
        return R;
    }();
    var v = /* */ function() {
        function v() {
            _classCallCheck(this, v);
        }
        _createClass(v, null, [{
            key: "lightAttenTexture",
            value: function lightAttenTexture(e, t, r, i, a, n) {
                var s = e / r,
                    o = 1 / (1 + 25 * s);
                s >= .64 && (s > 1 ? o = 0 : o *= 1 - (s - .64) / .36), n[a] = Math.floor(255 * o + .5);
            }
        }, {
            key: "haloTexture",
            value: function haloTexture(e, t, r, i, a, n) {
                var s = (e - (r >>= 1)) / r,
                    o = (t - (i >>= 1)) / i,
                    l = s * s + o * o;
                l > 1 && (l = 1), n[a] = Math.floor(255 * (1 - l) + .5);
            }
        }, {
            key: "_generateTexture2D",
            value: function _generateTexture2D(e, r, i, a) {
                var n = 0,
                    s = 0;
                switch (e.format) {
                    case t.TextureFormat.R8G8B8:
                        s = 3;
                        break;

                    case t.TextureFormat.R8G8B8A8:
                        s = 4;
                        break;

                    case t.TextureFormat.Alpha8:
                        s = 1;
                        break;

                    default:
                        throw "GeneratedTexture._generateTexture: unkonw texture format.";
                }
                for (var o = new Uint8Array(r * i * s), l = 0; l < i; l++) {
                    for (var _ = 0; _ < r; _++) {
                        a(_, l, r, i, n, o), n += s;
                    }
                }
                e.setPixels(o);
            }
        }]);
        return v;
    }();
    var x = function x() {
        _classCallCheck(this, x);
    };
    x._bullet = null, x._enablePhysics = !1;
    var I = /* */ function() {
        function I() {
            _classCallCheck(this, I);
        }
        _createClass(I, null, [{
            key: "_createFloatTextureBuffer",
            value: function _createFloatTextureBuffer(e, r) {
                var i = new t.Texture2D(e, r, t.TextureFormat.R32G32B32A32, !1, !1);
                return i.filterMode = t.FilterMode.Point, i.wrapModeU = t.WarpMode.Clamp, i.wrapModeV = t.WarpMode.Clamp,
                    i.anisoLevel = 0, i;
            }
        }, {
            key: "_convertToLayaVec3",
            value: function _convertToLayaVec3(e, t, r) {
                var i = x._bullet;
                t.x = r ? -i.btVector3_x(e) : i.btVector3_x(e), t.y = i.btVector3_y(e), t.z = i.btVector3_z(e);
            }
        }, {
            key: "_convertToBulletVec3",
            value: function _convertToBulletVec3(e, t, r) {
                x._bullet.btVector3_setValue(t, r ? -e.x : e.x, e.y, e.z);
            }
        }, {
            key: "_rotationTransformScaleSkinAnimation",
            value: function _rotationTransformScaleSkinAnimation(e, t, r, i, a, n, s, o, l, _, h, c) {
                var d, u, m, f, E, T = I._tempArray16_0,
                    p = I._tempArray16_1,
                    g = I._tempArray16_2,
                    S = i + i,
                    R = a + a,
                    v = n + n,
                    x = i * S,
                    A = a * S,
                    M = a * R,
                    D = n * S,
                    L = n * R,
                    y = n * v,
                    C = s * S,
                    O = s * R,
                    N = s * v;
                for (T[15] = 1, T[0] = 1 - M - y, T[1] = A + N, T[2] = D - O, T[4] = A - N, T[5] = 1 - x - y,
                    T[6] = L + C, T[8] = D + O, T[9] = L - C, T[10] = 1 - x - M, p[15] = 1, p[0] = o,
                    p[5] = l, p[10] = _, d = 0; d < 4; d++) {
                    u = T[d], m = T[d + 4], f = T[d + 8], E = T[d + 12], g[d] = u, g[d + 4] = m, g[d + 8] = f,
                        g[d + 12] = u * e + m * t + f * r + E;
                }
                for (d = 0; d < 4; d++) {
                    u = g[d], m = g[d + 4], f = g[d + 8], E = g[d + 12], h[d + c] = u * p[0] + m * p[1] + f * p[2] + E * p[3],
                        h[d + c + 4] = u * p[4] + m * p[5] + f * p[6] + E * p[7], h[d + c + 8] = u * p[8] + m * p[9] + f * p[10] + E * p[11],
                        h[d + c + 12] = u * p[12] + m * p[13] + f * p[14] + E * p[15];
                }
            }
        }, {
            key: "_computeBoneAndAnimationDatasByBindPoseMatrxix",
            value: function _computeBoneAndAnimationDatasByBindPoseMatrxix(e, t, r, i, a, n) {
                var s, o, l = 0,
                    _ = 0,
                    h = e.length;
                for (s = 0; s < h; l += e[s].keyframeWidth, _ += 16, s++) {
                    I._rotationTransformScaleSkinAnimation(t[l + 0], t[l + 1], t[l + 2], t[l + 3], t[l + 4], t[l + 5], t[l + 6], t[l + 7], t[l + 8], t[l + 9], i, _),
                        0 != s && (o = 16 * e[s].parentIndex, I.mulMatrixByArray(i, o, i, _, i, _));
                }
                var c = r.length;
                for (s = 0; s < c; s++) {
                    I.mulMatrixByArrayAndMatrixFast(i, 16 * n[s], r[s], a, 16 * s);
                }
            }
        }, {
            key: "_computeAnimationDatasByArrayAndMatrixFast",
            value: function _computeAnimationDatasByArrayAndMatrixFast(e, t, r, i) {
                for (var a = 0, n = e.length; a < n; a++) {
                    I.mulMatrixByArrayAndMatrixFast(t, 16 * i[a], e[a], r, 16 * a);
                }
            }
        }, {
            key: "_computeBoneAndAnimationDatasByBindPoseMatrxixOld",
            value: function _computeBoneAndAnimationDatasByBindPoseMatrxixOld(e, t, r, i, a) {
                var n, s, o = 0,
                    l = 0,
                    _ = e.length;
                for (n = 0; n < _; o += e[n].keyframeWidth, l += 16, n++) {
                    I._rotationTransformScaleSkinAnimation(t[o + 7], t[o + 8], t[o + 9], t[o + 3], t[o + 4], t[o + 5], t[o + 6], t[o + 0], t[o + 1], t[o + 2], i, l),
                        0 != n && (s = 16 * e[n].parentIndex, I.mulMatrixByArray(i, s, i, l, i, l));
                }
                var h = r.length;
                for (n = 0; n < h; n++) {
                    var c = 16 * n;
                    I.mulMatrixByArrayAndMatrixFast(i, c, r[n], a, c);
                }
            }
        }, {
            key: "_computeAnimationDatasByArrayAndMatrixFastOld",
            value: function _computeAnimationDatasByArrayAndMatrixFastOld(e, t, r) {
                for (var i = e.length, a = 0; a < i; a++) {
                    var n = 16 * a;
                    I.mulMatrixByArrayAndMatrixFast(t, n, e[a], r, n);
                }
            }
        }, {
            key: "_computeRootAnimationData",
            value: function _computeRootAnimationData(e, t, r) {
                for (var i = 0, a = 0, n = 0, s = e.length; i < s; a += e[i].keyframeWidth, n += 16,
                    i++) {
                    I.createAffineTransformationArray(t[a + 0], t[a + 1], t[a + 2], t[a + 3], t[a + 4], t[a + 5], t[a + 6], t[a + 7], t[a + 8], t[a + 9], r, n);
                }
            }
        }, {
            key: "transformVector3ArrayByQuat",
            value: function transformVector3ArrayByQuat(e, t, r, i, a) {
                var n = e[t],
                    s = e[t + 1],
                    o = e[t + 2],
                    l = r.x,
                    _ = r.y,
                    h = r.z,
                    c = r.w,
                    d = c * n + _ * o - h * s,
                    u = c * s + h * n - l * o,
                    m = c * o + l * s - _ * n,
                    f = -l * n - _ * s - h * o;
                i[a] = d * c + f * -l + u * -h - m * -_, i[a + 1] = u * c + f * -_ + m * -l - d * -h,
                    i[a + 2] = m * c + f * -h + d * -_ - u * -l;
            }
        }, {
            key: "mulMatrixByArray",
            value: function mulMatrixByArray(e, t, r, i, a, n) {
                var s, o, l, _, h;
                if (a === r) {
                    for (r = I._tempArray16_3, s = 0; s < 16; ++s) {
                        r[s] = a[n + s];
                    }
                    i = 0;
                }
                for (s = 0; s < 4; s++) {
                    o = e[t + s], l = e[t + s + 4], _ = e[t + s + 8], h = e[t + s + 12], a[n + s] = o * r[i + 0] + l * r[i + 1] + _ * r[i + 2] + h * r[i + 3],
                        a[n + s + 4] = o * r[i + 4] + l * r[i + 5] + _ * r[i + 6] + h * r[i + 7], a[n + s + 8] = o * r[i + 8] + l * r[i + 9] + _ * r[i + 10] + h * r[i + 11],
                        a[n + s + 12] = o * r[i + 12] + l * r[i + 13] + _ * r[i + 14] + h * r[i + 15];
                }
            }
        }, {
            key: "mulMatrixByArrayFast",
            value: function mulMatrixByArrayFast(e, t, r, i, a, n) {
                var s, o, l, _, h;
                for (s = 0; s < 4; s++) {
                    o = e[t + s], l = e[t + s + 4], _ = e[t + s + 8], h = e[t + s + 12], a[n + s] = o * r[i + 0] + l * r[i + 1] + _ * r[i + 2] + h * r[i + 3],
                        a[n + s + 4] = o * r[i + 4] + l * r[i + 5] + _ * r[i + 6] + h * r[i + 7], a[n + s + 8] = o * r[i + 8] + l * r[i + 9] + _ * r[i + 10] + h * r[i + 11],
                        a[n + s + 12] = o * r[i + 12] + l * r[i + 13] + _ * r[i + 14] + h * r[i + 15];
                }
            }
        }, {
            key: "mulMatrixByArrayAndMatrixFast",
            value: function mulMatrixByArrayAndMatrixFast(e, t, r, i, a) {
                var n, s, o, l, _, h = r.elements,
                    c = h[0],
                    d = h[1],
                    u = h[2],
                    m = h[3],
                    f = h[4],
                    E = h[5],
                    T = h[6],
                    p = h[7],
                    g = h[8],
                    S = h[9],
                    R = h[10],
                    v = h[11],
                    x = h[12],
                    I = h[13],
                    A = h[14],
                    M = h[15],
                    D = t,
                    L = t + 4,
                    y = t + 8,
                    C = t + 12,
                    O = a,
                    N = a + 4,
                    P = a + 8,
                    b = a + 12;
                for (n = 0; n < 4; n++) {
                    s = e[D + n], o = e[L + n], l = e[y + n], _ = e[C + n], i[O + n] = s * c + o * d + l * u + _ * m,
                        i[N + n] = s * f + o * E + l * T + _ * p, i[P + n] = s * g + o * S + l * R + _ * v,
                        i[b + n] = s * x + o * I + l * A + _ * M;
                }
            }
        }, {
            key: "createAffineTransformationArray",
            value: function createAffineTransformationArray(e, t, r, i, a, n, s, o, l, _, h, c) {
                var d = i + i,
                    u = a + a,
                    m = n + n,
                    f = i * d,
                    E = i * u,
                    T = i * m,
                    p = a * u,
                    g = a * m,
                    S = n * m,
                    R = s * d,
                    v = s * u,
                    x = s * m;
                h[c + 0] = (1 - (p + S)) * o, h[c + 1] = (E + x) * o, h[c + 2] = (T - v) * o, h[c + 3] = 0,
                    h[c + 4] = (E - x) * l, h[c + 5] = (1 - (f + S)) * l, h[c + 6] = (g + R) * l, h[c + 7] = 0,
                    h[c + 8] = (T + v) * _, h[c + 9] = (g - R) * _, h[c + 10] = (1 - (f + p)) * _, h[c + 11] = 0,
                    h[c + 12] = e, h[c + 13] = t, h[c + 14] = r, h[c + 15] = 1;
            }
        }, {
            key: "transformVector3ArrayToVector3ArrayCoordinate",
            value: function transformVector3ArrayToVector3ArrayCoordinate(e, t, r, i, a) {
                var n = e[t + 0],
                    s = e[t + 1],
                    o = e[t + 2],
                    l = r.elements,
                    _ = n * l[3] + s * l[7] + o * l[11] + l[15];
                i[a] = n * l[0] + s * l[4] + o * l[8] + l[12] / _, i[a + 1] = n * l[1] + s * l[5] + o * l[9] + l[13] / _,
                    i[a + 2] = n * l[2] + s * l[6] + o * l[10] + l[14] / _;
            }
        }, {
            key: "transformVector3ArrayToVector3ArrayNormal",
            value: function transformVector3ArrayToVector3ArrayNormal(e, t, r, i, a) {
                var n = e[t + 0],
                    s = e[t + 1],
                    o = e[t + 2],
                    l = r.elements;
                i[a] = n * l[0] + s * l[4] + o * l[8], i[a + 1] = n * l[1] + s * l[5] + o * l[9],
                    i[a + 2] = n * l[2] + s * l[6] + o * l[10];
            }
        }, {
            key: "transformLightingMapTexcoordArray",
            value: function transformLightingMapTexcoordArray(e, t, r, i, a) {
                i[a + 0] = e[t + 0] * r.x + r.z, i[a + 1] = 1 - ((1 - e[t + 1]) * r.y + r.w);
            }
        }, {
            key: "getURLVerion",
            value: function getURLVerion(e) {
                var t = e.indexOf("?");
                return t >= 0 ? e.substr(t) : null;
            }
        }, {
            key: "_createAffineTransformationArray",
            value: function _createAffineTransformationArray(e, t, r, i) {
                var a = t.x,
                    n = t.y,
                    s = t.z,
                    o = t.w,
                    l = a + a,
                    _ = n + n,
                    h = s + s,
                    c = a * l,
                    d = a * _,
                    u = a * h,
                    m = n * _,
                    f = n * h,
                    E = s * h,
                    T = o * l,
                    p = o * _,
                    g = o * h,
                    S = r.x,
                    R = r.y,
                    v = r.z;
                i[0] = (1 - (m + E)) * S, i[1] = (d + g) * S, i[2] = (u - p) * S, i[3] = 0, i[4] = (d - g) * R,
                    i[5] = (1 - (c + E)) * R, i[6] = (f + T) * R, i[7] = 0, i[8] = (u + p) * v, i[9] = (f - T) * v,
                    i[10] = (1 - (c + m)) * v, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1;
            }
        }, {
            key: "_mulMatrixArray",
            value: function _mulMatrixArray(e, t, r, i) {
                var a, n, s, o, l, _ = t.elements,
                    h = _[0],
                    c = _[1],
                    d = _[2],
                    u = _[3],
                    m = _[4],
                    f = _[5],
                    E = _[6],
                    T = _[7],
                    p = _[8],
                    g = _[9],
                    S = _[10],
                    R = _[11],
                    v = _[12],
                    x = _[13],
                    I = _[14],
                    A = _[15],
                    M = i,
                    D = i + 4,
                    L = i + 8,
                    y = i + 12;
                for (a = 0; a < 4; a++) {
                    n = e[a], s = e[a + 4], o = e[a + 8], l = e[a + 12], r[M + a] = n * h + s * c + o * d + l * u,
                        r[D + a] = n * m + s * f + o * E + l * T, r[L + a] = n * p + s * g + o * S + l * R,
                        r[y + a] = n * v + s * x + o * I + l * A;
                }
            }
        }, {
            key: "arcTanAngle",
            value: function arcTanAngle(e, t) {
                return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
            }
        }, {
            key: "angleTo",
            value: function angleTo(e, t, r) {
                n.subtract(t, e, f.TEMPVector30), n.normalize(f.TEMPVector30, f.TEMPVector30), r.x = Math.asin(f.TEMPVector30.y),
                    r.y = I.arcTanAngle(-f.TEMPVector30.z, -f.TEMPVector30.x);
            }
        }, {
            key: "transformQuat",
            value: function transformQuat(e, t, r) {
                var i = t,
                    a = e.x,
                    n = e.y,
                    s = e.z,
                    o = i[0],
                    l = i[1],
                    _ = i[2],
                    h = i[3],
                    c = h * a + l * s - _ * n,
                    d = h * n + _ * a - o * s,
                    u = h * s + o * n - l * a,
                    m = -o * a - l * n - _ * s;
                r.x = c * h + m * -o + d * -_ - u * -l, r.y = d * h + m * -l + u * -o - c * -_,
                    r.z = u * h + m * -_ + c * -l - d * -o;
            }
        }, {
            key: "quaternionWeight",
            value: function quaternionWeight(e, t, r) {
                r.x = e.x * t, r.y = e.y * t, r.z = e.z * t, r.w = e.w;
            }
        }, {
            key: "quaternionConjugate",
            value: function quaternionConjugate(e, t) {
                t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = e.w;
            }
        }, {
            key: "scaleWeight",
            value: function scaleWeight(e, t, r) {
                var i = e.x,
                    a = e.y,
                    n = e.z;
                r.x = i > 0 ? Math.pow(Math.abs(i), t) : -Math.pow(Math.abs(i), t), r.y = a > 0 ? Math.pow(Math.abs(a), t) : -Math.pow(Math.abs(a), t),
                    r.z = n > 0 ? Math.pow(Math.abs(n), t) : -Math.pow(Math.abs(n), t);
            }
        }, {
            key: "scaleBlend",
            value: function scaleBlend(e, t, r, i) {
                var a = I._tempVector3_0,
                    n = I._tempVector3_1;
                I.scaleWeight(e, 1 - r, a), I.scaleWeight(t, r, n);
                var s = r > .5 ? t : e;
                i.x = s.x > 0 ? Math.abs(a.x * n.x) : -Math.abs(a.x * n.x), i.y = s.y > 0 ? Math.abs(a.y * n.y) : -Math.abs(a.y * n.y),
                    i.z = s.z > 0 ? Math.abs(a.z * n.z) : -Math.abs(a.z * n.z);
            }
        }, {
            key: "matrix4x4MultiplyFFF",
            value: function matrix4x4MultiplyFFF(e, t, r) {
                var i, a, n, s, o;
                if (r === t)
                    for (t = new Float32Array(16), i = 0; i < 16; ++i) {
                        t[i] = r[i];
                    }
                var l = t[0],
                    _ = t[1],
                    h = t[2],
                    c = t[3],
                    d = t[4],
                    u = t[5],
                    m = t[6],
                    f = t[7],
                    E = t[8],
                    T = t[9],
                    p = t[10],
                    g = t[11],
                    S = t[12],
                    R = t[13],
                    v = t[14],
                    x = t[15];
                for (i = 0; i < 4; i++) {
                    a = e[i], n = e[i + 4], s = e[i + 8], o = e[i + 12], r[i] = a * l + n * _ + s * h + o * c,
                        r[i + 4] = a * d + n * u + s * m + o * f, r[i + 8] = a * E + n * T + s * p + o * g,
                        r[i + 12] = a * S + n * R + s * v + o * x;
                }
            }
        }, {
            key: "matrix4x4MultiplyFFFForNative",
            value: function matrix4x4MultiplyFFFForNative(e, r, i) {
                t.LayaGL.instance.matrix4x4Multiply(e, r, i);
            }
        }, {
            key: "matrix4x4MultiplyMFM",
            value: function matrix4x4MultiplyMFM(e, t, r) {
                I.matrix4x4MultiplyFFF(e.elements, t, r.elements);
            }
        }, {
            key: "_buildTexture2D",
            value: function _buildTexture2D(e, r, i, a) {
                var n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
                var s = new t.Texture2D(e, r, i, n, !0);
                return s.anisoLevel = 1, s.filterMode = t.FilterMode.Point, v._generateTexture2D(s, e, r, a),
                    s;
            }
        }, {
            key: "_drawBound",
            value: function _drawBound(e, t, r) {
                e.lineCount + 12 > e.maxLineCount && (e.maxLineCount += 12);
                var i = I._tempVector3_0,
                    a = I._tempVector3_1,
                    n = t.min,
                    s = t.max;
                i.setValue(n.x, n.y, n.z), a.setValue(s.x, n.y, n.z), e.addLine(i, a, r, r), i.setValue(n.x, n.y, n.z),
                    a.setValue(n.x, n.y, s.z), e.addLine(i, a, r, r), i.setValue(s.x, n.y, n.z), a.setValue(s.x, n.y, s.z),
                    e.addLine(i, a, r, r), i.setValue(n.x, n.y, s.z), a.setValue(s.x, n.y, s.z), e.addLine(i, a, r, r),
                    i.setValue(n.x, n.y, n.z), a.setValue(n.x, s.y, n.z), e.addLine(i, a, r, r), i.setValue(n.x, n.y, s.z),
                    a.setValue(n.x, s.y, s.z), e.addLine(i, a, r, r), i.setValue(s.x, n.y, n.z), a.setValue(s.x, s.y, n.z),
                    e.addLine(i, a, r, r), i.setValue(s.x, n.y, s.z), a.setValue(s.x, s.y, s.z), e.addLine(i, a, r, r),
                    i.setValue(n.x, s.y, n.z), a.setValue(s.x, s.y, n.z), e.addLine(i, a, r, r), i.setValue(n.x, s.y, n.z),
                    a.setValue(n.x, s.y, s.z), e.addLine(i, a, r, r), i.setValue(s.x, s.y, n.z), a.setValue(s.x, s.y, s.z),
                    e.addLine(i, a, r, r), i.setValue(n.x, s.y, s.z), a.setValue(s.x, s.y, s.z), e.addLine(i, a, r, r);
            }
        }, {
            key: "_getHierarchyPath",
            value: function _getHierarchyPath(e, t, r) {
                r.length = 0;
                for (var i = t; i !== e;) {
                    var a = i._parent;
                    if (!a) return null;
                    r.push(a.getChildIndex(i)), i = a;
                }
                return r;
            }
        }, {
            key: "_getNodeByHierarchyPath",
            value: function _getNodeByHierarchyPath(e, t) {
                for (var r = e, i = t.length - 1; i >= 0; i--) {
                    r = r.getChildAt(t[i]);
                }
                return r;
            }
        }]);
        return I;
    }();
    I._tempVector3_0 = new n(), I._tempVector3_1 = new n(), I._tempArray16_0 = new Float32Array(16),
        I._tempArray16_1 = new Float32Array(16), I._tempArray16_2 = new Float32Array(16),
        I._tempArray16_3 = new Float32Array(16), I._compIdToNode = new Object();
    var A = /* */ function(_t$Resource) {
        _inherits(A, _t$Resource);

        function A() {
            var _this3;
            _classCallCheck(this, A);
            _this3 = _possibleConstructorReturn(this, _getPrototypeOf(A).call(this)), _this3._nodes = new R(),
                _this3._animationEvents = [];
            return _this3;
        }
        _createClass(A, [{
            key: "duration",
            value: function duration() {
                return this._duration;
            }
        }, {
            key: "_hermiteInterpolate",
            value: function _hermiteInterpolate(e, t, r, i) {
                var a = e.outTangent,
                    n = t.inTangent;
                if (Number.isFinite(a) && Number.isFinite(n)) {
                    var s = r * r,
                        o = s * r,
                        l = o - 2 * s + r,
                        _ = o - s,
                        h = -2 * o + 3 * s;
                    return (2 * o - 3 * s + 1) * e.value + l * a * i + _ * n * i + h * t.value;
                }
                return e.value;
            }
        }, {
            key: "_hermiteInterpolateVector3",
            value: function _hermiteInterpolateVector3(e, t, r, i, a) {
                var n = e.value,
                    s = e.outTangent,
                    o = t.value,
                    l = t.inTangent,
                    _ = r * r,
                    h = _ * r,
                    c = 2 * h - 3 * _ + 1,
                    d = h - 2 * _ + r,
                    u = h - _,
                    m = -2 * h + 3 * _,
                    f = s.x,
                    E = l.x;
                Number.isFinite(f) && Number.isFinite(E) ? a.x = c * n.x + d * f * i + u * E * i + m * o.x : a.x = n.x,
                    f = s.y, E = l.y, Number.isFinite(f) && Number.isFinite(E) ? a.y = c * n.y + d * f * i + u * E * i + m * o.y : a.y = n.y,
                    f = s.z, E = l.z, Number.isFinite(f) && Number.isFinite(E) ? a.z = c * n.z + d * f * i + u * E * i + m * o.z : a.z = n.z;
            }
        }, {
            key: "_hermiteInterpolateQuaternion",
            value: function _hermiteInterpolateQuaternion(e, t, r, i, a) {
                var n = e.value,
                    s = e.outTangent,
                    o = t.value,
                    l = t.inTangent,
                    _ = r * r,
                    h = _ * r,
                    c = 2 * h - 3 * _ + 1,
                    d = h - 2 * _ + r,
                    u = h - _,
                    m = -2 * h + 3 * _,
                    f = s.x,
                    E = l.x;
                Number.isFinite(f) && Number.isFinite(E) ? a.x = c * n.x + d * f * i + u * E * i + m * o.x : a.x = n.x,
                    f = s.y, E = l.y, Number.isFinite(f) && Number.isFinite(E) ? a.y = c * n.y + d * f * i + u * E * i + m * o.y : a.y = n.y,
                    f = s.z, E = l.z, Number.isFinite(f) && Number.isFinite(E) ? a.z = c * n.z + d * f * i + u * E * i + m * o.z : a.z = n.z,
                    f = s.w, E = l.w, Number.isFinite(f) && Number.isFinite(E) ? a.w = c * n.w + d * f * i + u * E * i + m * o.w : a.w = n.w;
            }
        }, {
            key: "_evaluateClipDatasRealTime",
            value: function _evaluateClipDatasRealTime(e, t, r, i, a, n) {
                for (var s = 0, o = e.count; s < o; s++) {
                    var l, _ = e.getNodeByIndex(s),
                        h = _.type,
                        c = _._keyFrames,
                        d = c.length,
                        u = r[s];
                    if (a)
                        for (-1 !== u && t < c[u].time && (u = -1, r[s] = u), l = u + 1; l < d && !(c[l].time > t);) {
                            u++, l++, r[s] = u;
                        } else
                            for ((l = u + 1) !== d && t > c[l].time && (u = d - 1, r[s] = u), l = u + 1; u > -1 && !(c[u].time < t);) {
                                u--, l--, r[s] = u;
                            }
                    var m = l === d;
                    switch (h) {
                        case 0:
                            if (-1 !== u) {
                                var E = c[u];
                                if (m) n[s] = E.value;
                                else {
                                    var T, p = c[l],
                                        g = p.time - E.time;
                                    T = 0 !== g ? (t - E.time) / g : 0, n[s] = this._hermiteInterpolate(E, p, T, g);
                                }
                            } else n[s] = c[0].value;
                            i && (n[s] = n[s] - c[0].value);
                            break;

                        case 1:
                        case 4:
                            var S = n[s];
                            if (this._evaluateFrameNodeVector3DatasRealTime(c, u, m, t, S), i) {
                                var R = c[0].value;
                                S.x -= R.x, S.y -= R.y, S.z -= R.z;
                            }
                            break;

                        case 2:
                            var v = n[s];
                            if (this._evaluateFrameNodeQuaternionDatasRealTime(c, u, m, t, v), i) {
                                var x = A._tempQuaternion0,
                                    M = c[0].value;
                                I.quaternionConjugate(M, x), f.multiply(x, v, v);
                            }
                            break;

                        case 3:
                            S = n[s], this._evaluateFrameNodeVector3DatasRealTime(c, u, m, t, S), i && (R = c[0].value,
                                S.x /= R.x, S.y /= R.y, S.z /= R.z);
                            break;

                        default:
                            throw "AnimationClip:unknown node type.";
                    }
                }
            }
        }, {
            key: "_evaluateClipDatasRealTimeForNative",
            value: function _evaluateClipDatasRealTimeForNative(e, r, i, a) {
                t.LayaGL.instance.evaluateClipDatasRealTime(e._nativeObj, r, i, a);
            }
        }, {
            key: "_evaluateFrameNodeVector3DatasRealTime",
            value: function _evaluateFrameNodeVector3DatasRealTime(e, t, r, i, a) {
                if (-1 !== t) {
                    var n = e[t];
                    if (r) {
                        var s = n.value;
                        a.x = s.x, a.y = s.y, a.z = s.z;
                    } else {
                        var o, l = e[t + 1],
                            _ = n.time,
                            h = l.time - _;
                        o = 0 !== h ? (i - _) / h : 0, this._hermiteInterpolateVector3(n, l, o, h, a);
                    }
                } else {
                    var c = e[0].value;
                    a.x = c.x, a.y = c.y, a.z = c.z;
                }
            }
        }, {
            key: "_evaluateFrameNodeQuaternionDatasRealTime",
            value: function _evaluateFrameNodeQuaternionDatasRealTime(e, t, r, i, a) {
                if (-1 !== t) {
                    var n = e[t];
                    if (r) {
                        var s = n.value;
                        a.x = s.x, a.y = s.y, a.z = s.z, a.w = s.w;
                    } else {
                        var o, l = e[t + 1],
                            _ = n.time,
                            h = l.time - _;
                        o = 0 !== h ? (i - _) / h : 0, this._hermiteInterpolateQuaternion(n, l, o, h, a);
                    }
                } else {
                    var c = e[0].value;
                    a.x = c.x, a.y = c.y, a.z = c.z, a.w = c.w;
                }
            }
        }, {
            key: "_binarySearchEventIndex",
            value: function _binarySearchEventIndex(e) {
                for (var t, r = 0, i = this._animationEvents.length - 1; r <= i;) {
                    t = Math.floor((r + i) / 2);
                    var a = this._animationEvents[t].time;
                    if (a == e) return t;
                    a > e ? i = t - 1 : r = t + 1;
                }
                return r;
            }
        }, {
            key: "addEvent",
            value: function addEvent(e) {
                var t = this._binarySearchEventIndex(e.time);
                this._animationEvents.splice(t, 0, e);
            }
        }, {
            key: "_disposeResource",
            value: function _disposeResource() {
                this._nodes = null, this._nodesMap = null;
            }
        }], [{
            key: "_parse",
            value: function _parse(e) {
                var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var a = new A(),
                    n = new t.Byte(e),
                    s = n.readUTFString();
                switch (s) {
                    case "LAYAANIMATION:03":
                        p.parse(a, n);
                        break;

                    case "LAYAANIMATION:04":
                    case "LAYAANIMATION:COMPRESSION_04":
                        S.parse(a, n, s);
                        break;

                    default:
                        throw "unknown animationClip version.";
                }
                return a;
            }
        }, {
            key: "load",
            value: function load(e, r) {
                t.ILaya.loader.create(e, r, null, A.ANIMATIONCLIP);
            }
        }]);
        return A;
    }(t.Resource);
    A.ANIMATIONCLIP = "ANIMATIONCLIP", A._tempQuaternion0 = new f();
    var M = /* */ function() {
        function M() {
            _classCallCheck(this, M);
            this._currentState = null;
        }
        _createClass(M, [{
            key: "_resetPlayState",
            value: function _resetPlayState(e) {
                this._finish = !1, this._startPlayTime = e, this._elapsedTime = e, this._playEventIndex = 0,
                    this._lastIsFront = !0;
            }
        }, {
            key: "_cloneTo",
            value: function _cloneTo(e) {
                e._finish = this._finish, e._startPlayTime = this._startPlayTime, e._elapsedTime = this._elapsedTime,
                    e._normalizedTime = this._normalizedTime, e._normalizedPlayTime = this._normalizedPlayTime,
                    e._playEventIndex = this._playEventIndex, e._lastIsFront = this._lastIsFront;
            }
        }, {
            key: "normalizedTime",
            get: function get() {
                return this._normalizedTime;
            }
        }, {
            key: "duration",
            get: function get() {
                return this._duration;
            }
        }, {
            key: "animatorState",
            get: function get() {
                return this._currentState;
            }
        }]);
        return M;
    }();
    var D = /* */ function() {
        function D(e) {
            _classCallCheck(this, D);
            this._defaultState = null, this._referenceCount = 0, this._playType = -1, this._crossDuration = -1,
                this._crossMark = 0, this._crossNodesOwnersCount = 0, this._crossNodesOwners = [],
                this._crossNodesOwnersIndicesMap = {}, this._srcCrossClipNodeIndices = [], this._destCrossClipNodeIndices = [],
                this._statesMap = {}, this._states = [], this._playStateInfo = new M(), this._crossPlayStateInfo = new M(),
                this.blendingMode = D.BLENDINGMODE_OVERRIDE, this.defaultWeight = 1, this.playOnWake = !0,
                this.name = e;
        }
        _createClass(D, [{
            key: "_removeClip",
            value: function _removeClip(e, t, r, i) {
                var a = i._clip,
                    n = e[r];
                if (e.splice(r, 1), delete t[i.name], this._animator) {
                    var s = a._nodes,
                        o = n._nodeOwners;
                    a._removeReference();
                    for (var l = 0, _ = s.count; l < _; l++) {
                        this._animator._removeKeyframeNodeOwner(o, s.getNodeByIndex(l));
                    }
                }
            }
        }, {
            key: "_getReferenceCount",
            value: function _getReferenceCount() {
                return this._referenceCount;
            }
        }, {
            key: "_addReference",
            value: function _addReference() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
                for (var t = 0, r = this._states.length; t < r; t++) {
                    this._states[t]._addReference(e);
                }
                this._referenceCount += e;
            }
        }, {
            key: "_removeReference",
            value: function _removeReference() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
                for (var t = 0, r = this._states.length; t < r; t++) {
                    this._states[t]._removeReference(e);
                }
                this._referenceCount -= e;
            }
        }, {
            key: "_clearReference",
            value: function _clearReference() {
                this._removeReference(-this._referenceCount);
            }
        }, {
            key: "getCurrentPlayState",
            value: function getCurrentPlayState() {
                return this._playStateInfo;
            }
        }, {
            key: "getAnimatorState",
            value: function getAnimatorState(e) {
                var t = this._statesMap[e];
                return t || null;
            }
        }, {
            key: "addState",
            value: function addState(e) {
                var t = e.name;
                if (this._statesMap[t]) throw "AnimatorControllerLayer:this stat's name has exist.";
                this._statesMap[t] = e, this._states.push(e), this._animator && (e._clip._addReference(),
                    this._animator._getOwnersByClip(e));
            }
        }, {
            key: "removeState",
            value: function removeState(e) {
                for (var t = this._states, r = -1, i = 0, a = t.length; i < a; i++) {
                    if (t[i] === e) {
                        r = i;
                        break;
                    }
                } -
                1 !== r && this._removeClip(t, this._statesMap, r, e);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._clearReference(), this._statesMap = null, this._states = null, this._playStateInfo = null,
                    this._crossPlayStateInfo = null, this._defaultState = null;
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t.name = this.name, t.blendingMode = this.blendingMode, t.defaultWeight = this.defaultWeight,
                    t.playOnWake = this.playOnWake;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new D(this.name);
                return this.cloneTo(e), e;
            }
        }, {
            key: "defaultState",
            get: function get() {
                return this._defaultState;
            },
            set: function set(e) {
                this._defaultState = e, this._statesMap[e.name] = e;
            }
        }]);
        return D;
    }();
    D.BLENDINGMODE_OVERRIDE = 0, D.BLENDINGMODE_ADDTIVE = 1;
    var L = /* */ function() {
        function L() {
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            _classCallCheck(this, L);
            var a = this.elements = new Float32Array(4);
            a[0] = e, a[1] = t, a[2] = r, a[3] = i;
        }
        _createClass(L, [{
            key: "fromArray",
            value: function fromArray(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[t + 2],
                    this.elements[3] = e[t + 3];
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e.elements,
                    r = this.elements;
                t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3];
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new L();
                return this.cloneTo(e), e;
            }
        }, {
            key: "length",
            value: function length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
        }, {
            key: "lengthSquared",
            value: function lengthSquared() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
        }, {
            key: "x",
            get: function get() {
                return this.elements[0];
            },
            set: function set(e) {
                this.elements[0] = e;
            }
        }, {
            key: "y",
            get: function get() {
                return this.elements[1];
            },
            set: function set(e) {
                this.elements[1] = e;
            }
        }, {
            key: "z",
            get: function get() {
                return this.elements[2];
            },
            set: function set(e) {
                this.elements[2] = e;
            }
        }, {
            key: "w",
            get: function get() {
                return this.elements[3];
            },
            set: function set(e) {
                this.elements[3] = e;
            }
        }], [{
            key: "lerp",
            value: function lerp(e, t, r, i) {
                var a = i.elements,
                    n = e.elements,
                    s = t.elements,
                    o = n[0],
                    l = n[1],
                    _ = n[2],
                    h = n[3];
                a[0] = o + r * (s[0] - o), a[1] = l + r * (s[1] - l), a[2] = _ + r * (s[2] - _),
                    a[3] = h + r * (s[3] - h);
            }
        }, {
            key: "transformByM4x4",
            value: function transformByM4x4(e, t, r) {
                var i = e.elements,
                    a = i[0],
                    n = i[1],
                    s = i[2],
                    o = i[3],
                    l = t.elements,
                    _ = r.elements;
                _[0] = a * l[0] + n * l[4] + s * l[8] + o * l[12], _[1] = a * l[1] + n * l[5] + s * l[9] + o * l[13],
                    _[2] = a * l[2] + n * l[6] + s * l[10] + o * l[14], _[3] = a * l[3] + n * l[7] + s * l[11] + o * l[15];
            }
        }, {
            key: "equals",
            value: function equals(e, t) {
                var i = e.elements,
                    a = t.elements;
                return r.nearEqual(Math.abs(i[0]), Math.abs(a[0])) && r.nearEqual(Math.abs(i[1]), Math.abs(a[1])) && r.nearEqual(Math.abs(i[2]), Math.abs(a[2])) && r.nearEqual(Math.abs(i[3]), Math.abs(a[3]));
            }
        }, {
            key: "normalize",
            value: function normalize(e, t) {
                var r = e.elements,
                    i = t.elements,
                    a = e.length();
                a > 0 && (i[0] = r[0] * a, i[1] = r[1] * a, i[2] = r[2] * a, i[3] = r[3] * a);
            }
        }, {
            key: "add",
            value: function add(e, t, r) {
                var i = r.elements,
                    a = e.elements,
                    n = t.elements;
                i[0] = a[0] + n[0], i[1] = a[1] + n[1], i[2] = a[2] + n[2], i[3] = a[3] + n[3];
            }
        }, {
            key: "subtract",
            value: function subtract(e, t, r) {
                var i = r.elements,
                    a = e.elements,
                    n = t.elements;
                i[0] = a[0] - n[0], i[1] = a[1] - n[1], i[2] = a[2] - n[2], i[3] = a[3] - n[3];
            }
        }, {
            key: "multiply",
            value: function multiply(e, t, r) {
                var i = r.elements,
                    a = e.elements,
                    n = t.elements;
                i[0] = a[0] * n[0], i[1] = a[1] * n[1], i[2] = a[2] * n[2], i[3] = a[3] * n[3];
            }
        }, {
            key: "scale",
            value: function scale(e, t, r) {
                var i = r.elements,
                    a = e.elements;
                i[0] = a[0] * t, i[1] = a[1] * t, i[2] = a[2] * t, i[3] = a[3] * t;
            }
        }, {
            key: "Clamp",
            value: function Clamp(e, t, r, i) {
                var a = e.elements,
                    n = a[0],
                    s = a[1],
                    o = a[2],
                    l = a[3],
                    _ = t.elements,
                    h = _[0],
                    c = _[1],
                    d = _[2],
                    u = _[3],
                    m = r.elements,
                    f = m[0],
                    E = m[1],
                    T = m[2],
                    p = m[3],
                    g = i.elements;
                n = (n = n > f ? f : n) < h ? h : n, s = (s = s > E ? E : s) < c ? c : s, o = (o = o > T ? T : o) < d ? d : o,
                    l = (l = l > p ? p : l) < u ? u : l, g[0] = n, g[1] = s, g[2] = o, g[3] = l;
            }
        }, {
            key: "distanceSquared",
            value: function distanceSquared(e, t) {
                var r = e.elements,
                    i = t.elements,
                    a = r[0] - i[0],
                    n = r[1] - i[1],
                    s = r[2] - i[2],
                    o = r[3] - i[3];
                return a * a + n * n + s * s + o * o;
            }
        }, {
            key: "distance",
            value: function distance(e, t) {
                var r = e.elements,
                    i = t.elements,
                    a = r[0] - i[0],
                    n = r[1] - i[1],
                    s = r[2] - i[2],
                    o = r[3] - i[3];
                return Math.sqrt(a * a + n * n + s * s + o * o);
            }
        }, {
            key: "dot",
            value: function dot(e, t) {
                var r = e.elements,
                    i = t.elements;
                return r[0] * i[0] + r[1] * i[1] + r[2] * i[2] + r[3] * i[3];
            }
        }, {
            key: "min",
            value: function min(e, t, r) {
                var i = r.elements,
                    a = e.elements,
                    n = t.elements;
                i[0] = Math.min(a[0], n[0]), i[1] = Math.min(a[1], n[1]), i[2] = Math.min(a[2], n[2]),
                    i[3] = Math.min(a[3], n[3]);
            }
        }, {
            key: "max",
            value: function max(e, t, r) {
                var i = r.elements,
                    a = e.elements,
                    n = t.elements;
                i[0] = Math.max(a[0], n[0]), i[1] = Math.max(a[1], n[1]), i[2] = Math.max(a[2], n[2]),
                    i[3] = Math.max(a[3], n[3]);
            }
        }]);
        return L;
    }();
    L.ZERO = new L(), L.ONE = new L(1, 1, 1, 1), L.UnitX = new L(1, 0, 0, 0), L.UnitY = new L(0, 1, 0, 0),
        L.UnitZ = new L(0, 0, 1, 0), L.UnitW = new L(0, 0, 0, 1);
    var y = /* */ function() {
        function y() {
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
            _classCallCheck(this, y);
            var a;
            a = i || new Float32Array(3), this.elements = a, a[0] = e, a[1] = t, a[2] = r;
        }
        _createClass(y, [{
            key: "setValue",
            value: function setValue(e, t, r) {
                this.elements[0] = e, this.elements[1] = t, this.elements[2] = r;
            }
        }, {
            key: "fromArray",
            value: function fromArray(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[t + 2];
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e.elements,
                    r = this.elements;
                t[0] = r[0], t[1] = r[1], t[2] = r[2];
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new y();
                return this.cloneTo(e), e;
            }
        }, {
            key: "toDefault",
            value: function toDefault() {
                this.elements[0] = 0, this.elements[1] = 0, this.elements[2] = 0;
            }
        }, {
            key: "x",
            get: function get() {
                return this.elements[0];
            },
            set: function set(e) {
                this.elements[0] = e;
            }
        }, {
            key: "y",
            get: function get() {
                return this.elements[1];
            },
            set: function set(e) {
                this.elements[1] = e;
            }
        }, {
            key: "z",
            get: function get() {
                return this.elements[2];
            },
            set: function set(e) {
                this.elements[2] = e;
            }
        }], [{
            key: "distanceSquared",
            value: function distanceSquared(e, t) {
                var r = e.elements,
                    i = t.elements,
                    a = r[0] - i[0],
                    n = r[1] - i[1],
                    s = r[2] - i[2];
                return a * a + n * n + s * s;
            }
        }, {
            key: "distance",
            value: function distance(e, t) {
                var r = e.elements,
                    i = t.elements,
                    a = r[0] - i[0],
                    n = r[1] - i[1],
                    s = r[2] - i[2];
                return Math.sqrt(a * a + n * n + s * s);
            }
        }, {
            key: "min",
            value: function min(e, t, r) {
                var i = r.elements,
                    a = e.elements,
                    n = t.elements;
                i[0] = Math.min(a[0], n[0]), i[1] = Math.min(a[1], n[1]), i[2] = Math.min(a[2], n[2]);
            }
        }, {
            key: "max",
            value: function max(e, t, r) {
                var i = r.elements,
                    a = e.elements,
                    n = t.elements;
                i[0] = Math.max(a[0], n[0]), i[1] = Math.max(a[1], n[1]), i[2] = Math.max(a[2], n[2]);
            }
        }, {
            key: "transformQuat",
            value: function transformQuat(e, t, r) {
                var i = r.elements,
                    a = e.elements,
                    n = t.elements,
                    s = a[0],
                    o = a[1],
                    l = a[2],
                    _ = n[0],
                    h = n[1],
                    c = n[2],
                    d = n[3],
                    u = d * s + h * l - c * o,
                    m = d * o + c * s - _ * l,
                    f = d * l + _ * o - h * s,
                    E = -_ * s - h * o - c * l;
                i[0] = u * d + E * -_ + m * -c - f * -h, i[1] = m * d + E * -h + f * -_ - u * -c,
                    i[2] = f * d + E * -c + u * -h - m * -_;
            }
        }, {
            key: "scalarLength",
            value: function scalarLength(e) {
                var t = e.elements,
                    r = t[0],
                    i = t[1],
                    a = t[2];
                return Math.sqrt(r * r + i * i + a * a);
            }
        }, {
            key: "scalarLengthSquared",
            value: function scalarLengthSquared(e) {
                var t = e.elements,
                    r = t[0],
                    i = t[1],
                    a = t[2];
                return r * r + i * i + a * a;
            }
        }, {
            key: "normalize",
            value: function normalize(e, t) {
                var r = e.elements,
                    i = t.elements,
                    a = r[0],
                    n = r[1],
                    s = r[2],
                    o = a * a + n * n + s * s;
                o > 0 && (o = 1 / Math.sqrt(o), i[0] = r[0] * o, i[1] = r[1] * o, i[2] = r[2] * o);
            }
        }, {
            key: "multiply",
            value: function multiply(e, t, r) {
                var i = r.elements,
                    a = e.elements,
                    n = t.elements;
                i[0] = a[0] * n[0], i[1] = a[1] * n[1], i[2] = a[2] * n[2];
            }
        }, {
            key: "scale",
            value: function scale(e, t, r) {
                var i = r.elements,
                    a = e.elements;
                i[0] = a[0] * t, i[1] = a[1] * t, i[2] = a[2] * t;
            }
        }, {
            key: "lerp",
            value: function lerp(e, t, r, i) {
                var a = i.elements,
                    n = e.elements,
                    s = t.elements,
                    o = n[0],
                    l = n[1],
                    _ = n[2];
                a[0] = o + r * (s[0] - o), a[1] = l + r * (s[1] - l), a[2] = _ + r * (s[2] - _);
            }
        }, {
            key: "transformV3ToV3",
            value: function transformV3ToV3(e, t, r) {
                var i = y._tempVector4;
                y.transformV3ToV4(e, t, i);
                var a = i.elements,
                    n = r.elements;
                n[0] = a[0], n[1] = a[1], n[2] = a[2];
            }
        }, {
            key: "transformV3ToV4",
            value: function transformV3ToV4(e, t, r) {
                var i = e.elements,
                    a = i[0],
                    n = i[1],
                    s = i[2],
                    o = t.elements,
                    l = r.elements;
                l[0] = a * o[0] + n * o[4] + s * o[8] + o[12], l[1] = a * o[1] + n * o[5] + s * o[9] + o[13],
                    l[2] = a * o[2] + n * o[6] + s * o[10] + o[14], l[3] = a * o[3] + n * o[7] + s * o[11] + o[15];
            }
        }, {
            key: "TransformNormal",
            value: function TransformNormal(e, t, r) {
                var i = e.elements,
                    a = i[0],
                    n = i[1],
                    s = i[2],
                    o = t.elements,
                    l = r.elements;
                l[0] = a * o[0] + n * o[4] + s * o[8], l[1] = a * o[1] + n * o[5] + s * o[9], l[2] = a * o[2] + n * o[6] + s * o[10];
            }
        }, {
            key: "transformCoordinate",
            value: function transformCoordinate(e, t, r) {
                var i = e.elements,
                    a = i[0],
                    n = i[1],
                    s = i[2],
                    o = t.elements,
                    l = a * o[3] + n * o[7] + s * o[11] + o[15],
                    _ = r.elements;
                _[0] = a * o[0] + n * o[4] + s * o[8] + o[12] / l, _[1] = a * o[1] + n * o[5] + s * o[9] + o[13] / l,
                    _[2] = a * o[2] + n * o[6] + s * o[10] + o[14] / l;
            }
        }, {
            key: "Clamp",
            value: function Clamp(e, t, r, i) {
                var a = e.elements,
                    n = a[0],
                    s = a[1],
                    o = a[2],
                    l = t.elements,
                    _ = l[0],
                    h = l[1],
                    c = l[2],
                    d = r.elements,
                    u = d[0],
                    m = d[1],
                    f = d[2],
                    E = i.elements;
                n = (n = n > u ? u : n) < _ ? _ : n, s = (s = s > m ? m : s) < h ? h : s, o = (o = o > f ? f : o) < c ? c : o,
                    E[0] = n, E[1] = s, E[2] = o;
            }
        }, {
            key: "add",
            value: function add(e, t, r) {
                var i = r.elements,
                    a = e.elements,
                    n = t.elements;
                i[0] = a[0] + n[0], i[1] = a[1] + n[1], i[2] = a[2] + n[2];
            }
        }, {
            key: "subtract",
            value: function subtract(e, t, r) {
                var i = r.elements,
                    a = e.elements,
                    n = t.elements;
                i[0] = a[0] - n[0], i[1] = a[1] - n[1], i[2] = a[2] - n[2];
            }
        }, {
            key: "cross",
            value: function cross(e, t, r) {
                var i = e.elements,
                    a = t.elements,
                    n = r.elements,
                    s = i[0],
                    o = i[1],
                    l = i[2],
                    _ = a[0],
                    h = a[1],
                    c = a[2];
                n[0] = o * c - l * h, n[1] = l * _ - s * c, n[2] = s * h - o * _;
            }
        }, {
            key: "dot",
            value: function dot(e, t) {
                var r = e.elements,
                    i = t.elements;
                return r[0] * i[0] + r[1] * i[1] + r[2] * i[2];
            }
        }, {
            key: "equals",
            value: function equals(e, t) {
                var i = e.elements,
                    a = t.elements;
                return r.nearEqual(i[0], a[0]) && r.nearEqual(i[1], a[1]) && r.nearEqual(i[2], a[2]);
            }
        }]);
        return y;
    }();
    y._tempVector4 = new L(), y.ZERO = new y(0, 0, 0), y.ONE = new y(1, 1, 1), y.NegativeUnitX = new y(-1, 0, 0),
        y.UnitX = new y(1, 0, 0), y.UnitY = new y(0, 1, 0), y.UnitZ = new y(0, 0, 1), y.ForwardRH = new y(0, 0, -1),
        y.ForwardLH = new y(0, 0, 1), y.Up = new y(0, 1, 0), y.NAN = new y(NaN, NaN, NaN);
    var C = /* */ function() {
        function C() {
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
            var n = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
            var s = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
            var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
            var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
            var _ = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
            var h = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 1;
            var c = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
            var d = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
            var u = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
            var m = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;
            var f = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 1;
            var E = arguments.length > 16 && arguments[16] !== undefined ? arguments[16] : null;
            _classCallCheck(this, C);
            var T = this.elements = E || new Float32Array(16);
            T[0] = e, T[1] = t, T[2] = r, T[3] = i, T[4] = a, T[5] = n, T[6] = s, T[7] = o,
                T[8] = l, T[9] = _, T[10] = h, T[11] = c, T[12] = d, T[13] = u, T[14] = m, T[15] = f;
        }
        _createClass(C, [{
            key: "setRotation",
            value: function setRotation(e) {
                var t = e.x,
                    r = e.y,
                    i = e.z,
                    a = e.w,
                    n = t * t,
                    s = r * r,
                    o = i * i,
                    l = t * r,
                    _ = i * a,
                    h = i * t,
                    c = r * a,
                    d = r * i,
                    u = t * a,
                    m = this.elements;
                m[0] = 1 - 2 * (s + o), m[1] = 2 * (l + _), m[2] = 2 * (h - c), m[4] = 2 * (l - _),
                    m[5] = 1 - 2 * (o + n), m[6] = 2 * (d + u), m[8] = 2 * (h + c), m[9] = 2 * (d - u),
                    m[10] = 1 - 2 * (s + n);
            }
        }, {
            key: "setPosition",
            value: function setPosition(e) {
                var t = this.elements;
                t[12] = e.x, t[13] = e.y, t[14] = e.z;
            }
        }, {
            key: "getElementByRowColumn",
            value: function getElementByRowColumn(e, t) {
                if (e < 0 || e > 3) throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
                if (t < 0 || t > 3) throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
                return this.elements[4 * e + t];
            }
        }, {
            key: "setElementByRowColumn",
            value: function setElementByRowColumn(e, t, r) {
                if (e < 0 || e > 3) throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
                if (t < 0 || t > 3) throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
                this.elements[4 * e + t] = r;
            }
        }, {
            key: "equalsOtherMatrix",
            value: function equalsOtherMatrix(e) {
                var t = this.elements,
                    i = e.elements;
                return r.nearEqual(t[0], i[0]) && r.nearEqual(t[1], i[1]) && r.nearEqual(t[2], i[2]) && r.nearEqual(t[3], i[3]) && r.nearEqual(t[4], i[4]) && r.nearEqual(t[5], i[5]) && r.nearEqual(t[6], i[6]) && r.nearEqual(t[7], i[7]) && r.nearEqual(t[8], i[8]) && r.nearEqual(t[9], i[9]) && r.nearEqual(t[10], i[10]) && r.nearEqual(t[11], i[11]) && r.nearEqual(t[12], i[12]) && r.nearEqual(t[13], i[13]) && r.nearEqual(t[14], i[14]) && r.nearEqual(t[15], i[15]);
            }
        }, {
            key: "decomposeTransRotScale",
            value: function decomposeTransRotScale(e, t, r) {
                var i = C._tempMatrix4x4;
                return this.decomposeTransRotMatScale(e, i, r) ? (f.createFromMatrix4x4(i, t), !0) : (t.identity(), !1);
            }
        }, {
            key: "decomposeTransRotMatScale",
            value: function decomposeTransRotMatScale(e, t, i) {
                var a = this.elements,
                    s = e,
                    o = t.elements,
                    l = i;
                s.x = a[12], s.y = a[13], s.z = a[14];
                var _ = a[0],
                    h = a[1],
                    c = a[2],
                    d = a[4],
                    u = a[5],
                    m = a[6],
                    f = a[8],
                    E = a[9],
                    T = a[10],
                    p = l.x = Math.sqrt(_ * _ + h * h + c * c),
                    g = l.y = Math.sqrt(d * d + u * u + m * m),
                    S = l.z = Math.sqrt(f * f + E * E + T * T);
                if (r.isZero(p) || r.isZero(g) || r.isZero(S)) return o[1] = o[2] = o[3] = o[4] = o[6] = o[7] = o[8] = o[9] = o[11] = o[12] = o[13] = o[14] = 0,
                    o[0] = o[5] = o[10] = o[15] = 1, !1;
                var R = C._tempVector0;
                R.x = f / S, R.y = E / S, R.z = T / S;
                var v = C._tempVector1;
                v.x = _ / p, v.y = h / p, v.z = c / p;
                var x = C._tempVector2;
                n.cross(R, v, x);
                var I = C._tempVector1;
                return n.cross(x, R, I), o[3] = o[7] = o[11] = o[12] = o[13] = o[14] = 0, o[15] = 1,
                    o[0] = I.x, o[1] = I.y, o[2] = I.z, o[4] = x.x, o[5] = x.y, o[6] = x.z, o[8] = R.x,
                    o[9] = R.y, o[10] = R.z, o[0] * _ + o[1] * h + o[2] * c < 0 && (l.x = -p), o[4] * d + o[5] * u + o[6] * m < 0 && (l.y = -g),
                    o[8] * f + o[9] * E + o[10] * T < 0 && (l.z = -S), !0;
            }
        }, {
            key: "decomposeYawPitchRoll",
            value: function decomposeYawPitchRoll(e) {
                var t = Math.asin(-this.elements[9]);
                e.y = t, Math.cos(t) > r.zeroTolerance ? (e.z = Math.atan2(this.elements[1], this.elements[5]),
                    e.x = Math.atan2(this.elements[8], this.elements[10])) : (e.z = Math.atan2(-this.elements[4], this.elements[0]),
                    e.x = 0);
            }
        }, {
            key: "normalize",
            value: function normalize() {
                var e = this.elements,
                    t = e[0],
                    r = e[1],
                    i = e[2],
                    a = Math.sqrt(t * t + r * r + i * i);
                if (!a) return e[0] = 0, e[1] = 0, void(e[2] = 0);
                1 != a && (a = 1 / a, e[0] = t * a, e[1] = r * a, e[2] = i * a);
            }
        }, {
            key: "transpose",
            value: function transpose() {
                var e, t;
                return t = (e = this.elements)[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8],
                    e[8] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[7],
                    e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
            }
        }, {
            key: "invert",
            value: function invert(e) {
                var t = this.elements,
                    r = e.elements,
                    i = t[0],
                    a = t[1],
                    n = t[2],
                    s = t[3],
                    o = t[4],
                    l = t[5],
                    _ = t[6],
                    h = t[7],
                    c = t[8],
                    d = t[9],
                    u = t[10],
                    m = t[11],
                    f = t[12],
                    E = t[13],
                    T = t[14],
                    p = t[15],
                    g = i * l - a * o,
                    S = i * _ - n * o,
                    R = i * h - s * o,
                    v = a * _ - n * l,
                    x = a * h - s * l,
                    I = n * h - s * _,
                    A = c * E - d * f,
                    M = c * T - u * f,
                    D = c * p - m * f,
                    L = d * T - u * E,
                    y = d * p - m * E,
                    C = u * p - m * T,
                    O = g * C - S * y + R * L + v * D - x * M + I * A;
                0 !== Math.abs(O) && (O = 1 / O, r[0] = (l * C - _ * y + h * L) * O, r[1] = (n * y - a * C - s * L) * O,
                    r[2] = (E * I - T * x + p * v) * O, r[3] = (u * x - d * I - m * v) * O, r[4] = (_ * D - o * C - h * M) * O,
                    r[5] = (i * C - n * D + s * M) * O, r[6] = (T * R - f * I - p * S) * O, r[7] = (c * I - u * R + m * S) * O,
                    r[8] = (o * y - l * D + h * A) * O, r[9] = (a * D - i * y - s * A) * O, r[10] = (f * x - E * R + p * g) * O,
                    r[11] = (d * R - c * x - m * g) * O, r[12] = (l * M - o * L - _ * A) * O, r[13] = (i * L - a * M + n * A) * O,
                    r[14] = (E * S - f * v - T * g) * O, r[15] = (c * v - d * S + u * g) * O);
            }
        }, {
            key: "identity",
            value: function identity() {
                var e = this.elements;
                e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0,
                    e[0] = e[5] = e[10] = e[15] = 1;
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t, r, i;
                if ((r = this.elements) !== (i = e.elements))
                    for (t = 0; t < 16; ++t) {
                        i[t] = r[t];
                    }
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new C();
                return this.cloneTo(e), e;
            }
        }, {
            key: "getTranslationVector",
            value: function getTranslationVector(e) {
                var t = this.elements;
                e.x = t[12], e.y = t[13], e.z = t[14];
            }
        }, {
            key: "setTranslationVector",
            value: function setTranslationVector(e) {
                var t = this.elements,
                    r = e;
                t[12] = r.x, t[13] = r.y, t[14] = r.z;
            }
        }, {
            key: "getForward",
            value: function getForward(e) {
                var t = this.elements;
                e.x = -t[8], e.y = -t[9], e.z = -t[10];
            }
        }, {
            key: "setForward",
            value: function setForward(e) {
                var t = this.elements;
                t[8] = -e.x, t[9] = -e.y, t[10] = -e.z;
            }
        }], [{
            key: "createRotationX",
            value: function createRotationX(e, t) {
                var r = t.elements,
                    i = Math.sin(e),
                    a = Math.cos(e);
                r[1] = r[2] = r[3] = r[4] = r[7] = r[8] = r[11] = r[12] = r[13] = r[14] = 0, r[0] = r[15] = 1,
                    r[5] = r[10] = a, r[6] = i, r[9] = -i;
            }
        }, {
            key: "createRotationY",
            value: function createRotationY(e, t) {
                var r = t.elements,
                    i = Math.sin(e),
                    a = Math.cos(e);
                r[1] = r[3] = r[4] = r[6] = r[7] = r[9] = r[11] = r[12] = r[13] = r[14] = 0, r[5] = r[15] = 1,
                    r[0] = r[10] = a, r[2] = -i, r[8] = i;
            }
        }, {
            key: "createRotationZ",
            value: function createRotationZ(e, t) {
                var r = t.elements,
                    i = Math.sin(e),
                    a = Math.cos(e);
                r[2] = r[3] = r[6] = r[7] = r[8] = r[9] = r[11] = r[12] = r[13] = r[14] = 0, r[10] = r[15] = 1,
                    r[0] = r[5] = a, r[1] = i, r[4] = -i;
            }
        }, {
            key: "createRotationYawPitchRoll",
            value: function createRotationYawPitchRoll(e, t, r, i) {
                f.createFromYawPitchRoll(e, t, r, C._tempQuaternion), C.createRotationQuaternion(C._tempQuaternion, i);
            }
        }, {
            key: "createRotationAxis",
            value: function createRotationAxis(e, t, r) {
                var i = e.x,
                    a = e.y,
                    n = e.z,
                    s = Math.cos(t),
                    o = Math.sin(t),
                    l = i * i,
                    _ = a * a,
                    h = n * n,
                    c = i * a,
                    d = i * n,
                    u = a * n,
                    m = r.elements;
                m[3] = m[7] = m[11] = m[12] = m[13] = m[14] = 0, m[15] = 1, m[0] = l + s * (1 - l),
                    m[1] = c - s * c + o * n, m[2] = d - s * d - o * a, m[4] = c - s * c - o * n, m[5] = _ + s * (1 - _),
                    m[6] = u - s * u + o * i, m[8] = d - s * d + o * a, m[9] = u - s * u - o * i, m[10] = h + s * (1 - h);
            }
        }, {
            key: "createRotationQuaternion",
            value: function createRotationQuaternion(e, t) {
                var r = t.elements,
                    i = e.x,
                    a = e.y,
                    n = e.z,
                    s = e.w,
                    o = i * i,
                    l = a * a,
                    _ = n * n,
                    h = i * a,
                    c = n * s,
                    d = n * i,
                    u = a * s,
                    m = a * n,
                    f = i * s;
                r[3] = r[7] = r[11] = r[12] = r[13] = r[14] = 0, r[15] = 1, r[0] = 1 - 2 * (l + _),
                    r[1] = 2 * (h + c), r[2] = 2 * (d - u), r[4] = 2 * (h - c), r[5] = 1 - 2 * (_ + o),
                    r[6] = 2 * (m + f), r[8] = 2 * (d + u), r[9] = 2 * (m - f), r[10] = 1 - 2 * (l + o);
            }
        }, {
            key: "createTranslate",
            value: function createTranslate(e, t) {
                var r = t.elements;
                r[4] = r[8] = r[1] = r[9] = r[2] = r[6] = r[3] = r[7] = r[11] = 0, r[0] = r[5] = r[10] = r[15] = 1,
                    r[12] = e.x, r[13] = e.y, r[14] = e.z;
            }
        }, {
            key: "createScaling",
            value: function createScaling(e, t) {
                var r = t.elements;
                r[0] = e.x, r[5] = e.y, r[10] = e.z, r[1] = r[4] = r[8] = r[12] = r[9] = r[13] = r[2] = r[6] = r[14] = r[3] = r[7] = r[11] = 0,
                    r[15] = 1;
            }
        }, {
            key: "multiply",
            value: function multiply(e, t, r) {
                var i = t.elements,
                    a = e.elements,
                    n = r.elements,
                    s = i[0],
                    o = i[1],
                    l = i[2],
                    _ = i[3],
                    h = i[4],
                    c = i[5],
                    d = i[6],
                    u = i[7],
                    m = i[8],
                    f = i[9],
                    E = i[10],
                    T = i[11],
                    p = i[12],
                    g = i[13],
                    S = i[14],
                    R = i[15],
                    v = a[0],
                    x = a[1],
                    I = a[2],
                    A = a[3],
                    M = a[4],
                    D = a[5],
                    L = a[6],
                    y = a[7],
                    C = a[8],
                    O = a[9],
                    N = a[10],
                    P = a[11],
                    b = a[12],
                    V = a[13],
                    w = a[14],
                    F = a[15];
                n[0] = s * v + o * M + l * C + _ * b, n[1] = s * x + o * D + l * O + _ * V, n[2] = s * I + o * L + l * N + _ * w,
                    n[3] = s * A + o * y + l * P + _ * F, n[4] = h * v + c * M + d * C + u * b, n[5] = h * x + c * D + d * O + u * V,
                    n[6] = h * I + c * L + d * N + u * w, n[7] = h * A + c * y + d * P + u * F, n[8] = m * v + f * M + E * C + T * b,
                    n[9] = m * x + f * D + E * O + T * V, n[10] = m * I + f * L + E * N + T * w, n[11] = m * A + f * y + E * P + T * F,
                    n[12] = p * v + g * M + S * C + R * b, n[13] = p * x + g * D + S * O + R * V, n[14] = p * I + g * L + S * N + R * w,
                    n[15] = p * A + g * y + S * P + R * F;
            }
        }, {
            key: "multiplyForNative",
            value: function multiplyForNative(e, r, i) {
                t.LayaGL.instance.matrix4x4Multiply(e.elements, r.elements, i.elements);
            }
        }, {
            key: "createFromQuaternion",
            value: function createFromQuaternion(e, t) {
                var r = t.elements,
                    i = e.x,
                    a = e.y,
                    n = e.z,
                    s = e.w,
                    o = i + i,
                    l = a + a,
                    _ = n + n,
                    h = i * o,
                    c = a * o,
                    d = a * l,
                    u = n * o,
                    m = n * l,
                    f = n * _,
                    E = s * o,
                    T = s * l,
                    p = s * _;
                r[0] = 1 - d - f, r[1] = c + p, r[2] = u - T, r[3] = 0, r[4] = c - p, r[5] = 1 - h - f,
                    r[6] = m + E, r[7] = 0, r[8] = u + T, r[9] = m - E, r[10] = 1 - h - d, r[11] = 0,
                    r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1;
            }
        }, {
            key: "createAffineTransformation",
            value: function createAffineTransformation(e, t, r, i) {
                var a = i.elements,
                    n = t.x,
                    s = t.y,
                    o = t.z,
                    l = t.w,
                    _ = n + n,
                    h = s + s,
                    c = o + o,
                    d = n * _,
                    u = n * h,
                    m = n * c,
                    f = s * h,
                    E = s * c,
                    T = o * c,
                    p = l * _,
                    g = l * h,
                    S = l * c,
                    R = r.x,
                    v = r.y,
                    x = r.z;
                a[0] = (1 - (f + T)) * R, a[1] = (u + S) * R, a[2] = (m - g) * R, a[3] = 0, a[4] = (u - S) * v,
                    a[5] = (1 - (d + T)) * v, a[6] = (E + p) * v, a[7] = 0, a[8] = (m + g) * x, a[9] = (E - p) * x,
                    a[10] = (1 - (d + f)) * x, a[11] = 0, a[12] = e.x, a[13] = e.y, a[14] = e.z, a[15] = 1;
            }
        }, {
            key: "createLookAt",
            value: function createLookAt(e, t, r, i) {
                var a = i.elements,
                    s = C._tempVector0,
                    o = C._tempVector1,
                    l = C._tempVector2;
                n.subtract(e, t, l), n.normalize(l, l), n.cross(r, l, s), n.normalize(s, s), n.cross(l, s, o),
                    i.identity(), a[0] = s.x, a[4] = s.y, a[8] = s.z, a[1] = o.x, a[5] = o.y, a[9] = o.z,
                    a[2] = l.x, a[6] = l.y, a[10] = l.z, a[12] = -n.dot(s, e), a[13] = -n.dot(o, e),
                    a[14] = -n.dot(l, e);
            }
        }, {
            key: "createPerspective",
            value: function createPerspective(e, t, r, i, a) {
                var n = 1 / Math.tan(.5 * e),
                    s = r / (n / t),
                    o = r / n;
                C.createPerspectiveOffCenter(-s, s, -o, o, r, i, a);
            }
        }, {
            key: "createPerspectiveOffCenter",
            value: function createPerspectiveOffCenter(e, t, r, i, a, n, s) {
                var o = s.elements,
                    l = n / (n - a);
                o[1] = o[2] = o[3] = o[4] = o[6] = o[7] = o[12] = o[13] = o[15] = 0, o[0] = 2 * a / (t - e),
                    o[5] = 2 * a / (i - r), o[8] = (e + t) / (t - e), o[9] = (i + r) / (i - r), o[10] = -l,
                    o[11] = -1, o[14] = -a * l;
            }
        }, {
            key: "createOrthoOffCenter",
            value: function createOrthoOffCenter(e, t, r, i, a, n, s) {
                var o = s.elements,
                    l = 1 / (n - a);
                o[1] = o[2] = o[3] = o[4] = o[6] = o[8] = o[7] = o[9] = o[11] = 0, o[15] = 1, o[0] = 2 / (t - e),
                    o[5] = 2 / (i - r), o[10] = -l, o[12] = (e + t) / (e - t), o[13] = (i + r) / (r - i),
                    o[14] = -a * l;
            }
        }, {
            key: "billboard",
            value: function billboard(e, t, i, a, s, o) {
                n.subtract(e, t, C._tempVector0);
                var l = n.scalarLengthSquared(C._tempVector0);
                r.isZero(l) ? (n.scale(s, -1, C._tempVector1), C._tempVector1.cloneTo(C._tempVector0)) : n.scale(C._tempVector0, 1 / Math.sqrt(l), C._tempVector0),
                    n.cross(a, C._tempVector0, C._tempVector2), n.normalize(C._tempVector2, C._tempVector2),
                    n.cross(C._tempVector0, C._tempVector2, C._tempVector3);
                var _ = C._tempVector2,
                    h = C._tempVector3,
                    c = C._tempVector0,
                    d = e,
                    u = o.elements;
                u[0] = _.x, u[1] = _.y, u[2] = _.z, u[3] = 0, u[4] = h.x, u[5] = h.y, u[6] = h.z,
                    u[7] = 0, u[8] = c.x, u[9] = c.y, u[10] = c.z, u[11] = 0, u[12] = d.x, u[13] = d.y,
                    u[14] = d.z, u[15] = 1;
            }
        }, {
            key: "translation",
            value: function translation(e, t) {
                var r = t.elements;
                r[0] = r[5] = r[10] = r[15] = 1, r[12] = e.x, r[13] = e.y, r[14] = e.z;
            }
        }]);
        return C;
    }();
    C._tempMatrix4x4 = new C(), C.TEMPMatrix0 = new C(), C.TEMPMatrix1 = new C(), C._tempVector0 = new n(),
        C._tempVector1 = new n(), C._tempVector2 = new n(), C._tempVector3 = new n(), C._tempQuaternion = new f(),
        C.DEFAULT = new C(), C.ZERO = new C(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    var O = /* */ function() {
        function O() {
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
            _classCallCheck(this, O);
            var n;
            (n = a || new Float32Array(4))[0] = e, n[1] = t, n[2] = r, n[3] = i, this.elements = n;
        }
        _createClass(O, [{
            key: "scaling",
            value: function scaling(e, t) {
                var r = t.elements,
                    i = this.elements;
                r[0] = i[0] * e, r[1] = i[1] * e, r[2] = i[2] * e, r[3] = i[3] * e;
            }
        }, {
            key: "normalize",
            value: function normalize(e) {
                O._normalizeArray(this.elements, e.elements);
            }
        }, {
            key: "length",
            value: function length() {
                var e = this.elements,
                    t = e[0],
                    r = e[1],
                    i = e[2],
                    a = e[3];
                return Math.sqrt(t * t + r * r + i * i + a * a);
            }
        }, {
            key: "rotateX",
            value: function rotateX(e, t) {
                var r = t.elements,
                    i = this.elements;
                e *= .5;
                var a = i[0],
                    n = i[1],
                    s = i[2],
                    o = i[3],
                    l = Math.sin(e),
                    _ = Math.cos(e);
                r[0] = a * _ + o * l, r[1] = n * _ + s * l, r[2] = s * _ - n * l, r[3] = o * _ - a * l;
            }
        }, {
            key: "rotateY",
            value: function rotateY(e, t) {
                var r = t.elements,
                    i = this.elements;
                e *= .5;
                var a = i[0],
                    n = i[1],
                    s = i[2],
                    o = i[3],
                    l = Math.sin(e),
                    _ = Math.cos(e);
                r[0] = a * _ - s * l, r[1] = n * _ + o * l, r[2] = s * _ + a * l, r[3] = o * _ - n * l;
            }
        }, {
            key: "rotateZ",
            value: function rotateZ(e, t) {
                var r = t.elements,
                    i = this.elements;
                e *= .5;
                var a = i[0],
                    n = i[1],
                    s = i[2],
                    o = i[3],
                    l = Math.sin(e),
                    _ = Math.cos(e);
                r[0] = a * _ + n * l, r[1] = n * _ - a * l, r[2] = s * _ + o * l, r[3] = o * _ - s * l;
            }
        }, {
            key: "getYawPitchRoll",
            value: function getYawPitchRoll(e) {
                y.transformQuat(y.ForwardRH, this, O.TEMPVector31), y.transformQuat(y.Up, this, O.TEMPVector32);
                var t = O.TEMPVector32.elements;
                O.angleTo(y.ZERO, O.TEMPVector31, O.TEMPVector33);
                var r = O.TEMPVector33.elements;
                r[0] == Math.PI / 2 ? (r[1] = O.arcTanAngle(t[2], t[0]), r[2] = 0) : r[0] == -Math.PI / 2 ? (r[1] = O.arcTanAngle(-t[2], -t[0]),
                        r[2] = 0) : (C.createRotationY(-r[1], O.TEMPMatrix0), C.createRotationX(-r[0], O.TEMPMatrix1),
                        y.transformCoordinate(O.TEMPVector32, O.TEMPMatrix0, O.TEMPVector32), y.transformCoordinate(O.TEMPVector32, O.TEMPMatrix1, O.TEMPVector32),
                        r[2] = O.arcTanAngle(t[1], -t[0])), r[1] <= -Math.PI && (r[1] = Math.PI), r[2] <= -Math.PI && (r[2] = Math.PI),
                    r[1] >= Math.PI && r[2] >= Math.PI && (r[1] = 0, r[2] = 0, r[0] = Math.PI - r[0]);
                var i = e.elements;
                i[0] = r[1], i[1] = r[0], i[2] = r[2];
            }
        }, {
            key: "invert",
            value: function invert(e) {
                var t = e.elements,
                    r = this.elements,
                    i = r[0],
                    a = r[1],
                    n = r[2],
                    s = r[3],
                    o = i * i + a * a + n * n + s * s,
                    l = o ? 1 / o : 0;
                t[0] = -i * l, t[1] = -a * l, t[2] = -n * l, t[3] = s * l;
            }
        }, {
            key: "identity",
            value: function identity() {
                var e = this.elements;
                e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1;
            }
        }, {
            key: "fromArray",
            value: function fromArray(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[t + 2],
                    this.elements[3] = e[t + 3];
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t, r, i;
                if ((r = this.elements) !== (i = e.elements))
                    for (t = 0; t < 4; ++t) {
                        i[t] = r[t];
                    }
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new O();
                return this.cloneTo(e), e;
            }
        }, {
            key: "equals",
            value: function equals(e) {
                var t = this.elements,
                    i = e.elements;
                return r.nearEqual(t[0], i[0]) && r.nearEqual(t[1], i[1]) && r.nearEqual(t[2], i[2]) && r.nearEqual(t[3], i[3]);
            }
        }, {
            key: "lengthSquared",
            value: function lengthSquared() {
                var e = this.elements[0],
                    t = this.elements[1],
                    r = this.elements[2],
                    i = this.elements[3];
                return e * e + t * t + r * r + i * i;
            }
        }, {
            key: "x",
            get: function get() {
                return this.elements[0];
            },
            set: function set(e) {
                this.elements[0] = e;
            }
        }, {
            key: "y",
            get: function get() {
                return this.elements[1];
            },
            set: function set(e) {
                this.elements[1] = e;
            }
        }, {
            key: "z",
            get: function get() {
                return this.elements[2];
            },
            set: function set(e) {
                this.elements[2] = e;
            }
        }, {
            key: "w",
            get: function get() {
                return this.elements[3];
            },
            set: function set(e) {
                this.elements[3] = e;
            }
        }], [{
            key: "_dotArray",
            value: function _dotArray(e, t) {
                return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];
            }
        }, {
            key: "_normalizeArray",
            value: function _normalizeArray(e, t) {
                var r = e[0],
                    i = e[1],
                    a = e[2],
                    n = e[3],
                    s = r * r + i * i + a * a + n * n;
                s > 0 && (s = 1 / Math.sqrt(s), t[0] = r * s, t[1] = i * s, t[2] = a * s, t[3] = n * s);
            }
        }, {
            key: "_lerpArray",
            value: function _lerpArray(e, t, r, i) {
                var a = 1 - r;
                O._dotArray(e, t) >= 0 ? (i[0] = a * e[0] + r * t[0], i[1] = a * e[1] + r * t[1],
                        i[2] = a * e[2] + r * t[2], i[3] = a * e[3] + r * t[3]) : (i[0] = a * e[0] - r * t[0],
                        i[1] = a * e[1] - r * t[1], i[2] = a * e[2] - r * t[2], i[3] = a * e[3] - r * t[3]),
                    O._normalizeArray(i, i);
            }
        }, {
            key: "createFromYawPitchRoll",
            value: function createFromYawPitchRoll(e, t, r, i) {
                var a = .5 * r,
                    n = .5 * t,
                    s = .5 * e,
                    o = Math.sin(a),
                    l = Math.cos(a),
                    _ = Math.sin(n),
                    h = Math.cos(n),
                    c = Math.sin(s),
                    d = Math.cos(s),
                    u = i.elements;
                u[0] = d * _ * l + c * h * o, u[1] = c * h * l - d * _ * o, u[2] = d * h * o - c * _ * l,
                    u[3] = d * h * l + c * _ * o;
            }
        }, {
            key: "multiply",
            value: function multiply(e, t, r) {
                var i = e.elements,
                    a = t.elements,
                    n = r.elements,
                    s = i[0],
                    o = i[1],
                    l = i[2],
                    _ = i[3],
                    h = a[0],
                    c = a[1],
                    d = a[2],
                    u = a[3],
                    m = o * d - l * c,
                    f = l * h - s * d,
                    E = s * c - o * h,
                    T = s * h + o * c + l * d;
                n[0] = s * u + h * _ + m, n[1] = o * u + c * _ + f, n[2] = l * u + d * _ + E, n[3] = _ * u - T;
            }
        }, {
            key: "arcTanAngle",
            value: function arcTanAngle(e, t) {
                return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
            }
        }, {
            key: "angleTo",
            value: function angleTo(e, t, r) {
                y.subtract(t, e, O.TEMPVector30), y.normalize(O.TEMPVector30, O.TEMPVector30), r.elements[0] = Math.asin(O.TEMPVector30.y),
                    r.elements[1] = O.arcTanAngle(-O.TEMPVector30.z, -O.TEMPVector30.x);
            }
        }, {
            key: "createFromAxisAngle",
            value: function createFromAxisAngle(e, t, r) {
                var i = r.elements,
                    a = e.elements;
                t *= .5;
                var n = Math.sin(t);
                i[0] = n * a[0], i[1] = n * a[1], i[2] = n * a[2], i[3] = Math.cos(t);
            }
        }, {
            key: "createFromMatrix3x3",
            value: function createFromMatrix3x3(e, t) {
                var r, i = t.elements,
                    a = e.elements,
                    n = a[0] + a[4] + a[8];
                if (n > 0) r = Math.sqrt(n + 1), i[3] = .5 * r, r = .5 / r, i[0] = (a[5] - a[7]) * r,
                    i[1] = (a[6] - a[2]) * r, i[2] = (a[1] - a[3]) * r;
                else {
                    var s = 0;
                    a[4] > a[0] && (s = 1), a[8] > a[3 * s + s] && (s = 2);
                    var o = (s + 1) % 3,
                        l = (s + 2) % 3;
                    r = Math.sqrt(a[3 * s + s] - a[3 * o + o] - a[3 * l + l] + 1), i[s] = .5 * r, r = .5 / r,
                        i[3] = (a[3 * o + l] - a[3 * l + o]) * r, i[o] = (a[3 * o + s] + a[3 * s + o]) * r,
                        i[l] = (a[3 * l + s] + a[3 * s + l]) * r;
                }
            }
        }, {
            key: "createFromMatrix4x4",
            value: function createFromMatrix4x4(e, t) {
                var r, i, a = e.elements,
                    n = t.elements,
                    s = a[0] + a[5] + a[10];
                s > 0 ? (r = Math.sqrt(s + 1), n[3] = .5 * r, r = .5 / r, n[0] = (a[6] - a[9]) * r,
                    n[1] = (a[8] - a[2]) * r, n[2] = (a[1] - a[4]) * r) : a[0] >= a[5] && a[0] >= a[10] ? (i = .5 / (r = Math.sqrt(1 + a[0] - a[5] - a[10])),
                    n[0] = .5 * r, n[1] = (a[1] + a[4]) * i, n[2] = (a[2] + a[8]) * i, n[3] = (a[6] - a[9]) * i) : a[5] > a[10] ? (i = .5 / (r = Math.sqrt(1 + a[5] - a[0] - a[10])),
                    n[0] = (a[4] + a[1]) * i, n[1] = .5 * r, n[2] = (a[9] + a[6]) * i, n[3] = (a[8] - a[2]) * i) : (i = .5 / (r = Math.sqrt(1 + a[10] - a[0] - a[5])),
                    n[0] = (a[8] + a[2]) * i, n[1] = (a[9] + a[6]) * i, n[2] = .5 * r, n[3] = (a[1] - a[4]) * i);
            }
        }, {
            key: "slerp",
            value: function slerp(e, t, r, i) {
                var a, n, s, o, l, _ = e.elements,
                    h = t.elements,
                    c = i.elements,
                    d = _[0],
                    u = _[1],
                    m = _[2],
                    f = _[3],
                    E = h[0],
                    T = h[1],
                    p = h[2],
                    g = h[3];
                return (n = d * E + u * T + m * p + f * g) < 0 && (n = -n, E = -E, T = -T, p = -p,
                        g = -g), 1 - n > 1e-6 ? (a = Math.acos(n), s = Math.sin(a), o = Math.sin((1 - r) * a) / s,
                        l = Math.sin(r * a) / s) : (o = 1 - r, l = r), c[0] = o * d + l * E, c[1] = o * u + l * T,
                    c[2] = o * m + l * p, c[3] = o * f + l * g, c;
            }
        }, {
            key: "lerp",
            value: function lerp(e, t, r, i) {
                O._lerpArray(e.elements, t.elements, r, i.elements);
            }
        }, {
            key: "add",
            value: function add(e, t, r) {
                var i = r.elements,
                    a = e.elements,
                    n = t.elements;
                i[0] = a[0] + n[0], i[1] = a[1] + n[1], i[2] = a[2] + n[2], i[3] = a[3] + n[3];
            }
        }, {
            key: "dot",
            value: function dot(e, t) {
                return O._dotArray(e.elements, t.elements);
            }
        }, {
            key: "rotationLookAt",
            value: function rotationLookAt(e, t, r) {
                O.lookAt(y.ZERO, e, t, r);
            }
        }, {
            key: "lookAt",
            value: function lookAt(e, t, r, i) {
                m.lookAt(e, t, r, O._tempMatrix3x3), O.rotationMatrix(O._tempMatrix3x3, i);
            }
        }, {
            key: "invert",
            value: function invert(e, t) {
                var i = e.elements,
                    a = t.elements,
                    n = e.lengthSquared();
                r.isZero(n) || (n = 1 / n, a[0] = -i[0] * n, a[1] = -i[1] * n, a[2] = -i[2] * n,
                    a[3] = i[3] * n);
            }
        }, {
            key: "rotationMatrix",
            value: function rotationMatrix(e, t) {
                var r, i, a = e.elements,
                    n = a[0],
                    s = a[1],
                    o = a[2],
                    l = a[3],
                    _ = a[4],
                    h = a[5],
                    c = a[6],
                    d = a[7],
                    u = a[8],
                    m = t.elements,
                    f = n + _ + u;
                f > 0 ? (r = Math.sqrt(f + 1), m[3] = .5 * r, r = .5 / r, m[0] = (h - d) * r, m[1] = (c - o) * r,
                    m[2] = (s - l) * r) : n >= _ && n >= u ? (i = .5 / (r = Math.sqrt(1 + n - _ - u)),
                    m[0] = .5 * r, m[1] = (s + l) * i, m[2] = (o + c) * i, m[3] = (h - d) * i) : _ > u ? (i = .5 / (r = Math.sqrt(1 + _ - n - u)),
                    m[0] = (l + s) * i, m[1] = .5 * r, m[2] = (d + h) * i, m[3] = (c - o) * i) : (i = .5 / (r = Math.sqrt(1 + u - n - _)),
                    m[0] = (c + o) * i, m[1] = (d + h) * i, m[2] = .5 * r, m[3] = (s - l) * i);
            }
        }]);
        return O;
    }();
    O.TEMPVector30 = new y(), O.TEMPVector31 = new y(), O.TEMPVector32 = new y(), O.TEMPVector33 = new y(),
        O.TEMPMatrix0 = new C(), O.TEMPMatrix1 = new C(), O._tempMatrix3x3 = new m(), O.DEFAULT = new O(),
        O.NAN = new O(NaN, NaN, NaN, NaN);
    var N = /* */ function() {
        function N() {
            _classCallCheck(this, N);
            this._referenceCount = 0, this._clip = null, this._nodeOwners = [], this._currentFrameIndices = null,
                this._realtimeDatas = [], this._scripts = null, this.speed = 1, this.clipStart = 0,
                this.clipEnd = 1;
        }
        _createClass(N, [{
            key: "_getReferenceCount",
            value: function _getReferenceCount() {
                return this._referenceCount;
            }
        }, {
            key: "_addReference",
            value: function _addReference() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
                this._clip && this._clip._addReference(e), this._referenceCount += e;
            }
        }, {
            key: "_removeReference",
            value: function _removeReference() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
                this._clip && this._clip._removeReference(e), this._referenceCount -= e;
            }
        }, {
            key: "_clearReference",
            value: function _clearReference() {
                this._removeReference(-this._referenceCount);
            }
        }, {
            key: "_resetFrameIndices",
            value: function _resetFrameIndices() {
                for (var e = 0, t = this._currentFrameIndices.length; e < t; e++) {
                    this._currentFrameIndices[e] = -1;
                }
            }
        }, {
            key: "addScript",
            value: function addScript(e) {
                var t = new e();
                return this._scripts = this._scripts || [], this._scripts.push(t), t;
            }
        }, {
            key: "getScript",
            value: function getScript(e) {
                if (this._scripts)
                    for (var t = 0, r = this._scripts.length; t < r; t++) {
                        var i = this._scripts[t];
                        if (i instanceof e) return i;
                    }
                return null;
            }
        }, {
            key: "getScripts",
            value: function getScripts(e) {
                var t;
                if (this._scripts)
                    for (var r = 0, i = this._scripts.length; r < i; r++) {
                        var a = this._scripts[r];
                        a instanceof e && (t = t || []).push(a);
                    }
                return t;
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t.name = this.name, t.speed = this.speed, t.clipStart = this.clipStart, t.clipEnd = this.clipEnd,
                    t.clip = this._clip;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new N();
                return this.cloneTo(e), e;
            }
        }, {
            key: "clip",
            get: function get() {
                return this._clip;
            },
            set: function set(e) {
                if (this._clip !== e) {
                    if (this._clip && this._referenceCount > 0 && this._clip._removeReference(this._referenceCount),
                        e) {
                        var r = this._realtimeDatas,
                            i = e._nodes,
                            a = i.count;
                        this._currentFrameIndices = new Int16Array(a), this._resetFrameIndices(), this._referenceCount > 0 && e._addReference(this._referenceCount),
                            this._realtimeDatas.length = a;
                        for (var s = 0; s < a; s++) {
                            switch (i.getNodeByIndex(s).type) {
                                case 0:
                                    break;

                                case 1:
                                case 3:
                                case 4:
                                    r[s] = t.Render.supportWebGLPlusAnimation ? new y() : new n();
                                    break;

                                case 2:
                                    r[s] = t.Render.supportWebGLPlusAnimation ? new O() : new f();
                                    break;

                                default:
                                    throw "AnimationClipParser04:unknown type.";
                            }
                        }
                    }
                    this._clip = e;
                }
            }
        }]);
        return N;
    }();
    var P = /* */ function() {
        function P() {
            _classCallCheck(this, P);
            this.indexInList = -1, this.referenceCount = 0, this.updateMark = -1, this.type = -1,
                this.fullPath = null, this.propertyOwner = null, this.property = null, this.defaultValue = null,
                this.value = null, this.crossFixedValue = null;
        }
        _createClass(P, [{
            key: "saveCrossFixedValue",
            value: function saveCrossFixedValue() {
                if (this.propertyOwner) switch (this.type) {
                    case 0:
                        this.crossFixedValue = this.value;
                        break;

                    case 1:
                    case 3:
                    case 4:
                    case 2:
                        this.value.cloneTo(this.crossFixedValue);
                        break;

                    default:
                        throw "Animator:unknown type.";
                }
            }
        }]);
        return P;
    }();
    var b = /* */ function(_t$Component) {
        _inherits(b, _t$Component);

        function b() {
            var _this4;
            _classCallCheck(this, b);
            _this4 = _possibleConstructorReturn(this, _getPrototypeOf(b).call(this)), _this4._keyframeNodeOwners = [],
                _this4._linkAvatarSpritesData = {}, _this4._linkAvatarSprites = [], _this4._renderableSprites = [],
                _this4.cullingMode = b.CULLINGMODE_CULLCOMPLETELY, _this4._controllerLayers = [],
                _this4._linkSprites = {}, _this4._speed = 1, _this4._keyframeNodeOwnerMap = {},
                _this4._updateMark = 0;
            return _this4;
        }
        _createClass(b, [{
            key: "_linkToSprites",
            value: function _linkToSprites(e) {
                for (var t in e) {
                    for (var r = this.owner, i = e[t], a = 0, n = i.length; a < n; a++) {
                        var s = i[a];
                        if ("" === s) break;
                        if (!(r = r.getChildByName(s))) break;
                    }
                    r && this.linkSprite3DToAvatarNode(t, r);
                }
            }
        }, {
            key: "_addKeyframeNodeOwner",
            value: function _addKeyframeNodeOwner(e, t, r) {
                var i = t._indexInList,
                    a = t.fullPath,
                    n = this._keyframeNodeOwnerMap[a];
                if (n) n.referenceCount++, e[i] = n;
                else {
                    for (var s = r, o = 0, l = t.propertyCount; o < l && (s = s[t.getPropertyByIndex(o)]); o++) {}
                    (n = this._keyframeNodeOwnerMap[a] = new P()).fullPath = a, n.indexInList = this._keyframeNodeOwners.length,
                        n.referenceCount = 1, n.propertyOwner = r;
                    var _ = t.propertyCount,
                        h = [];
                    for (o = 0; o < _; o++) {
                        h[o] = t.getPropertyByIndex(o);
                    }
                    if (n.property = h, n.type = t.type, s)
                        if (0 === t.type) n.defaultValue = s;
                        else {
                            var c = new s.constructor();
                            s.cloneTo(c), n.defaultValue = c, n.value = new s.constructor(), n.crossFixedValue = new s.constructor();
                        }
                    this._keyframeNodeOwners.push(n), e[i] = n;
                }
            }
        }, {
            key: "_removeKeyframeNodeOwner",
            value: function _removeKeyframeNodeOwner(e, t) {
                var r = t.fullPath,
                    i = this._keyframeNodeOwnerMap[r];
                i && (i.referenceCount--, 0 === i.referenceCount && (delete this._keyframeNodeOwnerMap[r],
                    this._keyframeNodeOwners.splice(this._keyframeNodeOwners.indexOf(i), 1)), e[t._indexInList] = null);
            }
        }, {
            key: "_getOwnersByClip",
            value: function _getOwnersByClip(e) {
                var t = e._clip._nodes,
                    r = t.count,
                    i = e._nodeOwners;
                i.length = r;
                for (var a = 0; a < r; a++) {
                    for (var n = t.getNodeByIndex(a), s = this._avatar ? this._avatarNodeMap[this._avatar._rootNode.name] : this.owner, o = 0, l = n.ownerPathCount; o < l; o++) {
                        var _ = n.getOwnerPathByIndex(o);
                        if ("" === _) break;
                        if (!(s = s.getChildByName(_))) break;
                    }
                    if (s) {
                        var h = n.propertyOwner;
                        h && (s = s[h]), s && this._addKeyframeNodeOwner(i, n, s);
                    }
                }
            }
        }, {
            key: "_updatePlayer",
            value: function _updatePlayer(e, t, r, i) {
                var a = e._clip._duration * (e.clipEnd - e.clipStart),
                    n = t._elapsedTime,
                    s = n + r;
                t._lastElapsedTime = n, t._elapsedTime = s;
                var o = s / a;
                t._normalizedTime = o;
                var l = o % 1;
                t._normalizedPlayTime = l < 0 ? l + 1 : l, t._duration = a;
                var _ = e._scripts;
                if (!i && s >= a) {
                    if (t._finish = !0, t._elapsedTime = a, t._normalizedPlayTime = 1, _)
                        for (var h = 0, c = _.length; h < c; h++) {
                            _[h].onStateExit();
                        }
                } else if (_)
                    for (h = 0, c = _.length; h < c; h++) {
                        _[h].onStateUpdate();
                    }
            }
        }, {
            key: "_eventScript",
            value: function _eventScript(e, t, r, i, a) {
                if (a)
                    for (var n = t.length; r < n; r++) {
                        var s = t[r];
                        if (!(s.time <= i)) break;
                        for (var o = 0, l = e.length; o < l; o++) {
                            var _ = e[o],
                                h = _[s.eventName];
                            h && h.apply(_, s.params);
                        }
                    } else
                        for (; r >= 0 && (s = t[r]).time >= i; r--) {
                            for (o = 0, l = e.length; o < l; o++) {
                                (h = (_ = e[o])[s.eventName]) && h.apply(_, s.params);
                            }
                        }
                return r;
            }
        }, {
            key: "_updateEventScript",
            value: function _updateEventScript(e, t) {
                var r = this.owner._scripts;
                if (r) {
                    var i = e._clip,
                        a = i._animationEvents,
                        n = i._duration,
                        s = t._elapsedTime,
                        o = s % n,
                        l = Math.abs(Math.floor(s / n) - Math.floor(t._lastElapsedTime / n)),
                        _ = t._elapsedTime >= t._lastElapsedTime;
                    if (t._lastIsFront !== _ && (_ ? t._playEventIndex++ : t._playEventIndex--, t._lastIsFront = _),
                        _) {
                        t._playEventIndex = this._eventScript(r, a, t._playEventIndex, l > 0 ? n : o, !0);
                        for (var h = 0, c = l - 1; h < c; h++) {
                            this._eventScript(r, a, 0, n, !0);
                        }
                        l > 0 && o > 0 && (t._playEventIndex = this._eventScript(r, a, 0, o, !0));
                    } else {
                        t._playEventIndex = this._eventScript(r, a, t._playEventIndex, l > 0 ? 0 : o, !1);
                        var d = a.length - 1;
                        for (h = 0, c = l - 1; h < c; h++) {
                            this._eventScript(r, a, d, 0, !1);
                        }
                        l > 0 && o > 0 && (t._playEventIndex = this._eventScript(r, a, d, o, !1));
                    }
                }
            }
        }, {
            key: "_updateClipDatas",
            value: function _updateClipDatas(e, t, r, i) {
                var a = e._clip,
                    n = a._duration,
                    s = e.clipStart * n + r._normalizedPlayTime * r._duration,
                    o = e._currentFrameIndices,
                    l = r._elapsedTime > r._lastElapsedTime;
                a._evaluateClipDatasRealTime(a._nodes, s, o, t, l, e._realtimeDatas);
            }
        }, {
            key: "_applyFloat",
            value: function _applyFloat(e, t, r, i, a, n, s) {
                if (r.updateMark === this._updateMark) {
                    if (i) e[t] += a * s;
                    else {
                        var o = e[t];
                        e[t] = o + a * (s - o);
                    }
                } else if (n) e[t] = i ? r.defaultValue + s : s;
                else if (i) e[t] = r.defaultValue + a * s;
                else {
                    var l = r.defaultValue;
                    e[t] = l + a * (s - l);
                }
            }
        }, {
            key: "_applyPositionAndRotationEuler",
            value: function _applyPositionAndRotationEuler(e, t, r, i, a, n) {
                if (e.updateMark === this._updateMark) {
                    if (t) n.x += r * a.x, n.y += r * a.y, n.z += r * a.z;
                    else {
                        var s = n.x,
                            o = n.y,
                            l = n.z;
                        n.x = s + r * (a.x - s), n.y = o + r * (a.y - o), n.z = l + r * (a.z - l);
                    }
                } else if (i) {
                    if (t) {
                        var _ = e.defaultValue;
                        n.x = _.x + a.x, n.y = _.y + a.y, n.z = _.z + a.z;
                    } else n.x = a.x, n.y = a.y, n.z = a.z;
                } else if (_ = e.defaultValue, t) n.x = _.x + r * a.x, n.y = _.y + r * a.y, n.z = _.z + r * a.z;
                else {
                    var h = _.x,
                        c = _.y,
                        d = _.z;
                    n.x = h + r * (a.x - h), n.y = c + r * (a.y - c), n.z = d + r * (a.z - d);
                }
            }
        }, {
            key: "_applyRotation",
            value: function _applyRotation(e, t, r, i, a, n) {
                if (e.updateMark === this._updateMark) {
                    if (t) {
                        var s = b._tempQuaternion1;
                        I.quaternionWeight(a, r, s), s.normalize(s), f.multiply(n, s, n);
                    } else f.lerp(n, a, r, n);
                } else if (i) {
                    if (t) {
                        var o = e.defaultValue;
                        f.multiply(o, a, n);
                    } else n.x = a.x, n.y = a.y, n.z = a.z, n.w = a.w;
                } else o = e.defaultValue, t ? (s = b._tempQuaternion1, I.quaternionWeight(a, r, s),
                    s.normalize(s), f.multiply(o, s, n)) : f.lerp(o, a, r, n);
            }
        }, {
            key: "_applyScale",
            value: function _applyScale(e, t, r, i, a, n) {
                if (e.updateMark === this._updateMark) {
                    if (t) {
                        var s = b._tempVector31;
                        I.scaleWeight(a, r, s), n.x = n.x * s.x, n.y = n.y * s.y, n.z = n.z * s.z;
                    } else I.scaleBlend(n, a, r, n);
                } else if (i) {
                    if (t) {
                        var o = e.defaultValue;
                        n.x = o.x * a.x, n.y = o.y * a.y, n.z = o.z * a.z;
                    } else n.x = a.x, n.y = a.y, n.z = a.z;
                } else o = e.defaultValue, t ? (s = b._tempVector31, I.scaleWeight(a, r, s), n.x = o.x * s.x,
                    n.y = o.y * s.y, n.z = o.z * s.z) : I.scaleBlend(o, a, r, n);
            }
        }, {
            key: "_applyCrossData",
            value: function _applyCrossData(e, t, r, i, a, n, s) {
                var o = e.propertyOwner;
                if (o) {
                    switch (e.type) {
                        case 0:
                            for (var l = e.property, _ = l.length - 1, h = 0; h < _ && (o = o[l[h]]); h++) {}
                            var c = a + s * (n - a);
                            e.value = c, this._applyFloat(o, l[_], e, t, r, i, c);
                            break;

                        case 1:
                            var d = o.localPosition,
                                u = e.value,
                                m = a.x,
                                E = a.y,
                                T = a.z;
                            u.x = m + s * (n.x - m), u.y = E + s * (n.y - E), u.z = T + s * (n.z - T), this._applyPositionAndRotationEuler(e, t, r, i, u, d),
                                o.localPosition = d;
                            break;

                        case 2:
                            var p = o.localRotation,
                                g = e.value;
                            f.lerp(a, n, s, g), this._applyRotation(e, t, r, i, g, p), o.localRotation = p;
                            break;

                        case 3:
                            var S = o.localScale,
                                R = e.value;
                            I.scaleBlend(a, n, s, R), this._applyScale(e, t, r, i, R, S), o.localScale = S;
                            break;

                        case 4:
                            var v = o.localRotationEuler,
                                x = e.value;
                            m = a.x, E = a.y, T = a.z, x.x = m + s * (n.x - m), x.y = E + s * (n.y - E), x.z = T + s * (n.z - T),
                                this._applyPositionAndRotationEuler(e, t, r, i, x, v), o.localRotationEuler = v;
                    }
                    e.updateMark = this._updateMark;
                }
            }
        }, {
            key: "_setClipDatasToNode",
            value: function _setClipDatasToNode(e, t, r, i) {
                for (var a = e._realtimeDatas, n = e._clip._nodes, s = e._nodeOwners, o = 0, l = n.count; o < l; o++) {
                    var _ = s[o];
                    if (_) {
                        var h = _.propertyOwner;
                        if (h) {
                            switch (_.type) {
                                case 0:
                                    for (var c = _.property, d = c.length - 1, u = 0; u < d && (h = h[c[u]]); u++) {}
                                    this._applyFloat(h, c[d], _, t, r, i, a[o]);
                                    break;

                                case 1:
                                    var m = h.localPosition;
                                    this._applyPositionAndRotationEuler(_, t, r, i, a[o], m), h.localPosition = m;
                                    break;

                                case 2:
                                    var f = h.localRotation;
                                    this._applyRotation(_, t, r, i, a[o], f), h.localRotation = f;
                                    break;

                                case 3:
                                    var E = h.localScale;
                                    this._applyScale(_, t, r, i, a[o], E), h.localScale = E;
                                    break;

                                case 4:
                                    var T = h.localRotationEuler;
                                    this._applyPositionAndRotationEuler(_, t, r, i, a[o], T), h.localRotationEuler = T;
                            }
                            _.updateMark = this._updateMark;
                        }
                    }
                }
            }
        }, {
            key: "_setCrossClipDatasToNode",
            value: function _setCrossClipDatasToNode(e, t, r, i, a) {
                for (var n = e._crossNodesOwners, s = e._crossNodesOwnersCount, o = e.blendingMode !== D.BLENDINGMODE_OVERRIDE, l = e.defaultWeight, _ = r._realtimeDatas, h = e._destCrossClipNodeIndices, c = r._nodeOwners, d = t._realtimeDatas, u = e._srcCrossClipNodeIndices, m = t._nodeOwners, f = 0; f < s; f++) {
                    var E = n[f];
                    if (E) {
                        var T = u[f],
                            p = h[f],
                            g = -1 !== T ? d[T] : c[p].defaultValue,
                            S = -1 !== p ? _[p] : m[T].defaultValue;
                        this._applyCrossData(E, o, l, a, g, S, i);
                    }
                }
            }
        }, {
            key: "_setFixedCrossClipDatasToNode",
            value: function _setFixedCrossClipDatasToNode(e, t, r, i) {
                for (var a = e._crossNodesOwners, n = e._crossNodesOwnersCount, s = e.blendingMode !== D.BLENDINGMODE_OVERRIDE, o = e.defaultWeight, l = t._realtimeDatas, _ = e._destCrossClipNodeIndices, h = 0; h < n; h++) {
                    var c = a[h];
                    if (c) {
                        var d = _[h],
                            u = c.crossFixedValue,
                            m = -1 !== d ? l[d] : c.defaultValue;
                        this._applyCrossData(c, s, o, i, u, m, r);
                    }
                }
            }
        }, {
            key: "_revertDefaultKeyframeNodes",
            value: function _revertDefaultKeyframeNodes(e) {
                for (var t = e._nodeOwners, r = 0, i = t.length; r < i; r++) {
                    var a = t[r];
                    if (a) {
                        var n = a.propertyOwner;
                        if (n) switch (a.type) {
                            case 0:
                                for (var s = a.property, o = s.length - 1, l = 0; l < o && (n = n[s[l]]); l++) {}
                                n[s[o]] = a.defaultValue;
                                break;

                            case 1:
                                var _ = n.localPosition,
                                    h = a.defaultValue;
                                _.x = h.x, _.y = h.y, _.z = h.z, n.localPosition = _;
                                break;

                            case 2:
                                var c = n.localRotation,
                                    d = a.defaultValue;
                                c.x = d.x, c.y = d.y, c.z = d.z, c.w = d.w, n.localRotation = c;
                                break;

                            case 3:
                                var u = n.localScale;
                                h = a.defaultValue, u.x = h.x, u.y = h.y, u.z = h.z, n.localScale = u;
                                break;

                            case 4:
                                var m = n.localRotationEuler;
                                h = a.defaultValue, m.x = h.x, m.y = h.y, m.z = h.z, n.localRotationEuler = m;
                                break;

                            default:
                                throw "Animator:unknown type.";
                        }
                    }
                }
            }
        }, {
            key: "_onAdded",
            value: function _onAdded() {
                var e = this.owner._parent;
                this.owner._setHierarchyAnimator(this, e ? e._hierarchyAnimator : null), this.owner._changeAnimatorToLinkSprite3DNoAvatar(this, !0, []);
            }
        }, {
            key: "_onDestroy",
            value: function _onDestroy() {
                for (var e = 0, t = this._controllerLayers.length; e < t; e++) {
                    this._controllerLayers[e]._removeReference();
                }
                var r = this.owner._parent;
                this.owner._clearHierarchyAnimator(this, r ? r._hierarchyAnimator : null);
            }
        }, {
            key: "_onEnable",
            value: function _onEnable() {
                this.owner._scene._animatorPool.add(this);
                for (var e = 0, t = this._controllerLayers.length; e < t; e++) {
                    if (this._controllerLayers[e].playOnWake) this.getDefaultState(e) && this.play(null, e, 0);
                }
            }
        }, {
            key: "_onDisable",
            value: function _onDisable() {
                this.owner._scene._animatorPool.remove(this);
            }
        }, {
            key: "_handleSpriteOwnersBySprite",
            value: function _handleSpriteOwnersBySprite(e, t, r) {
                for (var i = 0, a = this._controllerLayers.length; i < a; i++) {
                    for (var n = this._controllerLayers[i]._states, s = 0, o = n.length; s < o; s++) {
                        var l = n[s],
                            _ = l._clip,
                            h = t.join("/"),
                            c = _._nodesMap[h];
                        if (c)
                            for (var d = l._nodeOwners, u = 0, m = c.length; u < m; u++) {
                                e ? this._addKeyframeNodeOwner(d, c[u], r) : this._removeKeyframeNodeOwner(d, c[u]);
                            }
                    }
                }
            }
        }, {
            key: "_parse",
            value: function _parse(e) {
                var r = e.avatar;
                if (r) {
                    this.avatar = t.Loader.getRes(r.path);
                    var i = r.linkSprites;
                    this._linkSprites = i, this._linkToSprites(i);
                }
                e.clipPaths;
                for (var a = e.playOnWake, n = e.layers, s = 0; s < n.length; s++) {
                    var o = n[s],
                        l = new D(o.name);
                    l.defaultWeight = 0 === s ? 1 : o.weight;
                    var _ = o.blendingMode;
                    _ && (l.blendingMode = _), this.addControllerLayer(l);
                    for (var h = o.states, c = 0, d = h.length; c < d; c++) {
                        var u = h[c],
                            m = u.clipPath;
                        if (m) {
                            var f, E = u.name;
                            if (f = t.Loader.getRes(m)) {
                                var T = new N();
                                T.name = E, T.clip = f, l.addState(T), 0 === c && (this.getControllerLayer(s).defaultState = T);
                            }
                        }
                    }
                    void 0 !== a && (l.playOnWake = a);
                }
                var p = e.cullingMode;
                void 0 !== p && (this.cullingMode = p);
            }
        }, {
            key: "_update",
            value: function _update() {
                var e = this.owner._scene.timer,
                    r = e._delta / 1e3;
                if (0 !== this._speed && 0 !== r) {
                    var i;
                    if (this.cullingMode === b.CULLINGMODE_CULLCOMPLETELY) {
                        i = !1;
                        for (var a = 0, n = this._renderableSprites.length; a < n; a++) {
                            if (this._renderableSprites[a]._render.isRender) {
                                i = !0;
                                break;
                            }
                        }
                    } else i = !0;
                    this._updateMark++;
                    var s = e.scale;
                    for (a = 0, n = this._controllerLayers.length; a < n; a++) {
                        var o = this._controllerLayers[a],
                            l = o._playStateInfo,
                            _ = o._crossPlayStateInfo;
                        switch (m = o.blendingMode !== D.BLENDINGMODE_OVERRIDE, o._playType) {
                            case 0:
                                var h = l._currentState,
                                    c = h._clip,
                                    d = this._speed * h.speed,
                                    u = l._finish;
                                if (u || this._updatePlayer(h, l, r * d, c.islooping), i) {
                                    var m = o.blendingMode !== D.BLENDINGMODE_OVERRIDE;
                                    this._updateClipDatas(h, m, l, s * d), this._setClipDatasToNode(h, m, o.defaultWeight, 0 === a),
                                        u || this._updateEventScript(h, l);
                                }
                                break;

                            case 1:
                                c = (h = l._currentState)._clip;
                                var f = o._crossPlayState,
                                    E = f._clip,
                                    T = o._crossDuration,
                                    p = _._startPlayTime,
                                    g = E._duration - p,
                                    S = T > g ? g / T : 1,
                                    R = this._speed * f.speed;
                                this._updatePlayer(f, _, r * S * R, E.islooping);
                                var v = (_._elapsedTime - p) / S / T;
                                v >= 1 ? i && (this._updateClipDatas(f, m, _, s * R), this._setClipDatasToNode(f, m, o.defaultWeight, 0 === a),
                                        o._playType = 0, l._currentState = f, _._cloneTo(l)) : (l._finish || (d = this._speed * h.speed,
                                            this._updatePlayer(h, l, r * d, c.islooping), i && this._updateClipDatas(h, m, l, s * d)),
                                        i && (this._updateClipDatas(f, m, _, s * S * R), this._setCrossClipDatasToNode(o, h, f, v, 0 === a))),
                                    i && (this._updateEventScript(h, l), this._updateEventScript(f, _));
                                break;

                            case 2:
                                E = (f = o._crossPlayState)._clip, T = o._crossDuration, p = _._startPlayTime, S = T > (g = E._duration - p) ? g / T : 1,
                                    R = this._speed * f.speed, this._updatePlayer(f, _, r * S * R, E.islooping), i && ((v = (_._elapsedTime - p) / S / T) >= 1 ? (this._updateClipDatas(f, m, _, s * R),
                                            this._setClipDatasToNode(f, m, 1, 0 === a), o._playType = 0, l._currentState = f,
                                            _._cloneTo(l)) : (this._updateClipDatas(f, m, _, s * S * R), this._setFixedCrossClipDatasToNode(o, f, v, 0 === a)),
                                        this._updateEventScript(f, _));
                        }
                    }
                    i && this._avatar && (t.Render.supportWebGLPlusAnimation && this._updateAnimationNodeWorldMatix(this._animationNodeLocalPositions, this._animationNodeLocalRotations, this._animationNodeLocalScales, this._animationNodeWorldMatrixs, this._animationNodeParentIndices),
                        this._updateAvatarNodesToSprite());
                }
            }
        }, {
            key: "_cloneTo",
            value: function _cloneTo(e) {
                var t = e;
                t.avatar = this.avatar, t.cullingMode = this.cullingMode;
                for (var r = 0, i = this._controllerLayers.length; r < i; r++) {
                    var a = this._controllerLayers[r];
                    t.addControllerLayer(a.clone());
                    for (var n = a._states, s = 0, o = n.length; s < o; s++) {
                        var l = n[s].clone(),
                            _ = t.getControllerLayer(r);
                        _.addState(l), 0 == s && (_.defaultState = l);
                    }
                }
                t._linkSprites = this._linkSprites, t._linkToSprites(this._linkSprites);
            }
        }, {
            key: "getDefaultState",
            value: function getDefaultState() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                return this._controllerLayers[e].defaultState;
            }
        }, {
            key: "addState",
            value: function addState(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                this._controllerLayers[t].addState(e), console.warn("Animator:this function is discard,please use animatorControllerLayer.addState() instead.");
            }
        }, {
            key: "removeState",
            value: function removeState(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                this._controllerLayers[t].removeState(e), console.warn("Animator:this function is discard,please use animatorControllerLayer.removeState() instead.");
            }
        }, {
            key: "addControllerLayer",
            value: function addControllerLayer(e) {
                this._controllerLayers.push(e), e._animator = this, e._addReference();
                for (var t = e._states, r = 0, i = t.length; r < i; r++) {
                    this._getOwnersByClip(t[r]);
                }
            }
        }, {
            key: "getControllerLayer",
            value: function getControllerLayer() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                return this._controllerLayers[e];
            }
        }, {
            key: "play",
            value: function play() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.NEGATIVE_INFINITY;
                var i = this._controllerLayers[t];
                if (i) {
                    var a = i.defaultState;
                    if (!e && !a) throw new Error("Animator:must have default clip value,please set clip property.");
                    var n = i._playStateInfo,
                        s = n._currentState,
                        o = e ? i._statesMap[e] : a,
                        l = o._clip._duration;
                    s !== o ? (r !== Number.NEGATIVE_INFINITY ? n._resetPlayState(l * r) : n._resetPlayState(0),
                        null !== s && s !== o && this._revertDefaultKeyframeNodes(s), i._playType = 0, n._currentState = o) : r !== Number.NEGATIVE_INFINITY && (n._resetPlayState(l * r),
                        i._playType = 0);
                    var _ = o._scripts;
                    if (_)
                        for (var h = 0, c = _.length; h < c; h++) {
                            _[h].onStateEnter();
                        }
                } else console.warn("Invalid layerIndex " + t + ".");
            }
        }, {
            key: "crossFade",
            value: function crossFade(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Number.NEGATIVE_INFINITY;
                var a = this._controllerLayers[r];
                if (a) {
                    var n = a._statesMap[e];
                    if (n) {
                        var s = a._playType;
                        if (-1 === s) return void this.play(e, r, i);
                        var o = a._crossPlayStateInfo,
                            l = a._crossNodesOwners,
                            _ = a._crossNodesOwnersIndicesMap,
                            h = a._playStateInfo._currentState,
                            c = n._nodeOwners,
                            d = a._destCrossClipNodeIndices,
                            u = n._clip,
                            m = u._nodes,
                            f = u._nodesDic;
                        switch (s) {
                            case 0:
                                var E = h._nodeOwners,
                                    T = a._srcCrossClipNodeIndices,
                                    p = h._clip,
                                    g = p._nodes,
                                    S = p._nodesDic;
                                a._playType = 1;
                                for (var R = ++a._crossMark, v = a._crossNodesOwnersCount = 0, x = 0, I = g.count; x < I; x++) {
                                    var A = g.getNodeByIndex(x),
                                        M = A._indexInList,
                                        D = E[M];
                                    if (D) {
                                        var L = A.fullPath;
                                        T[v] = M;
                                        var y = f[L];
                                        d[v] = y ? y._indexInList : -1, _[L] = R, l[v] = D, v++;
                                    }
                                }
                                for (x = 0, I = m.count; x < I; x++) {
                                    var C = (y = m.getNodeByIndex(x))._indexInList,
                                        O = c[C];
                                    if (O) {
                                        var N = y.fullPath;
                                        S[N] || (T[v] = -1, d[v] = C, _[N] = R, l[v] = O, v++);
                                    }
                                }
                                break;

                            case 1:
                            case 2:
                                for (a._playType = 2, x = 0, I = l.length; x < I; x++) {
                                    var P = l[x];
                                    P.saveCrossFixedValue(), y = f[P.fullPath], d[x] = y ? y._indexInList : -1;
                                }
                                for (v = a._crossNodesOwnersCount, R = a._crossMark, x = 0, I = m.count; x < I; x++) {
                                    (O = c[C = (y = m.getNodeByIndex(x))._indexInList]) && _[N = y.fullPath] !== R && (d[v] = C,
                                        _[N] = R, P = c[C], l[v] = P, P.saveCrossFixedValue(), v++);
                                }
                        }
                        a._crossNodesOwnersCount = v, a._crossPlayState = n, a._crossDuration = h._clip._duration * t,
                            i !== Number.NEGATIVE_INFINITY ? o._resetPlayState(u._duration * i) : o._resetPlayState(0);
                        var b = n._scripts;
                        if (b)
                            for (x = 0, I = b.length; x < I; x++) {
                                b[x].onStateEnter();
                            }
                    } else console.warn("Invalid name " + r + ".");
                } else console.warn("Invalid layerIndex " + r + ".");
            }
        }, {
            key: "getCurrentAnimatorPlayState",
            value: function getCurrentAnimatorPlayState() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                return this._controllerLayers[e]._playStateInfo;
            }
        }, {
            key: "_isLinkSpriteToAnimationNodeData",
            value: function _isLinkSpriteToAnimationNodeData(e, t, r) {
                var i = this._linkAvatarSpritesData[t];
                if (r) i || (this._linkAvatarSpritesData[t] = i = []), i.push(e);
                else {
                    var a = i.indexOf(e);
                    i.splice(a, 1);
                }
            }
        }, {
            key: "_getAvatarOwnersAndInitDatasAsync",
            value: function _getAvatarOwnersAndInitDatasAsync() {
                for (var e = 0, t = this._controllerLayers.length; e < t; e++) {
                    for (var r = this._controllerLayers[e]._states, i = 0, a = r.length; i < a; i++) {
                        this._getOwnersByClip(r[i]);
                    }
                }
                for (var n in this._avatar._cloneDatasToAnimator(this), this._linkAvatarSpritesData) {
                    var s = this._linkAvatarSpritesData[n];
                    if (s)
                        for (var o = 0, l = s.length; o < l; o++) {
                            this._isLinkSpriteToAnimationNode(s[o], n, !0);
                        }
                }
            }
        }, {
            key: "_isLinkSpriteToAnimationNode",
            value: function _isLinkSpriteToAnimationNode(e, t, r) {
                if (this._avatar) {
                    var i = this._avatarNodeMap[t];
                    if (i)
                        if (r) {
                            e._transform._dummy = i.transform, this._linkAvatarSprites.push(e);
                            var a = i.transform,
                                n = e.transform;
                            if (!n.owner.isStatic && a) {
                                var s = n.worldMatrix,
                                    o = this.owner._transform._parent;
                                if (o) I.matrix4x4MultiplyMFM(o.worldMatrix, a.getWorldMatrix(), s);
                                else
                                    for (var l = s.elements, _ = a.getWorldMatrix(), h = 0; h < 16; h++) {
                                        l[h] = _[h];
                                    }
                                n.worldMatrix = s;
                            }
                        } else e._transform._dummy = null, this._linkAvatarSprites.splice(this._linkAvatarSprites.indexOf(e), 1);
                }
            }
        }, {
            key: "_updateAvatarNodesToSprite",
            value: function _updateAvatarNodesToSprite() {
                for (var e = 0, t = this._linkAvatarSprites.length; e < t; e++) {
                    var r = this._linkAvatarSprites[e],
                        i = r.transform._dummy,
                        a = r.transform;
                    if (!a.owner.isStatic && i) {
                        var n = a.worldMatrix,
                            s = this.owner._transform;
                        I.matrix4x4MultiplyMFM(s.worldMatrix, i.getWorldMatrix(), n), a.worldMatrix = n;
                    }
                }
            }
        }, {
            key: "linkSprite3DToAvatarNode",
            value: function linkSprite3DToAvatarNode(e, t) {
                return this._isLinkSpriteToAnimationNodeData(t, e, !0), this._isLinkSpriteToAnimationNode(t, e, !0), !0;
            }
        }, {
            key: "unLinkSprite3DToAvatarNode",
            value: function unLinkSprite3DToAvatarNode(e) {
                var t = e.transform._dummy;
                if (t) {
                    var r = t._owner.name;
                    return this._isLinkSpriteToAnimationNodeData(e, r, !1), this._isLinkSpriteToAnimationNode(e, r, !1), !0;
                }
                return !1;
            }
        }, {
            key: "_updateAnimationNodeWorldMatix",
            value: function _updateAnimationNodeWorldMatix(e, r, i, a, n) {
                t.LayaGL.instance.updateAnimationNodeWorldMatix(e, r, i, n, a);
            }
        }, {
            key: "speed",
            get: function get() {
                return this._speed;
            },
            set: function set(e) {
                this._speed = e;
            }
        }, {
            key: "avatar",
            get: function get() {
                return this._avatar;
            },
            set: function set(e) {
                if (this._avatar !== e)
                    if (this._avatar = e, e) this._getAvatarOwnersAndInitDatasAsync(),
                        this.owner._changeHierarchyAnimatorAvatar(this, e);
                    else {
                        var t = this.owner._parent;
                        this.owner._changeHierarchyAnimatorAvatar(this, t ? t._hierarchyAnimator._avatar : null);
                    }
            }
        }], [{
            key: "_update",
            value: function _update(e) {
                for (var t = e._animatorPool, r = t.elements, i = 0, a = t.length; i < a; i++) {
                    var n = r[i];
                    n && n.enabled && n._update();
                }
            }
        }]);
        return b;
    }(t.Component);
    b._tempVector30 = new n(), b._tempVector31 = new n(), b._tempQuaternion0 = new f(),
        b._tempQuaternion1 = new f(), b.CULLINGMODE_ALWAYSANIMATE = 0, b.CULLINGMODE_CULLCOMPLETELY = 2;
    var V = function V() {
        _classCallCheck(this, V);
        this.source = null, this.destination = null, this.camera = null, this.compositeShaderData = null,
            this.command = null, this.deferredReleaseTextures = [];
    };
    var w = function w() {
        _classCallCheck(this, w);
        this.invertY = !1;
    };
    w._instance = new w();
    var F = /* */ function(_t$BaseTexture) {
        _inherits(F, _t$BaseTexture);

        function F(e, r) {
            var _this5;
            var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : t.RenderTextureFormat.R8G8B8;
            var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : t.RenderTextureDepthFormat.DEPTH_16;
            _classCallCheck(this, F);
            _this5 = _possibleConstructorReturn(this, _getPrototypeOf(F).call(this, i, !1)),
                _this5._inPool = !1, _this5._isCameraTarget = !1, _this5._glTextureType = t.LayaGL.instance.TEXTURE_2D,
                _this5._width = e, _this5._height = r, _this5._depthStencilFormat = a, _this5._create(e, r);
            return _this5;
        }
        _createClass(F, [{
            key: "_texImage2D",
            value: function _texImage2D(e, r, i, a) {
                switch (this._format) {
                    case t.RenderTextureFormat.R8G8B8:
                        e.texImage2D(r, 0, e.RGB, i, a, 0, e.RGB, e.UNSIGNED_BYTE, null);
                        break;

                    case t.RenderTextureFormat.R8G8B8A8:
                        e.texImage2D(r, 0, e.RGBA, i, a, 0, e.RGBA, e.UNSIGNED_BYTE, null);
                        break;

                    case t.RenderTextureFormat.Alpha8:
                        e.texImage2D(r, 0, e.ALPHA, i, a, 0, e.ALPHA, e.UNSIGNED_BYTE, null);
                        break;

                    case t.RenderTextureFormat.R16G16B16A16:
                        t.LayaGL.layaGPUInstance._isWebGL2 ? e.texImage2D(this._glTextureType, 0, e.RGBA16F, i, a, 0, e.RGBA, e.HALF_FLOAT, null) : e.texImage2D(this._glTextureType, 0, e.RGBA, i, a, 0, e.RGBA, t.LayaGL.layaGPUInstance._oesTextureHalfFloat.HALF_FLOAT_OES, null);
                }
            }
        }, {
            key: "_create",
            value: function _create(e, r) {
                var i = t.LayaGL.instance;
                if (this._frameBuffer = i.createFramebuffer(), t.WebGLContext.bindTexture(i, this._glTextureType, this._glTexture),
                    this._texImage2D(i, this._glTextureType, e, r), this._setGPUMemory(e * r * 4), i.bindFramebuffer(i.FRAMEBUFFER, this._frameBuffer),
                    i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, this._glTexture, 0),
                    this._depthStencilFormat !== t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE) switch (this._depthStencilBuffer = i.createRenderbuffer(),
                    i.bindRenderbuffer(i.RENDERBUFFER, this._depthStencilBuffer), this._depthStencilFormat) {
                    case t.RenderTextureDepthFormat.DEPTH_16:
                        i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_COMPONENT16, e, r), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, this._depthStencilBuffer);
                        break;

                    case t.RenderTextureDepthFormat.STENCIL_8:
                        i.renderbufferStorage(i.RENDERBUFFER, i.STENCIL_INDEX8, e, r), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.STENCIL_ATTACHMENT, i.RENDERBUFFER, this._depthStencilBuffer);
                        break;

                    case t.RenderTextureDepthFormat.DEPTHSTENCIL_16_8:
                        i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, e, r), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, this._depthStencilBuffer);
                        break;

                    default:
                        throw "RenderTexture: unkonw depth format.";
                }
                i.bindFramebuffer(i.FRAMEBUFFER, null), i.bindRenderbuffer(i.RENDERBUFFER, null),
                    this._setWarpMode(i.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(i.TEXTURE_WRAP_T, this._wrapModeV),
                    this._setFilterMode(this._filterMode), this._setAnisotropy(this._anisoLevel), this._readyed = !0,
                    this._activeResource();
            }
        }, {
            key: "_start",
            value: function _start() {
                var e = t.LayaGL.instance;
                e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), F._currentActive = this, this._isCameraTarget && (w._instance.invertY = !0),
                    this._readyed = !1;
            }
        }, {
            key: "_end",
            value: function _end() {
                var e = t.LayaGL.instance;
                e.bindFramebuffer(e.FRAMEBUFFER, null), F._currentActive = null, this._isCameraTarget && (w._instance.invertY = !1),
                    this._readyed = !0;
            }
        }, {
            key: "getData",
            value: function getData(e, r, i, a, n) {
                if (t.Render.isConchApp && 2 == window.conchConfig.threadMode) throw "native 2 thread mode use getDataAsync";
                var s = t.LayaGL.instance;
                return s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), s.checkFramebufferStatus(s.FRAMEBUFFER) === s.FRAMEBUFFER_COMPLETE ? (s.readPixels(e, r, i, a, s.RGBA, s.UNSIGNED_BYTE, n),
                    s.bindFramebuffer(s.FRAMEBUFFER, null), n) : (s.bindFramebuffer(s.FRAMEBUFFER, null),
                    null);
            }
        }, {
            key: "getDataAsync",
            value: function getDataAsync(e, r, i, a, n) {
                var s = t.LayaGL.instance;
                s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), s.readPixelsAsync(e, r, i, a, s.RGBA, s.UNSIGNED_BYTE, function(e) {
                    n(new Uint8Array(e));
                }), s.bindFramebuffer(s.FRAMEBUFFER, null);
            }
        }, {
            key: "_disposeResource",
            value: function _disposeResource() {
                if (this._frameBuffer) {
                    var e = t.LayaGL.instance;
                    e.deleteTexture(this._glTexture), e.deleteFramebuffer(this._frameBuffer), e.deleteRenderbuffer(this._depthStencilBuffer),
                        this._glTexture = null, this._frameBuffer = null, this._depthStencilBuffer = null,
                        this._setGPUMemory(0);
                }
            }
        }, {
            key: "depthStencilFormat",
            get: function get() {
                return this._depthStencilFormat;
            }
        }, {
            key: "defaulteTexture",
            get: function get() {
                return t.Texture2D.grayTexture;
            }
        }], [{
            key: "createFromPool",
            value: function createFromPool(e, r) {
                var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : t.RenderTextureFormat.R8G8B8;
                var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : t.RenderTextureDepthFormat.DEPTH_16;
                var n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : t.FilterMode.Bilinear;
                for (var s, o = 0, l = F._pool.length; o < l; o++) {
                    if ((s = F._pool[o])._width == e && s._height == r && s._format == i && s._depthStencilFormat == a && s._filterMode == n) {
                        s._inPool = !1;
                        var _ = F._pool[l - 1];
                        return F._pool[o] = _, F._pool.length -= 1, s;
                    }
                }
                return (s = new F(e, r, i, a)).filterMode = n, s.lock = !0, s;
            }
        }, {
            key: "recoverToPool",
            value: function recoverToPool(e) {
                e._inPool || (F._pool.push(e), e._inPool = !0);
            }
        }, {
            key: "currentActive",
            get: function get() {
                return F._currentActive;
            }
        }]);
        return F;
    }(t.BaseTexture);
    F._pool = [];
    var B = /* */ function() {
        function B() {
            _classCallCheck(this, B);
            this._mask = [], this._length = 0;
        }
        _createClass(B, [{
            key: "_intersectionDefineDatas",
            value: function _intersectionDefineDatas(e) {
                for (var t = e._mask, r = this._mask, i = this._length - 1; i >= 0; i--) {
                    var a = r[i] & t[i];
                    0 == a && i == this._length - 1 ? this._length-- : r[i] = a;
                }
            }
        }, {
            key: "add",
            value: function add(e) {
                var t = e._index,
                    r = t + 1,
                    i = this._mask,
                    a = this._length;
                if (a < r) {
                    for (i.length < r && (i.length = r); a < t; a++) {
                        i[a] = 0;
                    }
                    i[t] = e._value, this._length = r;
                } else r > this._length ? (i[t] = e._value, this._length = r) : i[t] |= e._value;
            }
        }, {
            key: "remove",
            value: function remove(e) {
                var t = e._index,
                    r = this._mask,
                    i = this._length - 1;
                if (!(t > i)) {
                    var a = r[t] & ~e._value;
                    t == i && 0 === a ? this._length-- : r[t] = a;
                }
            }
        }, {
            key: "addDefineDatas",
            value: function addDefineDatas(e) {
                var t = e._mask,
                    r = e._length,
                    i = this._mask,
                    a = i.length;
                if (a < r) {
                    i.length = r;
                    for (var n = 0; n < a; n++) {
                        i[n] |= t[n];
                    }
                    for (; a < r; a++) {
                        i[a] = t[a];
                    }
                    this._length = r;
                } else {
                    for (n = 0; n < r; n++) {
                        i[n] |= t[n];
                    }
                    this._length = Math.max(this._length, r);
                }
            }
        }, {
            key: "removeDefineDatas",
            value: function removeDefineDatas(e) {
                for (var t = e._mask, r = this._mask, i = this._length - 1, a = e._length - 1; a >= 0; a--) {
                    if (!(a > i)) {
                        var n = r[a] & ~t[a];
                        a == i && 0 === n ? (i--, this._length--) : r[a] = n;
                    }
                }
            }
        }, {
            key: "has",
            value: function has(e) {
                var t = e._index;
                return !(t >= this._length) && 0 != (this._mask[t] & e._value);
            }
        }, {
            key: "clear",
            value: function clear() {
                this._length = 0;
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e,
                    r = t._mask,
                    i = this._mask,
                    a = this._length;
                r.length = a;
                for (var n = 0; n < a; n++) {
                    r[n] = i[n];
                }
                t._length = a;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new B();
                return this.cloneTo(e), e;
            }
        }]);
        return B;
    }();
    var U = function U(e, t) {
        _classCallCheck(this, U);
        this._index = e, this._value = t;
    };
    var G = /* */ function() {
        function G(e, t, r, i) {
            _classCallCheck(this, G);
            this._subShaderIndex = 0, this._passIndex = 0, this.setValue(e, t, r, i);
        }
        _createClass(G, [{
            key: "setValue",
            value: function setValue(e, t, r, i) {
                if (!e) throw "ShaderVariantInfo:Shader can't be null.";
                var a = e.getSubShaderAt(t);
                if (!a) throw "ShaderVariantInfo:Shader don't have subShaderIndex of ".concat(t, ".");
                var n = a._passes[r];
                if (!n) throw "ShaderVariantInfo:Shader don't have passIndex of ".concat(r, ".");
                for (var s = n._validDefine, o = 0, l = i.length; o < l; o++) {
                    var h = i[o];
                    if (!s.has(_.Shader3D.getDefineByName(h))) throw "ShaderVariantInfo:Invalid defineName ".concat(h, " in ").concat(e._name, " subShaderIndex of ").concat(t, " passIndex of ").concat(r, ".");
                }
                this._shader = e, this._subShaderIndex = t, this._passIndex = r, this._defineNames = i;
            }
        }, {
            key: "equal",
            value: function equal(e) {
                if (this._shader !== e._shader || this._subShaderIndex !== e._subShaderIndex || this._passIndex !== e._passIndex) return !1;
                var t = this._defineNames,
                    r = e._defineNames;
                if (t.length !== r.length) return !1;
                for (var i = 0, a = this._defineNames.length; i < a; i++) {
                    if (t[i] !== r[i]) return !1;
                }
                return !0;
            }
        }, {
            key: "clone",
            value: function clone() {
                return new G(this._shader, this._subShaderIndex, this._passIndex, this._defineNames.slice());
            }
        }, {
            key: "shader",
            get: function get() {
                return this._shader;
            }
        }, {
            key: "subShaderIndex",
            get: function get() {
                return this._subShaderIndex;
            }
        }, {
            key: "passIndex",
            get: function get() {
                return this._passIndex;
            }
        }, {
            key: "defineNames",
            get: function get() {
                return this._defineNames;
            }
        }]);
        return G;
    }();
    var z = /* */ function() {
        function z() {
            _classCallCheck(this, z);
            this._allCompiled = !1, this._variants = [];
        }
        _createClass(z, [{
            key: "add",
            value: function add(e) {
                for (var t = 0, r = this._variants.length; t < r; t++) {
                    if (this._variants[t].equal(e)) return !1;
                }
                return this._variants.push(e.clone()), this._allCompiled = !1, !0;
            }
        }, {
            key: "remove",
            value: function remove(e) {
                for (var t = 0, r = this._variants.length; t < r; t++) {
                    if (this._variants[t].equal(e)) return this._variants.splice(t, 1), !0;
                }
                return !1;
            }
        }, {
            key: "contatins",
            value: function contatins(e) {
                for (var t = 0, r = this._variants.length; t < r; t++) {
                    if (this._variants[t].equal(e)) return !0;
                }
                return !1;
            }
        }, {
            key: "getByIndex",
            value: function getByIndex(e) {
                return this._variants[e];
            }
        }, {
            key: "clear",
            value: function clear() {
                this._variants.length = 0;
            }
        }, {
            key: "compile",
            value: function compile() {
                if (!this._allCompiled) {
                    for (var e = this._variants, t = 0, r = e.length; t < r; t++) {
                        var i = e[t];
                        _.Shader3D.compileShaderByDefineNames(i._shader._name, i._subShaderIndex, i._passIndex, i._defineNames);
                    }
                    this._allCompiled = !0;
                }
            }
        }, {
            key: "allCompiled",
            get: function get() {
                return this._allCompiled;
            }
        }, {
            key: "variantCount",
            get: function get() {
                return this._variants.length;
            }
        }]);
        return z;
    }();
    var H = /* */ function() {
        function H(e, t, r, i) {
            _classCallCheck(this, H);
            this._attributeMap = null, this._uniformMap = null, this._enableInstancing = !1,
                this._subShaders = [], this._name = e, this._attributeMap = t, this._uniformMap = r,
                this._enableInstancing = i;
        }
        _createClass(H, [{
            key: "addSubShader",
            value: function addSubShader(e) {
                this._subShaders.push(e), e._owner = this;
            }
        }, {
            key: "getSubShaderAt",
            value: function getSubShaderAt(e) {
                return this._subShaders[e];
            }
        }, {
            key: "name",
            get: function get() {
                return this._name;
            }
        }], [{
            key: "_getNamesByDefineData",
            value: function _getNamesByDefineData(e, t) {
                var r = H._maskMap,
                    i = e._mask;
                t.length = 0;
                for (var a = 0, n = e._length; a < n; a++) {
                    for (var s = r[a], o = i[a], l = 0; l < 32; l++) {
                        var _ = 1 << l;
                        if (o > 0 && _ > o) break;
                        o & _ && t.push(s[_]);
                    }
                }
            }
        }, {
            key: "getDefineByName",
            value: function getDefineByName(e) {
                var t = H._defineMap[e];
                if (!t) {
                    var r = H._maskMap,
                        i = H._defineCounter,
                        a = Math.floor(i / 32),
                        n = 1 << i % 32;
                    t = new U(a, n), H._defineMap[e] = t, a == r.length && (r.length++, r[a] = {}),
                        r[a][n] = e, H._defineCounter++;
                }
                return t;
            }
        }, {
            key: "propertyNameToID",
            value: function propertyNameToID(e) {
                if (null != H._propertyNameMap[e]) return H._propertyNameMap[e];
                var t = H._propertyNameCounter++;
                return H._propertyNameMap[e] = t, t;
            }
        }, {
            key: "addInclude",
            value: function addInclude(e, r) {
                r = r.replace(t.ShaderCompile._clearCR, ""), t.ShaderCompile.addInclude(e, r);
            }
        }, {
            key: "compileShaderByDefineNames",
            value: function compileShaderByDefineNames(e, t, r, i) {
                var a = H.find(e);
                if (a) {
                    var n = a.getSubShaderAt(t);
                    if (n) {
                        var s = n._passes[r];
                        if (s) {
                            var o = H._compileDefineDatas;
                            o.clear();
                            for (var _ = 0, h = i.length; _ < h; _++) {
                                o.add(H.getDefineByName(i[_]));
                            }
                            l._config._multiLighting || o.add(H.SHADERDEFINE_LEGACYSINGALLIGHTING), s.withCompile(o);
                        } else console.warn("Shader3D: unknown passIndex.");
                    } else console.warn("Shader3D: unknown subShaderIndex.");
                } else console.warn("Shader3D: unknown shader name.");
            }
        }, {
            key: "add",
            value: function add(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
                return H._preCompileShader[e] = new H(e, t, r, i);
            }
        }, {
            key: "find",
            value: function find(e) {
                return H._preCompileShader[e];
            }
        }, {
            key: "compileShader",
            value: function compileShader(e, t, r) {
                var a = H.find(e);
                if (a) {
                    var n = a.getSubShaderAt(t);
                    if (n) {
                        var s = n._passes[r];
                        if (s) {
                            var o = H._compileDefineDatas,
                                _ = o._mask;
                            _.length = 0;
                            for (var h = 0, c = arguments.length <= 3 ? 0 : arguments.length - 3; h < c; h++) {
                                _.push(h + 3 < 3 || arguments.length <= h + 3 ? undefined : arguments[h + 3]);
                            }
                            o._length = arguments.length <= 3 ? 0 : arguments.length - 3, l._config._multiLighting || o.add(H.SHADERDEFINE_LEGACYSINGALLIGHTING),
                                s.withCompile(o);
                        } else console.warn("Shader3D: unknown passIndex.");
                    } else console.warn("Shader3D: unknown subShaderIndex.");
                } else console.warn("Shader3D: unknown shader name.");
            }
        }]);
        return H;
    }();
    H._compileDefineDatas = new B(), H.RENDER_STATE_CULL = 0, H.RENDER_STATE_BLEND = 1,
        H.RENDER_STATE_BLEND_SRC = 2, H.RENDER_STATE_BLEND_DST = 3, H.RENDER_STATE_BLEND_SRC_RGB = 4,
        H.RENDER_STATE_BLEND_DST_RGB = 5, H.RENDER_STATE_BLEND_SRC_ALPHA = 6, H.RENDER_STATE_BLEND_DST_ALPHA = 7,
        H.RENDER_STATE_BLEND_CONST_COLOR = 8, H.RENDER_STATE_BLEND_EQUATION = 9, H.RENDER_STATE_BLEND_EQUATION_RGB = 10,
        H.RENDER_STATE_BLEND_EQUATION_ALPHA = 11, H.RENDER_STATE_DEPTH_TEST = 12, H.RENDER_STATE_DEPTH_WRITE = 13,
        H.PERIOD_CUSTOM = 0, H.PERIOD_MATERIAL = 1, H.PERIOD_SPRITE = 2, H.PERIOD_CAMERA = 3,
        H.PERIOD_SCENE = 4, H._propertyNameCounter = 0, H._propertyNameMap = {}, H._defineCounter = 0,
        H._defineMap = {}, H._preCompileShader = {}, H._maskMap = [], H.debugMode = !1,
        H.debugShaderVariantCollection = new z();
    var k = /* */ function() {
        function k() {
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            _classCallCheck(this, k);
            this._ownerResource = null, this._data = null, this._defineDatas = new B(), this._runtimeCopyValues = [],
                this._ownerResource = e, this._initData();
        }
        _createClass(k, [{
            key: "_initData",
            value: function _initData() {
                this._data = new Object();
            }
        }, {
            key: "getData",
            value: function getData() {
                return this._data;
            }
        }, {
            key: "addDefine",
            value: function addDefine(e) {
                this._defineDatas.add(e);
            }
        }, {
            key: "removeDefine",
            value: function removeDefine(e) {
                this._defineDatas.remove(e);
            }
        }, {
            key: "hasDefine",
            value: function hasDefine(e) {
                return this._defineDatas.has(e);
            }
        }, {
            key: "clearDefine",
            value: function clearDefine() {
                this._defineDatas.clear();
            }
        }, {
            key: "getBool",
            value: function getBool(e) {
                return this._data[e];
            }
        }, {
            key: "setBool",
            value: function setBool(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getInt",
            value: function getInt(e) {
                return this._data[e];
            }
        }, {
            key: "setInt",
            value: function setInt(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getNumber",
            value: function getNumber(e) {
                return this._data[e];
            }
        }, {
            key: "setNumber",
            value: function setNumber(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getVector2",
            value: function getVector2(e) {
                return this._data[e];
            }
        }, {
            key: "setVector2",
            value: function setVector2(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getVector3",
            value: function getVector3(e) {
                return this._data[e];
            }
        }, {
            key: "setVector3",
            value: function setVector3(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getVector",
            value: function getVector(e) {
                return this._data[e];
            }
        }, {
            key: "setVector",
            value: function setVector(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getQuaternion",
            value: function getQuaternion(e) {
                return this._data[e];
            }
        }, {
            key: "setQuaternion",
            value: function setQuaternion(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getMatrix4x4",
            value: function getMatrix4x4(e) {
                return this._data[e];
            }
        }, {
            key: "setMatrix4x4",
            value: function setMatrix4x4(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getBuffer",
            value: function getBuffer(e) {
                return this._data[e];
            }
        }, {
            key: "setBuffer",
            value: function setBuffer(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "setTexture",
            value: function setTexture(e, t) {
                var r = this._data[e];
                this._data[e] = t, this._ownerResource && this._ownerResource.referenceCount > 0 && (r && r._removeReference(),
                    t && t._addReference());
            }
        }, {
            key: "getTexture",
            value: function getTexture(e) {
                return this._data[e];
            }
        }, {
            key: "setAttribute",
            value: function setAttribute(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getAttribute",
            value: function getAttribute(e) {
                return this._data[e];
            }
        }, {
            key: "getLength",
            value: function getLength() {
                return this._data.length;
            }
        }, {
            key: "setLength",
            value: function setLength(e) {
                this._data.length = e;
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var r = e,
                    s = r._data;
                for (var o in this._data) {
                    var l = this._data[o];
                    if (null != l)
                        if ("number" == typeof l) s[o] = l;
                        else if ("number" == typeof l) s[o] = l;
                    else if ("boolean" == typeof l) s[o] = l;
                    else if (l instanceof i) {
                        var _ = s[o] || (s[o] = new i());
                        l.cloneTo(_), s[o] = _;
                    } else if (l instanceof n) {
                        var h = s[o] || (s[o] = new n());
                        l.cloneTo(h), s[o] = h;
                    } else if (l instanceof a) {
                        var c = s[o] || (s[o] = new a());
                        l.cloneTo(c), s[o] = c;
                    } else if (l instanceof C) {
                        var d = s[o] || (s[o] = new C());
                        l.cloneTo(d), s[o] = d;
                    } else l instanceof t.BaseTexture && (s[o] = l);
                }
                this._defineDatas.cloneTo(r._defineDatas);
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new k();
                return this.cloneTo(e), e;
            }
        }, {
            key: "cloneToForNative",
            value: function cloneToForNative(e) {
                var r = e;
                this._int32Data.length - r._int32Data.length > 0 && r.needRenewArrayBufferForNative(this._int32Data.length),
                    r._int32Data.set(this._int32Data, 0);
                var s = r._nativeArray,
                    o = this._nativeArray.length;
                s.length = o;
                for (var l = 0; l < o; l++) {
                    var _ = this._nativeArray[l];
                    if (_)
                        if ("number" == typeof _) s[l] = _, r.setNumber(l, _);
                        else if ("number" == typeof _) s[l] = _,
                        r.setInt(l, _);
                    else if ("boolean" == typeof _) s[l] = _, r.setBool(l, _);
                    else if (_ instanceof i) {
                        var h = s[l] || (s[l] = new i());
                        _.cloneTo(h), s[l] = h, r.setVector2(l, h);
                    } else if (_ instanceof n) {
                        var c = s[l] || (s[l] = new n());
                        _.cloneTo(c), s[l] = c, r.setVector3(l, c);
                    } else if (_ instanceof a) {
                        var d = s[l] || (s[l] = new a());
                        _.cloneTo(d), s[l] = d, r.setVector(l, d);
                    } else if (_ instanceof C) {
                        var u = s[l] || (s[l] = new C());
                        _.cloneTo(u), s[l] = u, r.setMatrix4x4(l, u);
                    } else _ instanceof t.BaseTexture && (s[l] = _, r.setTexture(l, _));
                }
                this._defineDatas.cloneTo(r._defineDatas);
            }
        }, {
            key: "_initDataForNative",
            value: function _initDataForNative() {
                this._frameCount = -1, this._runtimeCopyValues.length = 0, this._nativeArray = [],
                    this._data = new ArrayBuffer(32), this._int32Data = new Int32Array(this._data),
                    this._float32Data = new Float32Array(this._data), t.LayaGL.instance.createArrayBufferRef(this._data, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0);
            }
        }, {
            key: "needRenewArrayBufferForNative",
            value: function needRenewArrayBufferForNative(e) {
                if (e >= this._int32Data.length) {
                    var r = 4 * (e + 1),
                        i = this._int32Data,
                        a = this._data.conchRef,
                        n = this._data._ptrID;
                    this._data = new ArrayBuffer(r), this._int32Data = new Int32Array(this._data), this._float32Data = new Float32Array(this._data),
                        this._data.conchRef = a, this._data._ptrID = n, i && this._int32Data.set(i, 0);
                    var s = t.LayaGL.instance;
                    s.updateArrayBufferRef ? s.updateArrayBufferRef(this._data._ptrID, a.isSyncToRender(), this._data) : window.conch.updateArrayBufferRef(this._data._ptrID, a.isSyncToRender(), this._data);
                }
            }
        }, {
            key: "getDataForNative",
            value: function getDataForNative() {
                return this._nativeArray;
            }
        }, {
            key: "getIntForNative",
            value: function getIntForNative(e) {
                return this._int32Data[e];
            }
        }, {
            key: "setIntForNative",
            value: function setIntForNative(e, t) {
                this.needRenewArrayBufferForNative(e), this._int32Data[e] = t, this._nativeArray[e] = t;
            }
        }, {
            key: "getBoolForNative",
            value: function getBoolForNative(e) {
                return 1 == this._int32Data[e];
            }
        }, {
            key: "setBoolForNative",
            value: function setBoolForNative(e, t) {
                this.needRenewArrayBufferForNative(e), this._int32Data[e] = t ? 1 : 0, this._nativeArray[e] = t;
            }
        }, {
            key: "getNumberForNative",
            value: function getNumberForNative(e) {
                return this._float32Data[e];
            }
        }, {
            key: "setNumberForNative",
            value: function setNumberForNative(e, t) {
                this.needRenewArrayBufferForNative(e), this._float32Data[e] = t, this._nativeArray[e] = t;
            }
        }, {
            key: "getMatrix4x4ForNative",
            value: function getMatrix4x4ForNative(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setMatrix4x4ForNative",
            value: function setMatrix4x4ForNative(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t;
                var r = this.setReferenceForNative(t.elements);
                this._int32Data[e] = r;
            }
        }, {
            key: "getVectorForNative",
            value: function getVectorForNative(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setVectorForNative",
            value: function setVectorForNative(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
                var r = this.setReferenceForNative(t.elements);
                this._int32Data[e] = r;
            }
        }, {
            key: "getVector2ForNative",
            value: function getVector2ForNative(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setVector2ForNative",
            value: function setVector2ForNative(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
                var r = this.setReferenceForNative(t.elements);
                this._int32Data[e] = r;
            }
        }, {
            key: "getVector3ForNative",
            value: function getVector3ForNative(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setVector3ForNative",
            value: function setVector3ForNative(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
                var r = this.setReferenceForNative(t.elements);
                this._int32Data[e] = r;
            }
        }, {
            key: "getQuaternionForNative",
            value: function getQuaternionForNative(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setQuaternionForNative",
            value: function setQuaternionForNative(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
                var r = this.setReferenceForNative(t.elements);
                this._int32Data[e] = r;
            }
        }, {
            key: "getBufferForNative",
            value: function getBufferForNative(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setBufferForNative",
            value: function setBufferForNative(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t;
                var r = this.setReferenceForNative(t);
                this._int32Data[e] = r;
            }
        }, {
            key: "getAttributeForNative",
            value: function getAttributeForNative(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setAttributeForNative",
            value: function setAttributeForNative(e, r) {
                this._nativeArray[e] = r, r._ptrID || t.LayaGL.instance.createArrayBufferRef(r, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0),
                    t.LayaGL.instance.syncBufferToRenderThread(r), this._int32Data[e] = r._ptrID;
            }
        }, {
            key: "getTextureForNative",
            value: function getTextureForNative(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setTextureForNative",
            value: function setTextureForNative(e, t) {
                if (t) {
                    this.needRenewArrayBufferForNative(e);
                    var r = this._nativeArray[e];
                    this._nativeArray[e] = t;
                    var i = t._getSource() || t.defaulteTexture._getSource();
                    this._int32Data[e] = i.id, this._ownerResource && this._ownerResource.referenceCount > 0 && (r && r._removeReference(),
                        t && t._addReference());
                }
            }
        }, {
            key: "setReferenceForNative",
            value: function setReferenceForNative(e) {
                this.clearRuntimeCopyArray();
                var r = 0,
                    i = 0;
                return k._SET_RUNTIME_VALUE_MODE_REFERENCE_ ? (t.LayaGL.instance.createArrayBufferRefs(e, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0, t.LayaGL.ARRAY_BUFFER_REF_REFERENCE),
                    r = 0, i = e.getPtrID(r)) : (t.LayaGL.instance.createArrayBufferRefs(e, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0, t.LayaGL.ARRAY_BUFFER_REF_COPY),
                    r = e.getRefNum() - 1, i = e.getPtrID(r), this._runtimeCopyValues.push({
                        obj: e,
                        refID: r,
                        ptrID: i
                    })), t.LayaGL.instance.syncBufferToRenderThread(e, r), i;
            }
        }, {
            key: "clearRuntimeCopyArray",
            value: function clearRuntimeCopyArray() {
                var e = t.Stat.loopCount;
                if (this._frameCount != e) {
                    this._frameCount = e;
                    for (var r = 0, i = this._runtimeCopyValues.length; r < i; r++) {
                        this._runtimeCopyValues[r].obj.clearRefNum();
                    }
                    this._runtimeCopyValues.length = 0;
                }
            }
        }], [{
            key: "setRuntimeValueMode",
            value: function setRuntimeValueMode(e) {
                k._SET_RUNTIME_VALUE_MODE_REFERENCE_ = e;
            }
        }]);
        return k;
    }();
    k._SET_RUNTIME_VALUE_MODE_REFERENCE_ = !0;
    var W = /* */ function() {
        function W() {
            _classCallCheck(this, W);
            this._compositeShader = H.find("PostProcessComposite"), this._compositeShaderData = new k(),
                this._effects = [], this._context = null, this._context = new V(), this._context.compositeShaderData = this._compositeShaderData;
        }
        _createClass(W, [{
            key: "_init",
            value: function _init(e, t) {
                this._context.camera = e, this._context.command = t;
            }
        }, {
            key: "_render",
            value: function _render() {
                var e = k._SET_RUNTIME_VALUE_MODE_REFERENCE_;
                t.ILaya.Render.supportWebGLPlusRendering && k.setRuntimeValueMode(!1);
                var r = this._context.camera,
                    i = r.viewport,
                    a = F.createFromPool(w.clientWidth, w.clientHeight, r._getRenderTextureFormat(), t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE),
                    n = r._internalRenderTexture;
                this._context.command.clear(), this._context.source = a, this._context.destination = n,
                    this._context.compositeShaderData.clearDefine(), this._context.command.blitScreenTriangle(n, a),
                    this._context.compositeShaderData.setTexture(W.SHADERVALUE_AUTOEXPOSURETEX, t.Texture2D.whiteTexture);
                for (var s = 0, o = this._effects.length; s < o; s++) {
                    this._effects[s].render(this._context);
                }
                this._compositeShaderData.addDefine(W.SHADERDEFINE_FINALPASS);
                var l = r._offScreenRenderTexture,
                    _ = l || null;
                this._context.destination = _;
                var h = r._getCanvasWidth(),
                    c = r._getCanvasHeight();
                r._screenOffsetScale.setValue(i.x / h, i.y / c, i.width / h, i.height / c), this._context.command.blitScreenTriangle(this._context.source, _, r._screenOffsetScale, this._compositeShader, this._compositeShaderData),
                    F.recoverToPool(a);
                var d = this._context.deferredReleaseTextures;
                for (s = 0, o = d.length; s < o; s++) {
                    F.recoverToPool(d[s]);
                }
                d.length = 0, t.ILaya.Render.supportWebGLPlusRendering && k.setRuntimeValueMode(e);
            }
        }, {
            key: "addEffect",
            value: function addEffect(e) {
                this._effects.push(e);
            }
        }, {
            key: "removeEffect",
            value: function removeEffect(e) {
                var t = this._effects.indexOf(e); -
                1 !== t && this._effects.splice(t, 1);
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                W.SHADERDEFINE_BLOOM_LOW = H.getDefineByName("BLOOM_LOW"), W.SHADERDEFINE_BLOOM = H.getDefineByName("BLOOM"),
                    W.SHADERDEFINE_FINALPASS = H.getDefineByName("FINALPASS");
            }
        }]);
        return W;
    }();
    W.SHADERVALUE_MAINTEX = H.propertyNameToID("u_MainTex"), W.SHADERVALUE_BLOOMTEX = H.propertyNameToID("u_BloomTex"),
        W.SHADERVALUE_AUTOEXPOSURETEX = H.propertyNameToID("u_AutoExposureTex"), W.SHADERVALUE_BLOOM_DIRTTEX = H.propertyNameToID("u_Bloom_DirtTex"),
        W.SHADERVALUE_BLOOMTEX_TEXELSIZE = H.propertyNameToID("u_BloomTex_TexelSize"), W.SHADERVALUE_BLOOM_DIRTTILEOFFSET = H.propertyNameToID("u_Bloom_DirtTileOffset"),
        W.SHADERVALUE_BLOOM_SETTINGS = H.propertyNameToID("u_Bloom_Settings"), W.SHADERVALUE_BLOOM_COLOR = H.propertyNameToID("u_Bloom_Color");
    var X = /* */ function(_t$EventDispatcher) {
        _inherits(X, _t$EventDispatcher);

        function X(e) {
            var _this6;
            var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
            var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
            var s = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
            _classCallCheck(this, X);
            _this6 = _possibleConstructorReturn(this, _getPrototypeOf(X).call(this)), _this6._owner = e,
                _this6._children = [], _this6._localMatrix = new Float32Array(16), t.Render.supportWebGLPlusAnimation ? (_this6._localPosition = new y(0, 0, 0, r),
                    _this6._localRotation = new O(0, 0, 0, 1, i), _this6._localScale = new y(0, 0, 0, a),
                    _this6._worldMatrix = s) : (_this6._localPosition = new n(), _this6._localRotation = new f(),
                    _this6._localScale = new n(), _this6._worldMatrix = new Float32Array(16)), _this6._localQuaternionUpdate = !1,
                _this6._locaEulerlUpdate = !1, _this6._localUpdate = !1, _this6._worldUpdate = !0;
            return _this6;
        }
        _createClass(X, [{
            key: "_getlocalMatrix",
            value: function _getlocalMatrix() {
                return this._localUpdate && (I._createAffineTransformationArray(this._localPosition, this._localRotation, this._localScale, this._localMatrix),
                    this._localUpdate = !1), this._localMatrix;
            }
        }, {
            key: "_onWorldTransform",
            value: function _onWorldTransform() {
                if (!this._worldUpdate) {
                    this._worldUpdate = !0, this.event(t.Event.TRANSFORM_CHANGED);
                    for (var e = 0, r = this._children.length; e < r; e++) {
                        this._children[e]._onWorldTransform();
                    }
                }
            }
        }, {
            key: "getWorldMatrix",
            value: function getWorldMatrix() {
                if (!t.Render.supportWebGLPlusAnimation && this._worldUpdate) {
                    if (null != this._parent) I.matrix4x4MultiplyFFF(this._parent.getWorldMatrix(), this._getlocalMatrix(), this._worldMatrix);
                    else {
                        var e = this._worldMatrix;
                        e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0,
                            e[0] = e[5] = e[10] = e[15] = 1;
                    }
                    this._worldUpdate = !1;
                }
                return t.Render.supportWebGLPlusAnimation && this._worldUpdate && (this._worldUpdate = !1),
                    this._worldMatrix;
            }
        }, {
            key: "setParent",
            value: function setParent(e) {
                if (this._parent !== e) {
                    if (this._parent) {
                        var t = this._parent._children,
                            r = t.indexOf(this);
                        t.splice(r, 1);
                    }
                    e && (e._children.push(this), e && this._onWorldTransform()), this._parent = e;
                }
            }
        }, {
            key: "localPosition",
            get: function get() {
                return this._localPosition;
            },
            set: function set(e) {
                this._localPosition = e, this._localUpdate = !0, this._onWorldTransform();
            }
        }, {
            key: "localRotation",
            get: function get() {
                if (this._localQuaternionUpdate) {
                    var e = this._localRotationEuler;
                    f.createFromYawPitchRoll(e.y / X._angleToRandin, e.x / X._angleToRandin, e.z / X._angleToRandin, this._localRotation),
                        this._localQuaternionUpdate = !1;
                }
                return this._localRotation;
            },
            set: function set(e) {
                this._localRotation = e, this._locaEulerlUpdate = !0, this._localQuaternionUpdate = !1,
                    this._localUpdate = !0, this._onWorldTransform();
            }
        }, {
            key: "localScale",
            get: function get() {
                return this._localScale;
            },
            set: function set(e) {
                this._localScale = e, this._localUpdate = !0, this._onWorldTransform();
            }
        }, {
            key: "localRotationEuler",
            get: function get() {
                if (this._locaEulerlUpdate) {
                    this._localRotation.getYawPitchRoll(X._tempVector3);
                    var e = X._tempVector3,
                        t = this._localRotationEuler;
                    t.x = e.y * X._angleToRandin, t.y = e.x * X._angleToRandin, t.z = e.z * X._angleToRandin,
                        this._locaEulerlUpdate = !1;
                }
                return this._localRotationEuler;
            },
            set: function set(e) {
                this._localRotationEuler = e, this._locaEulerlUpdate = !1, this._localQuaternionUpdate = !0,
                    this._localUpdate = !0, this._onWorldTransform();
            }
        }]);
        return X;
    }(t.EventDispatcher);
    X._tempVector3 = new n(), X._angleToRandin = 180 / Math.PI;
    var Y = /* */ function() {
        function Y() {
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
            var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
            _classCallCheck(this, Y);
            this._children = [], this.transform = new X(this, e, t, r, i);
        }
        _createClass(Y, [{
            key: "addChild",
            value: function addChild(e) {
                e._parent = this, e.transform.setParent(this.transform), this._children.push(e);
            }
        }, {
            key: "removeChild",
            value: function removeChild(e) {
                var t = this._children.indexOf(e); -
                1 !== t && this._children.splice(t, 1);
            }
        }, {
            key: "getChildByName",
            value: function getChildByName(e) {
                for (var t = 0, r = this._children.length; t < r; t++) {
                    var i = this._children[t];
                    if (i.name === e) return i;
                }
                return null;
            }
        }, {
            key: "getChildByIndex",
            value: function getChildByIndex(e) {
                return this._children[e];
            }
        }, {
            key: "getChildCount",
            value: function getChildCount() {
                return this._children.length;
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t.name = this.name;
                for (var r = 0, i = this._children.length; r < i; r++) {
                    var a = this._children[r],
                        n = a.clone();
                    t.addChild(n);
                    var s = a.transform,
                        o = n.transform,
                        l = o.localPosition,
                        _ = o.localRotation,
                        h = o.localScale;
                    s.localPosition.cloneTo(l), s.localRotation.cloneTo(_), s.localScale.cloneTo(h),
                        o.localPosition = l, o.localRotation = _, o.localScale = h;
                }
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Y();
                return this.cloneTo(e), e;
            }
        }, {
            key: "_cloneNative",
            value: function _cloneNative(e, t, r, i, a, n, s) {
                var o = s._nativeCurCloneCount;
                a[o] = n;
                var l = new Float32Array(e.buffer, 3 * o * 4, 3),
                    _ = new Float32Array(t.buffer, 4 * o * 4, 4),
                    h = new Float32Array(r.buffer, 3 * o * 4, 3),
                    c = new Float32Array(i.buffer, 16 * o * 4, 16),
                    d = new Y(l, _, h, c);
                return d._worldMatrixIndex = o, this._cloneToNative(d, e, t, r, i, a, o, s), d;
            }
        }, {
            key: "_cloneToNative",
            value: function _cloneToNative(e, t, r, i, a, n, s, o) {
                var l = e;
                l.name = this.name;
                for (var _ = 0, h = this._children.length; _ < h; _++) {
                    var c = this._children[_];
                    o._nativeCurCloneCount++;
                    var d = c._cloneNative(t, r, i, a, n, s, o);
                    l.addChild(d);
                    var u = c.transform,
                        m = d.transform,
                        f = m.localPosition,
                        E = m.localRotation,
                        T = m.localScale;
                    u.localPosition.cloneTo(f), u.localRotation.cloneTo(E), u.localScale.cloneTo(T),
                        m.localPosition = f, m.localRotation = E, m.localScale = T;
                }
            }
        }]);
        return Y;
    }();
    var Z = /* */ function(_t$Resource2) {
        _inherits(Z, _t$Resource2);

        function Z() {
            var _this7;
            _classCallCheck(this, Z);
            _this7 = _possibleConstructorReturn(this, _getPrototypeOf(Z).call(this)), _this7._nativeNodeCount = 0,
                _this7._nativeCurCloneCount = 0;
            return _this7;
        }
        _createClass(Z, [{
            key: "_initCloneToAnimator",
            value: function _initCloneToAnimator(e, t) {
                t._avatarNodeMap[e.name] = e;
                for (var r = 0, i = e.getChildCount(); r < i; r++) {
                    this._initCloneToAnimator(e.getChildByIndex(r), t);
                }
            }
        }, {
            key: "_parseNode",
            value: function _parseNode(e, r) {
                var i = e.props.name;
                r.name = i;
                var a = e.props,
                    n = r.transform,
                    s = n.localPosition,
                    o = n.localRotation,
                    l = n.localScale;
                s.fromArray(a.translate), o.fromArray(a.rotation), l.fromArray(a.scale), n.localPosition = s,
                    n.localRotation = o, n.localScale = l;
                for (var _ = e.child, h = 0, c = _.length; h < c; h++) {
                    var d = _[h],
                        u = new Y(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16));
                    r.addChild(u), t.Render.supportWebGLPlusAnimation && this._nativeNodeCount++, this._parseNode(d, u);
                }
            }
        }, {
            key: "_cloneDatasToAnimator",
            value: function _cloneDatasToAnimator(e) {
                var t;
                t = this._rootNode.clone();
                var r = this._rootNode.transform,
                    i = t.transform,
                    a = i.localPosition,
                    n = i.localRotation,
                    s = i.localScale;
                r.localPosition.cloneTo(a), r.localRotation.cloneTo(n), r.localScale.cloneTo(s),
                    i.localPosition = a, i.localRotation = n, i.localScale = s, e._avatarNodeMap = {},
                    this._initCloneToAnimator(t, e);
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e,
                    r = this._rootNode.clone();
                t._rootNode = r;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Z();
                return this.cloneTo(e), e;
            }
        }, {
            key: "_cloneDatasToAnimatorNative",
            value: function _cloneDatasToAnimatorNative(e) {
                var t = new Float32Array(3 * this._nativeNodeCount),
                    r = new Float32Array(4 * this._nativeNodeCount),
                    i = new Float32Array(3 * this._nativeNodeCount),
                    a = new Float32Array(16 * this._nativeNodeCount),
                    n = new Int16Array(this._nativeNodeCount);
                e._animationNodeLocalPositions = t, e._animationNodeLocalRotations = r, e._animationNodeLocalScales = i,
                    e._animationNodeWorldMatrixs = a, e._animationNodeParentIndices = n, this._nativeCurCloneCount = 0;
                var s = this._rootNode._cloneNative(t, r, i, a, n, -1, this),
                    o = this._rootNode.transform,
                    l = s.transform,
                    _ = l.localPosition,
                    h = l.localRotation,
                    c = l.localScale;
                o.localPosition.cloneTo(_), o.localRotation.cloneTo(h), o.localScale.cloneTo(c),
                    l.localPosition = _, l.localRotation = h, l.localScale = c, e._avatarNodeMap = {},
                    this._initCloneToAnimator(s, e);
            }
        }], [{
            key: "_parse",
            value: function _parse(e) {
                var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var a = new Z();
                if (a._rootNode = new Y(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16)),
                    t.Render.supportWebGLPlusAnimation && a._nativeNodeCount++, e.version) {
                    var n = e.rootNode;
                    n && a._parseNode(n, a._rootNode);
                }
                return a;
            }
        }, {
            key: "load",
            value: function load(e, r) {
                t.ILaya.loader.create(e, r, null, Z.AVATAR);
            }
        }]);
        return Z;
    }(t.Resource);
    Z.AVATAR = "AVATAR";
    var j = /* */ function(_t$Resource3) {
        _inherits(j, _t$Resource3);

        function j() {
            var _this8;
            _classCallCheck(this, j);
            _this8 = _possibleConstructorReturn(this, _getPrototypeOf(j).call(this)), _this8._shaderValues = null,
                _this8._shaderValues = new k(_assertThisInitialized(_this8)), _this8.renderQueue = j.RENDERQUEUE_OPAQUE,
                _this8._alphaTest = !1;
            return _this8;
        }
        _createClass(j, [{
            key: "_removeTetxureReference",
            value: function _removeTetxureReference() {
                var e = this._shaderValues.getData();
                for (var r in e) {
                    var i = e[r];
                    i && i instanceof t.BaseTexture && i._removeReference();
                }
            }
        }, {
            key: "_disposeResource",
            value: function _disposeResource() {
                this._referenceCount > 0 && this._removeTetxureReference(), this._shaderValues = null;
            }
        }, {
            key: "_addReference",
            value: function _addReference() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
                _get(_getPrototypeOf(j.prototype), "_addReference", this).call(this, e);
                var r = this._shaderValues.getData();
                for (var i in r) {
                    var a = r[i];
                    a && a instanceof t.BaseTexture && a._addReference();
                }
            }
        }, {
            key: "_removeReference",
            value: function _removeReference() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
                _get(_getPrototypeOf(j.prototype), "_removeReference", this).call(this, e), this._removeTetxureReference();
            }
        }, {
            key: "setShaderName",
            value: function setShaderName(e) {
                if (this._shader = H.find(e), !this._shader) throw new Error("BaseMaterial: unknown shader name.");
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t.name = this.name, t.renderQueue = this.renderQueue, this._shaderValues.cloneTo(t._shaderValues);
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new j();
                return this.cloneTo(e), e;
            }
        }, {
            key: "shaderData",
            get: function get() {
                return this._shaderValues;
            }
        }, {
            key: "alphaTestValue",
            get: function get() {
                return this._shaderValues.getNumber(j.ALPHATESTVALUE);
            },
            set: function set(e) {
                this._shaderValues.setNumber(j.ALPHATESTVALUE, e);
            }
        }, {
            key: "alphaTest",
            get: function get() {
                return this._alphaTest;
            },
            set: function set(e) {
                this._alphaTest = e, e ? this._shaderValues.addDefine(j.SHADERDEFINE_ALPHATEST) : this._shaderValues.removeDefine(j.SHADERDEFINE_ALPHATEST);
            }
        }, {
            key: "_defineDatas",
            get: function get() {
                return this._shaderValues._defineDatas;
            }
        }], [{
            key: "load",
            value: function load(e, r) {
                t.Laya.loader.create(e, r, null, j.MATERIAL);
            }
        }, {
            key: "__initDefine__",
            value: function __initDefine__() {
                j.SHADERDEFINE_ALPHATEST = H.getDefineByName("ALPHATEST");
            }
        }, {
            key: "_parse",
            value: function _parse(e) {
                var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var o, l = e,
                    _ = l.props,
                    h = _.type,
                    c = t.ClassUtils.getRegClass(h);
                if (!c) throw "_getSprite3DHierarchyInnerUrls 错误: " + e.type + " 不是类";
                switch (o = new c(), l.version) {
                    case "LAYAMATERIAL:01":
                    case "LAYAMATERIAL:02":
                        var d, u;
                        for (var m in _) {
                            switch (m) {
                                case "type":
                                    break;

                                case "vectors":
                                    var f = _[m];
                                    for (d = 0, u = f.length; d < u; d++) {
                                        var E = f[d],
                                            T = E.value;
                                        switch (T.length) {
                                            case 2:
                                                o[E.name] = new i(T[0], T[1]);
                                                break;

                                            case 3:
                                                o[E.name] = new n(T[0], T[1], T[2]);
                                                break;

                                            case 4:
                                                o[E.name] = new a(T[0], T[1], T[2], T[3]);
                                                break;

                                            default:
                                                throw new Error("BaseMaterial:unkonwn color length.");
                                        }
                                    }
                                    break;

                                case "textures":
                                    var p = _[m];
                                    for (d = 0, u = p.length; d < u; d++) {
                                        var g = p[d],
                                            S = g.path;
                                        S && (o[g.name] = t.Loader.getRes(S));
                                    }
                                    break;

                                case "defines":
                                    var R = _[m];
                                    for (d = 0, u = R.length; d < u; d++) {
                                        var v = H.getDefineByName(R[d]);
                                        o._shaderValues.addDefine(v);
                                    }
                                    break;

                                case "renderStates":
                                    var x = _[m][0],
                                        I = o;
                                    I.blend = x.blend, I.cull = x.cull, I.depthTest = x.depthTest, I.depthWrite = x.depthWrite,
                                        I.blendSrc = x.srcBlend, I.blendDst = x.dstBlend;
                                    break;

                                case "cull":
                                    o.cull = _[m];
                                    break;

                                case "blend":
                                    o.blend = _[m];
                                    break;

                                case "depthWrite":
                                    o.depthWrite = _[m];
                                    break;

                                case "srcBlend":
                                    o.blendSrc = _[m];
                                    break;

                                case "dstBlend":
                                    o.blendDst = _[m];
                                    break;

                                default:
                                    o[m] = _[m];
                            }
                        }
                        break;

                    default:
                        throw new Error("BaseMaterial:unkonwn version.");
                }
                return o;
            }
        }]);
        return j;
    }(t.Resource);
    j.MATERIAL = "MATERIAL", j.RENDERQUEUE_OPAQUE = 2e3, j.RENDERQUEUE_ALPHATEST = 2450,
        j.RENDERQUEUE_TRANSPARENT = 3e3, j.ALPHATESTVALUE = H.propertyNameToID("u_AlphaTestValue"),
        j.SHADERDEFINE_ALPHATEST = null;
    var q = /* */ function() {
        function q() {
            _classCallCheck(this, q);
        }
        _createClass(q, null, [{
            key: "load",
            value: function load(e, r) {
                t.Laya.loader.create(e, r, null, j.MATERIAL);
            }
        }, {
            key: "__initDefine__",
            value: function __initDefine__() {
                q.SHADERDEFINE_ALPHATEST = j.SHADERDEFINE_ALPHATEST;
            }
        }]);
        return q;
    }();
    q.MATERIAL = "MATERIAL", q.RENDERQUEUE_OPAQUE = 2e3, q.RENDERQUEUE_ALPHATEST = 2450,
        q.RENDERQUEUE_TRANSPARENT = 3e3, q.ALPHATESTVALUE = H.propertyNameToID("u_AlphaTestValue"),
        q.SHADERDEFINE_ALPHATEST = null;
    var Q = /* */ function() {
        function Q() {
            _classCallCheck(this, Q);
            this.cull = Q.CULL_BACK, this.blend = Q.BLEND_DISABLE, this.srcBlend = Q.BLENDPARAM_ONE,
                this.dstBlend = Q.BLENDPARAM_ZERO, this.srcBlendRGB = Q.BLENDPARAM_ONE, this.dstBlendRGB = Q.BLENDPARAM_ZERO,
                this.srcBlendAlpha = Q.BLENDPARAM_ONE, this.dstBlendAlpha = Q.BLENDPARAM_ZERO, this.blendConstColor = new a(1, 1, 1, 1),
                this.blendEquation = Q.BLENDEQUATION_ADD, this.blendEquationRGB = Q.BLENDEQUATION_ADD,
                this.blendEquationAlpha = Q.BLENDEQUATION_ADD, this.depthTest = Q.DEPTHTEST_LEQUAL,
                this.depthWrite = !0;
        }
        _createClass(Q, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t.cull = this.cull, t.blend = this.blend, t.srcBlend = this.srcBlend, t.dstBlend = this.dstBlend,
                    t.srcBlendRGB = this.srcBlendRGB, t.dstBlendRGB = this.dstBlendRGB, t.srcBlendAlpha = this.srcBlendAlpha,
                    t.dstBlendAlpha = this.dstBlendAlpha, this.blendConstColor.cloneTo(t.blendConstColor),
                    t.blendEquation = this.blendEquation, t.blendEquationRGB = this.blendEquationRGB,
                    t.blendEquationAlpha = this.blendEquationAlpha, t.depthTest = this.depthTest, t.depthWrite = this.depthWrite;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Q();
                return this.cloneTo(e), e;
            }
        }]);
        return Q;
    }();
    Q.CULL_NONE = 0, Q.CULL_FRONT = 1, Q.CULL_BACK = 2, Q.BLEND_DISABLE = 0, Q.BLEND_ENABLE_ALL = 1,
        Q.BLEND_ENABLE_SEPERATE = 2, Q.BLENDPARAM_ZERO = 0, Q.BLENDPARAM_ONE = 1, Q.BLENDPARAM_SRC_COLOR = 768,
        Q.BLENDPARAM_ONE_MINUS_SRC_COLOR = 769, Q.BLENDPARAM_DST_COLOR = 774, Q.BLENDPARAM_ONE_MINUS_DST_COLOR = 775,
        Q.BLENDPARAM_SRC_ALPHA = 770, Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA = 771, Q.BLENDPARAM_DST_ALPHA = 772,
        Q.BLENDPARAM_ONE_MINUS_DST_ALPHA = 773, Q.BLENDPARAM_SRC_ALPHA_SATURATE = 776, Q.BLENDEQUATION_ADD = 32774,
        Q.BLENDEQUATION_SUBTRACT = 32778, Q.BLENDEQUATION_REVERSE_SUBTRACT = 32779, Q.DEPTHTEST_OFF = 0,
        Q.DEPTHTEST_NEVER = 512, Q.DEPTHTEST_LESS = 513, Q.DEPTHTEST_EQUAL = 514, Q.DEPTHTEST_LEQUAL = 515,
        Q.DEPTHTEST_GREATER = 516, Q.DEPTHTEST_NOTEQUAL = 517, Q.DEPTHTEST_GEQUAL = 518,
        Q.DEPTHTEST_ALWAYS = 519;
    var K = /* */ function(_j) {
        _inherits(K, _j);

        function K() {
            var _this9;
            _classCallCheck(this, K);
            _this9 = _possibleConstructorReturn(this, _getPrototypeOf(K).call(this)), _this9._enableVertexColor = !1,
                _this9.setShaderName("BLINNPHONG"), _this9._albedoIntensity = 1, _this9._albedoColor = new a(1, 1, 1, 1);
            var e = _this9._shaderValues;
            e.setVector(K.ALBEDOCOLOR, new a(1, 1, 1, 1)), e.setVector(K.MATERIALSPECULAR, new a(1, 1, 1, 1)),
                e.setNumber(K.SHININESS, .078125), e.setNumber(j.ALPHATESTVALUE, .5), e.setVector(K.TILINGOFFSET, new a(1, 1, 0, 0)),
                _this9._enableLighting = !0, _this9.renderMode = K.RENDERMODE_OPAQUE;
            return _this9;
        }
        _createClass(K, [{
            key: "clone",
            value: function clone() {
                var e = new K();
                return this.cloneTo(e), e;
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                _get(_getPrototypeOf(K.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t._enableLighting = this._enableLighting, t._albedoIntensity = this._albedoIntensity,
                    t._enableVertexColor = this._enableVertexColor, this._albedoColor.cloneTo(t._albedoColor);
            }
        }, {
            key: "_ColorR",
            get: function get() {
                return this._albedoColor.x;
            },
            set: function set(e) {
                this._albedoColor.x = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorG",
            get: function get() {
                return this._albedoColor.y;
            },
            set: function set(e) {
                this._albedoColor.y = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorB",
            get: function get() {
                return this._albedoColor.z;
            },
            set: function set(e) {
                this._albedoColor.z = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorA",
            get: function get() {
                return this._albedoColor.w;
            },
            set: function set(e) {
                this._albedoColor.w = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_SpecColorR",
            get: function get() {
                return this._shaderValues.getVector(K.MATERIALSPECULAR).x;
            },
            set: function set(e) {
                this._shaderValues.getVector(K.MATERIALSPECULAR).x = e;
            }
        }, {
            key: "_SpecColorG",
            get: function get() {
                return this._shaderValues.getVector(K.MATERIALSPECULAR).y;
            },
            set: function set(e) {
                this._shaderValues.getVector(K.MATERIALSPECULAR).y = e;
            }
        }, {
            key: "_SpecColorB",
            get: function get() {
                return this._shaderValues.getVector(K.MATERIALSPECULAR).z;
            },
            set: function set(e) {
                this._shaderValues.getVector(K.MATERIALSPECULAR).z = e;
            }
        }, {
            key: "_SpecColorA",
            get: function get() {
                return this._shaderValues.getVector(K.MATERIALSPECULAR).w;
            },
            set: function set(e) {
                this._shaderValues.getVector(K.MATERIALSPECULAR).w = e;
            }
        }, {
            key: "_AlbedoIntensity",
            get: function get() {
                return this._albedoIntensity;
            },
            set: function set(e) {
                if (this._albedoIntensity !== e) {
                    var t = this._shaderValues.getVector(K.ALBEDOCOLOR);
                    a.scale(this._albedoColor, e, t), this._albedoIntensity = e, this._shaderValues.setVector(K.ALBEDOCOLOR, t);
                }
            }
        }, {
            key: "_Shininess",
            get: function get() {
                return this._shaderValues.getNumber(K.SHININESS);
            },
            set: function set(e) {
                e = Math.max(0, Math.min(1, e)), this._shaderValues.setNumber(K.SHININESS, e);
            }
        }, {
            key: "_MainTex_STX",
            get: function get() {
                return this._shaderValues.getVector(K.TILINGOFFSET).x;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(K.TILINGOFFSET);
                t.x = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function get() {
                return this._shaderValues.getVector(K.TILINGOFFSET).y;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(K.TILINGOFFSET);
                t.y = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function get() {
                return this._shaderValues.getVector(K.TILINGOFFSET).z;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(K.TILINGOFFSET);
                t.z = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function get() {
                return this._shaderValues.getVector(K.TILINGOFFSET).w;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(K.TILINGOFFSET);
                t.w = e, this.tilingOffset = t;
            }
        }, {
            key: "_Cutoff",
            get: function get() {
                return this.alphaTestValue;
            },
            set: function set(e) {
                this.alphaTestValue = e;
            }
        }, {
            key: "renderMode",
            set: function set(e) {
                switch (e) {
                    case K.RENDERMODE_OPAQUE:
                        this.alphaTest = !1, this.renderQueue = j.RENDERQUEUE_OPAQUE, this.depthWrite = !0,
                            this.cull = Q.CULL_BACK, this.blend = Q.BLEND_DISABLE, this.depthTest = Q.DEPTHTEST_LESS;
                        break;

                    case K.RENDERMODE_CUTOUT:
                        this.renderQueue = j.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0,
                            this.cull = Q.CULL_BACK, this.blend = Q.BLEND_DISABLE, this.depthTest = Q.DEPTHTEST_LESS;
                        break;

                    case K.RENDERMODE_TRANSPARENT:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                            this.cull = Q.CULL_BACK, this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                            this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Q.DEPTHTEST_LESS;
                        break;

                    default:
                        throw new Error("Material:renderMode value error.");
                }
            }
        }, {
            key: "enableVertexColor",
            get: function get() {
                return this._enableVertexColor;
            },
            set: function set(e) {
                this._enableVertexColor = e, e ? this._shaderValues.addDefine(K.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._shaderValues.removeDefine(K.SHADERDEFINE_ENABLEVERTEXCOLOR);
            }
        }, {
            key: "tilingOffsetX",
            get: function get() {
                return this._MainTex_STX;
            },
            set: function set(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function get() {
                return this._MainTex_STY;
            },
            set: function set(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function get() {
                return this._MainTex_STZ;
            },
            set: function set(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function get() {
                return this._MainTex_STW;
            },
            set: function set(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function get() {
                return this._shaderValues.getVector(K.TILINGOFFSET);
            },
            set: function set(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(K.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(K.SHADERDEFINE_TILINGOFFSET),
                    this._shaderValues.setVector(K.TILINGOFFSET, e);
            }
        }, {
            key: "albedoColorR",
            get: function get() {
                return this._ColorR;
            },
            set: function set(e) {
                this._ColorR = e;
            }
        }, {
            key: "albedoColorG",
            get: function get() {
                return this._ColorG;
            },
            set: function set(e) {
                this._ColorG = e;
            }
        }, {
            key: "albedoColorB",
            get: function get() {
                return this._ColorB;
            },
            set: function set(e) {
                this._ColorB = e;
            }
        }, {
            key: "albedoColorA",
            get: function get() {
                return this._ColorA;
            },
            set: function set(e) {
                this._ColorA = e;
            }
        }, {
            key: "albedoColor",
            get: function get() {
                return this._albedoColor;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(K.ALBEDOCOLOR);
                a.scale(e, this._albedoIntensity, t), this._albedoColor = e, this._shaderValues.setVector(K.ALBEDOCOLOR, t);
            }
        }, {
            key: "albedoIntensity",
            get: function get() {
                return this._albedoIntensity;
            },
            set: function set(e) {
                this._AlbedoIntensity = e;
            }
        }, {
            key: "specularColorR",
            get: function get() {
                return this._SpecColorR;
            },
            set: function set(e) {
                this._SpecColorR = e;
            }
        }, {
            key: "specularColorG",
            get: function get() {
                return this._SpecColorG;
            },
            set: function set(e) {
                this._SpecColorG = e;
            }
        }, {
            key: "specularColorB",
            get: function get() {
                return this._SpecColorB;
            },
            set: function set(e) {
                this._SpecColorB = e;
            }
        }, {
            key: "specularColorA",
            get: function get() {
                return this._SpecColorA;
            },
            set: function set(e) {
                this._SpecColorA = e;
            }
        }, {
            key: "specularColor",
            get: function get() {
                return this._shaderValues.getVector(K.MATERIALSPECULAR);
            },
            set: function set(e) {
                this._shaderValues.setVector(K.MATERIALSPECULAR, e);
            }
        }, {
            key: "shininess",
            get: function get() {
                return this._Shininess;
            },
            set: function set(e) {
                this._Shininess = e;
            }
        }, {
            key: "albedoTexture",
            get: function get() {
                return this._shaderValues.getTexture(K.ALBEDOTEXTURE);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(K.SHADERDEFINE_DIFFUSEMAP) : this._shaderValues.removeDefine(K.SHADERDEFINE_DIFFUSEMAP),
                    this._shaderValues.setTexture(K.ALBEDOTEXTURE, e);
            }
        }, {
            key: "normalTexture",
            get: function get() {
                return this._shaderValues.getTexture(K.NORMALTEXTURE);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(K.SHADERDEFINE_NORMALMAP) : this._shaderValues.removeDefine(K.SHADERDEFINE_NORMALMAP),
                    this._shaderValues.setTexture(K.NORMALTEXTURE, e);
            }
        }, {
            key: "specularTexture",
            get: function get() {
                return this._shaderValues.getTexture(K.SPECULARTEXTURE);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(K.SHADERDEFINE_SPECULARMAP) : this._shaderValues.removeDefine(K.SHADERDEFINE_SPECULARMAP),
                    this._shaderValues.setTexture(K.SPECULARTEXTURE, e);
            }
        }, {
            key: "depthWrite",
            get: function get() {
                return this._shaderValues.getBool(K.DEPTH_WRITE);
            },
            set: function set(e) {
                this._shaderValues.setBool(K.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function get() {
                return this._shaderValues.getInt(K.CULL);
            },
            set: function set(e) {
                this._shaderValues.setInt(K.CULL, e);
            }
        }, {
            key: "blend",
            get: function get() {
                return this._shaderValues.getInt(K.BLEND);
            },
            set: function set(e) {
                this._shaderValues.setInt(K.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function get() {
                return this._shaderValues.getInt(K.BLEND_SRC);
            },
            set: function set(e) {
                this._shaderValues.setInt(K.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function get() {
                return this._shaderValues.getInt(K.BLEND_DST);
            },
            set: function set(e) {
                this._shaderValues.setInt(K.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function get() {
                return this._shaderValues.getInt(K.DEPTH_TEST);
            },
            set: function set(e) {
                this._shaderValues.setInt(K.DEPTH_TEST, e);
            }
        }], [{
            key: "__initDefine__",
            value: function __initDefine__() {
                K.SHADERDEFINE_DIFFUSEMAP = H.getDefineByName("DIFFUSEMAP"), K.SHADERDEFINE_NORMALMAP = H.getDefineByName("NORMALMAP"),
                    K.SHADERDEFINE_SPECULARMAP = H.getDefineByName("SPECULARMAP"), K.SHADERDEFINE_TILINGOFFSET = H.getDefineByName("TILINGOFFSET"),
                    K.SHADERDEFINE_ENABLEVERTEXCOLOR = H.getDefineByName("ENABLEVERTEXCOLOR");
            }
        }]);
        return K;
    }(j);
    K.RENDERMODE_OPAQUE = 0, K.RENDERMODE_CUTOUT = 1, K.RENDERMODE_TRANSPARENT = 2,
        K.ALBEDOTEXTURE = H.propertyNameToID("u_DiffuseTexture"), K.NORMALTEXTURE = H.propertyNameToID("u_NormalTexture"),
        K.SPECULARTEXTURE = H.propertyNameToID("u_SpecularTexture"), K.ALBEDOCOLOR = H.propertyNameToID("u_DiffuseColor"),
        K.MATERIALSPECULAR = H.propertyNameToID("u_MaterialSpecular"), K.SHININESS = H.propertyNameToID("u_Shininess"),
        K.TILINGOFFSET = H.propertyNameToID("u_TilingOffset"), K.CULL = H.propertyNameToID("s_Cull"),
        K.BLEND = H.propertyNameToID("s_Blend"), K.BLEND_SRC = H.propertyNameToID("s_BlendSrc"),
        K.BLEND_DST = H.propertyNameToID("s_BlendDst"), K.DEPTH_TEST = H.propertyNameToID("s_DepthTest"),
        K.DEPTH_WRITE = H.propertyNameToID("s_DepthWrite");
    var J = /* */ function(_j2) {
        _inherits(J, _j2);

        function J() {
            var _this10;
            _classCallCheck(this, J);
            _this10 = _possibleConstructorReturn(this, _getPrototypeOf(J).call(this)), _this10.setShaderName("Effect"),
                _this10._color = new a(1, 1, 1, 1), _this10._shaderValues.setVector(J.TINTCOLOR, new a(1, 1, 1, 1)),
                _this10.renderMode = J.RENDERMODE_ADDTIVE;
            return _this10;
        }
        _createClass(J, [{
            key: "clone",
            value: function clone() {
                var e = new J();
                return this.cloneTo(e), e;
            }
        }, {
            key: "_TintColorR",
            get: function get() {
                return this._color.x;
            },
            set: function set(e) {
                this._color.x = e, this.color = this._color;
            }
        }, {
            key: "_TintColorG",
            get: function get() {
                return this._color.y;
            },
            set: function set(e) {
                this._color.y = e, this.color = this._color;
            }
        }, {
            key: "_TintColorB",
            get: function get() {
                return this._color.z;
            },
            set: function set(e) {
                this._color.z = e, this.color = this._color;
            }
        }, {
            key: "_TintColorA",
            get: function get() {
                return this._color.w;
            },
            set: function set(e) {
                this._color.w = e, this.color = this._color;
            }
        }, {
            key: "_MainTex_STX",
            get: function get() {
                return this._shaderValues.getVector(J.TILINGOFFSET).x;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(J.TILINGOFFSET);
                t.x = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function get() {
                return this._shaderValues.getVector(J.TILINGOFFSET).y;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(J.TILINGOFFSET);
                t.y = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function get() {
                return this._shaderValues.getVector(J.TILINGOFFSET).z;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(J.TILINGOFFSET);
                t.z = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function get() {
                return this._shaderValues.getVector(J.TILINGOFFSET).w;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(J.TILINGOFFSET);
                t.w = e, this.tilingOffset = t;
            }
        }, {
            key: "renderMode",
            set: function set(e) {
                switch (e) {
                    case J.RENDERMODE_ADDTIVE:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                            this.cull = Q.CULL_NONE, this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                            this.blendDst = Q.BLENDPARAM_ONE, this.depthTest = Q.DEPTHTEST_LESS, this._shaderValues.addDefine(J.SHADERDEFINE_ADDTIVEFOG);
                        break;

                    case J.RENDERMODE_ALPHABLENDED:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                            this.cull = Q.CULL_NONE, this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                            this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Q.DEPTHTEST_LESS,
                            this._shaderValues.removeDefine(J.SHADERDEFINE_ADDTIVEFOG);
                        break;

                    default:
                        throw new Error("MeshEffectMaterial : renderMode value error.");
                }
            }
        }, {
            key: "colorR",
            get: function get() {
                return this._TintColorR;
            },
            set: function set(e) {
                this._TintColorR = e;
            }
        }, {
            key: "colorG",
            get: function get() {
                return this._TintColorG;
            },
            set: function set(e) {
                this._TintColorG = e;
            }
        }, {
            key: "colorB",
            get: function get() {
                return this._TintColorB;
            },
            set: function set(e) {
                this._TintColorB = e;
            }
        }, {
            key: "colorA",
            get: function get() {
                return this._TintColorA;
            },
            set: function set(e) {
                this._TintColorA = e;
            }
        }, {
            key: "color",
            get: function get() {
                return this._shaderValues.getVector(J.TINTCOLOR);
            },
            set: function set(e) {
                this._shaderValues.setVector(J.TINTCOLOR, e);
            }
        }, {
            key: "texture",
            get: function get() {
                return this._shaderValues.getTexture(J.MAINTEXTURE);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(J.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(J.SHADERDEFINE_MAINTEXTURE),
                    this._shaderValues.setTexture(J.MAINTEXTURE, e);
            }
        }, {
            key: "tilingOffsetX",
            get: function get() {
                return this._MainTex_STX;
            },
            set: function set(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function get() {
                return this._MainTex_STY;
            },
            set: function set(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function get() {
                return this._MainTex_STZ;
            },
            set: function set(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function get() {
                return this._MainTex_STW;
            },
            set: function set(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function get() {
                return this._shaderValues.getVector(J.TILINGOFFSET);
            },
            set: function set(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(J.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(J.SHADERDEFINE_TILINGOFFSET),
                    this._shaderValues.setVector(J.TILINGOFFSET, e);
            }
        }, {
            key: "depthWrite",
            get: function get() {
                return this._shaderValues.getBool(J.DEPTH_WRITE);
            },
            set: function set(e) {
                this._shaderValues.setBool(J.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function get() {
                return this._shaderValues.getInt(J.CULL);
            },
            set: function set(e) {
                this._shaderValues.setInt(J.CULL, e);
            }
        }, {
            key: "blend",
            get: function get() {
                return this._shaderValues.getInt(J.BLEND);
            },
            set: function set(e) {
                this._shaderValues.setInt(J.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function get() {
                return this._shaderValues.getInt(J.BLEND_SRC);
            },
            set: function set(e) {
                this._shaderValues.setInt(J.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function get() {
                return this._shaderValues.getInt(J.BLEND_DST);
            },
            set: function set(e) {
                this._shaderValues.setInt(J.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function get() {
                return this._shaderValues.getInt(J.DEPTH_TEST);
            },
            set: function set(e) {
                this._shaderValues.setInt(J.DEPTH_TEST, e);
            }
        }], [{
            key: "__initDefine__",
            value: function __initDefine__() {
                J.SHADERDEFINE_MAINTEXTURE = H.getDefineByName("MAINTEXTURE"), J.SHADERDEFINE_TILINGOFFSET = H.getDefineByName("TILINGOFFSET"),
                    J.SHADERDEFINE_ADDTIVEFOG = H.getDefineByName("ADDTIVEFOG");
            }
        }]);
        return J;
    }(j);
    J.RENDERMODE_ADDTIVE = 0, J.RENDERMODE_ALPHABLENDED = 1, J.MAINTEXTURE = H.propertyNameToID("u_AlbedoTexture"),
        J.TINTCOLOR = H.propertyNameToID("u_AlbedoColor"), J.TILINGOFFSET = H.propertyNameToID("u_TilingOffset"),
        J.CULL = H.propertyNameToID("s_Cull"), J.BLEND = H.propertyNameToID("s_Blend"),
        J.BLEND_SRC = H.propertyNameToID("s_BlendSrc"), J.BLEND_DST = H.propertyNameToID("s_BlendDst"),
        J.DEPTH_TEST = H.propertyNameToID("s_DepthTest"), J.DEPTH_WRITE = H.propertyNameToID("s_DepthWrite");
    var $ = /* */ function(_j3) {
        _inherits($, _j3);

        function $() {
            var _this11;
            _classCallCheck(this, $);
            _this11 = _possibleConstructorReturn(this, _getPrototypeOf($).call(this)), _this11._enableLighting = !0,
                _this11.setShaderName("ExtendTerrain"), _this11.renderMode = $.RENDERMODE_OPAQUE;
            return _this11;
        }
        _createClass($, [{
            key: "_setDetailNum",
            value: function _setDetailNum(e) {
                switch (e) {
                    case 1:
                        this._shaderValues.addDefine($.SHADERDEFINE_DETAIL_NUM1), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM2),
                            this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM4),
                            this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM5);
                        break;

                    case 2:
                        this._shaderValues.addDefine($.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM1),
                            this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM4),
                            this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM5);
                        break;

                    case 3:
                        this._shaderValues.addDefine($.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM1),
                            this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM4),
                            this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM5);
                        break;

                    case 4:
                        this._shaderValues.addDefine($.SHADERDEFINE_DETAIL_NUM4), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM1),
                            this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM3),
                            this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM5);
                        break;

                    case 5:
                        this._shaderValues.addDefine($.SHADERDEFINE_DETAIL_NUM5), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM1),
                            this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM3),
                            this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM4);
                }
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new $();
                return this.cloneTo(e), e;
            }
        }, {
            key: "splatAlphaTexture",
            get: function get() {
                return this._shaderValues.getTexture($.SPLATALPHATEXTURE);
            },
            set: function set(e) {
                this._shaderValues.setTexture($.SPLATALPHATEXTURE, e);
            }
        }, {
            key: "diffuseTexture1",
            get: function get() {
                return this._shaderValues.getTexture($.DIFFUSETEXTURE1);
            },
            set: function set(e) {
                this._shaderValues.setTexture($.DIFFUSETEXTURE1, e), this._setDetailNum(1);
            }
        }, {
            key: "diffuseTexture2",
            get: function get() {
                return this._shaderValues.getTexture($.DIFFUSETEXTURE2);
            },
            set: function set(e) {
                this._shaderValues.setTexture($.DIFFUSETEXTURE2, e), this._setDetailNum(2);
            }
        }, {
            key: "diffuseTexture3",
            get: function get() {
                return this._shaderValues.getTexture($.DIFFUSETEXTURE3);
            },
            set: function set(e) {
                this._shaderValues.setTexture($.DIFFUSETEXTURE3, e), this._setDetailNum(3);
            }
        }, {
            key: "diffuseTexture4",
            get: function get() {
                return this._shaderValues.getTexture($.DIFFUSETEXTURE4);
            },
            set: function set(e) {
                this._shaderValues.setTexture($.DIFFUSETEXTURE4, e), this._setDetailNum(4);
            }
        }, {
            key: "diffuseTexture5",
            get: function get() {
                return this._shaderValues.getTexture($.DIFFUSETEXTURE5);
            },
            set: function set(e) {
                this._shaderValues.setTexture($.DIFFUSETEXTURE5, e), this._setDetailNum(5);
            }
        }, {
            key: "diffuseScaleOffset1",
            set: function set(e) {
                this._shaderValues.setVector($.DIFFUSESCALEOFFSET1, e);
            }
        }, {
            key: "diffuseScaleOffset2",
            set: function set(e) {
                this._shaderValues.setVector($.DIFFUSESCALEOFFSET2, e);
            }
        }, {
            key: "diffuseScaleOffset3",
            set: function set(e) {
                this._shaderValues.setVector($.DIFFUSESCALEOFFSET3, e);
            }
        }, {
            key: "diffuseScaleOffset4",
            set: function set(e) {
                this._shaderValues.setVector($.DIFFUSESCALEOFFSET4, e);
            }
        }, {
            key: "diffuseScaleOffset5",
            set: function set(e) {
                this._shaderValues.setVector($.DIFFUSESCALEOFFSET5, e);
            }
        }, {
            key: "renderMode",
            set: function set(e) {
                switch (e) {
                    case $.RENDERMODE_OPAQUE:
                        this.renderQueue = j.RENDERQUEUE_OPAQUE, this.depthWrite = !0, this.cull = Q.CULL_BACK,
                            this.blend = Q.BLEND_DISABLE, this.depthTest = Q.DEPTHTEST_LESS;
                        break;

                    case $.RENDERMODE_TRANSPARENT:
                        this.renderQueue = j.RENDERQUEUE_OPAQUE, this.depthWrite = !1, this.cull = Q.CULL_BACK,
                            this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA, this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA,
                            this.depthTest = Q.DEPTHTEST_LEQUAL;
                        break;

                    default:
                        throw new Error("ExtendTerrainMaterial:renderMode value error.");
                }
            }
        }, {
            key: "depthWrite",
            get: function get() {
                return this._shaderValues.getBool($.DEPTH_WRITE);
            },
            set: function set(e) {
                this._shaderValues.setBool($.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function get() {
                return this._shaderValues.getInt($.CULL);
            },
            set: function set(e) {
                this._shaderValues.setInt($.CULL, e);
            }
        }, {
            key: "blend",
            get: function get() {
                return this._shaderValues.getInt($.BLEND);
            },
            set: function set(e) {
                this._shaderValues.setInt($.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function get() {
                return this._shaderValues.getInt($.BLEND_SRC);
            },
            set: function set(e) {
                this._shaderValues.setInt($.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function get() {
                return this._shaderValues.getInt($.BLEND_DST);
            },
            set: function set(e) {
                this._shaderValues.setInt($.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function get() {
                return this._shaderValues.getInt($.DEPTH_TEST);
            },
            set: function set(e) {
                this._shaderValues.setInt($.DEPTH_TEST, e);
            }
        }], [{
            key: "__initDefine__",
            value: function __initDefine__() {
                $.SHADERDEFINE_DETAIL_NUM1 = H.getDefineByName("ExtendTerrain_DETAIL_NUM1"), $.SHADERDEFINE_DETAIL_NUM2 = H.getDefineByName("ExtendTerrain_DETAIL_NUM2"),
                    $.SHADERDEFINE_DETAIL_NUM3 = H.getDefineByName("ExtendTerrain_DETAIL_NUM3"), $.SHADERDEFINE_DETAIL_NUM4 = H.getDefineByName("ExtendTerrain_DETAIL_NUM4"),
                    $.SHADERDEFINE_DETAIL_NUM5 = H.getDefineByName("ExtendTerrain_DETAIL_NUM5");
            }
        }]);
        return $;
    }(j);
    $.RENDERMODE_OPAQUE = 1, $.RENDERMODE_TRANSPARENT = 2, $.SPLATALPHATEXTURE = H.propertyNameToID("u_SplatAlphaTexture"),
        $.DIFFUSETEXTURE1 = H.propertyNameToID("u_DiffuseTexture1"), $.DIFFUSETEXTURE2 = H.propertyNameToID("u_DiffuseTexture2"),
        $.DIFFUSETEXTURE3 = H.propertyNameToID("u_DiffuseTexture3"), $.DIFFUSETEXTURE4 = H.propertyNameToID("u_DiffuseTexture4"),
        $.DIFFUSETEXTURE5 = H.propertyNameToID("u_DiffuseTexture5"), $.DIFFUSESCALEOFFSET1 = H.propertyNameToID("u_DiffuseScaleOffset1"),
        $.DIFFUSESCALEOFFSET2 = H.propertyNameToID("u_DiffuseScaleOffset2"), $.DIFFUSESCALEOFFSET3 = H.propertyNameToID("u_DiffuseScaleOffset3"),
        $.DIFFUSESCALEOFFSET4 = H.propertyNameToID("u_DiffuseScaleOffset4"), $.DIFFUSESCALEOFFSET5 = H.propertyNameToID("u_DiffuseScaleOffset5"),
        $.CULL = H.propertyNameToID("s_Cull"), $.BLEND = H.propertyNameToID("s_Blend"),
        $.BLEND_SRC = H.propertyNameToID("s_BlendSrc"), $.BLEND_DST = H.propertyNameToID("s_BlendDst"),
        $.DEPTH_TEST = H.propertyNameToID("s_DepthTest"), $.DEPTH_WRITE = H.propertyNameToID("s_DepthWrite"),
        (o = e.PBRRenderMode || (e.PBRRenderMode = {}))[o.Opaque = 0] = "Opaque", o[o.Cutout = 1] = "Cutout",
        o[o.Fade = 2] = "Fade", o[o.Transparent = 3] = "Transparent";
    var ee = /* */ function(_j4) {
        _inherits(ee, _j4);

        function ee() {
            var _this12;
            _classCallCheck(this, ee);
            _this12 = _possibleConstructorReturn(this, _getPrototypeOf(ee).call(this)), _this12._enableEmission = !1,
                _this12._shaderValues.setVector(ee.ALBEDOCOLOR, new a(1, 1, 1, 1)), _this12._shaderValues.setVector(ee.EMISSIONCOLOR, new a(1, 1, 1, 1)),
                _this12._shaderValues.setNumber(ee.SMOOTHNESS, .5), _this12._shaderValues.setNumber(ee.SMOOTHNESSSCALE, 1),
                _this12._shaderValues.setNumber(ee.OCCLUSIONSTRENGTH, 1), _this12._shaderValues.setNumber(ee.NORMALSCALE, 1),
                _this12._shaderValues.setNumber(ee.PARALLAXSCALE, .001), _this12._shaderValues.setNumber(j.ALPHATESTVALUE, .5),
                _this12.renderMode = e.PBRRenderMode.Opaque;
            return _this12;
        }
        _createClass(ee, [{
            key: "albedoColor",
            get: function get() {
                return this._shaderValues.getVector(ee.ALBEDOCOLOR);
            },
            set: function set(e) {
                this._shaderValues.setVector(ee.ALBEDOCOLOR, e);
            }
        }, {
            key: "albedoTexture",
            get: function get() {
                return this._shaderValues.getTexture(ee.ALBEDOTEXTURE);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(ee.SHADERDEFINE_ALBEDOTEXTURE) : this._shaderValues.removeDefine(ee.SHADERDEFINE_ALBEDOTEXTURE),
                    this._shaderValues.setTexture(ee.ALBEDOTEXTURE, e);
            }
        }, {
            key: "normalTexture",
            get: function get() {
                return this._shaderValues.getTexture(ee.NORMALTEXTURE);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(ee.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(ee.SHADERDEFINE_NORMALTEXTURE),
                    this._shaderValues.setTexture(ee.NORMALTEXTURE, e);
            }
        }, {
            key: "normalTextureScale",
            get: function get() {
                return this._shaderValues.getNumber(ee.NORMALSCALE);
            },
            set: function set(e) {
                this._shaderValues.setNumber(ee.NORMALSCALE, e);
            }
        }, {
            key: "parallaxTexture",
            get: function get() {
                return this._shaderValues.getTexture(ee.PARALLAXTEXTURE);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(ee.SHADERDEFINE_PARALLAXTEXTURE) : this._shaderValues.removeDefine(ee.SHADERDEFINE_PARALLAXTEXTURE),
                    this._shaderValues.setTexture(ee.PARALLAXTEXTURE, e);
            }
        }, {
            key: "parallaxTextureScale",
            get: function get() {
                return this._shaderValues.getNumber(ee.PARALLAXSCALE);
            },
            set: function set(e) {
                this._shaderValues.setNumber(ee.PARALLAXSCALE, Math.max(.005, Math.min(.08, e)));
            }
        }, {
            key: "occlusionTexture",
            get: function get() {
                return this._shaderValues.getTexture(ee.OCCLUSIONTEXTURE);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(ee.SHADERDEFINE_OCCLUSIONTEXTURE) : this._shaderValues.removeDefine(ee.SHADERDEFINE_OCCLUSIONTEXTURE),
                    this._shaderValues.setTexture(ee.OCCLUSIONTEXTURE, e);
            }
        }, {
            key: "occlusionTextureStrength",
            get: function get() {
                return this._shaderValues.getNumber(ee.OCCLUSIONSTRENGTH);
            },
            set: function set(e) {
                this._shaderValues.setNumber(ee.OCCLUSIONSTRENGTH, Math.max(0, Math.min(1, e)));
            }
        }, {
            key: "smoothness",
            get: function get() {
                return this._shaderValues.getNumber(ee.SMOOTHNESS);
            },
            set: function set(e) {
                this._shaderValues.setNumber(ee.SMOOTHNESS, Math.max(0, Math.min(1, e)));
            }
        }, {
            key: "smoothnessTextureScale",
            get: function get() {
                return this._shaderValues.getNumber(ee.SMOOTHNESSSCALE);
            },
            set: function set(e) {
                this._shaderValues.setNumber(ee.SMOOTHNESSSCALE, Math.max(0, Math.min(1, e)));
            }
        }, {
            key: "enableEmission",
            get: function get() {
                return this._enableEmission;
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(ee.SHADERDEFINE_EMISSION) : this._shaderValues.removeDefine(ee.SHADERDEFINE_EMISSION),
                    this._enableEmission = e;
            }
        }, {
            key: "emissionColor",
            get: function get() {
                return this._shaderValues.getVector(ee.EMISSIONCOLOR);
            },
            set: function set(e) {
                this._shaderValues.setVector(ee.EMISSIONCOLOR, e);
            }
        }, {
            key: "emissionTexture",
            get: function get() {
                return this._shaderValues.getTexture(ee.EMISSIONTEXTURE);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(ee.SHADERDEFINE_EMISSIONTEXTURE) : this._shaderValues.removeDefine(ee.SHADERDEFINE_EMISSIONTEXTURE),
                    this._shaderValues.setTexture(ee.EMISSIONTEXTURE, e);
            }
        }, {
            key: "tilingOffset",
            get: function get() {
                return this._shaderValues.getVector(ee.TILINGOFFSET);
            },
            set: function set(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(ee.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(ee.SHADERDEFINE_TILINGOFFSET),
                    this._shaderValues.setVector(ee.TILINGOFFSET, e);
            }
        }, {
            key: "depthWrite",
            get: function get() {
                return this._shaderValues.getBool(ee.DEPTH_WRITE);
            },
            set: function set(e) {
                this._shaderValues.setBool(ee.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function get() {
                return this._shaderValues.getInt(ee.CULL);
            },
            set: function set(e) {
                this._shaderValues.setInt(ee.CULL, e);
            }
        }, {
            key: "blend",
            get: function get() {
                return this._shaderValues.getInt(ee.BLEND);
            },
            set: function set(e) {
                this._shaderValues.setInt(ee.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function get() {
                return this._shaderValues.getInt(ee.BLEND_SRC);
            },
            set: function set(e) {
                this._shaderValues.setInt(ee.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function get() {
                return this._shaderValues.getInt(ee.BLEND_DST);
            },
            set: function set(e) {
                this._shaderValues.setInt(ee.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function get() {
                return this._shaderValues.getInt(ee.DEPTH_TEST);
            },
            set: function set(e) {
                this._shaderValues.setInt(ee.DEPTH_TEST, e);
            }
        }, {
            key: "renderMode",
            set: function set(t) {
                switch (t) {
                    case e.PBRRenderMode.Opaque:
                        this.alphaTest = !1, this.renderQueue = j.RENDERQUEUE_OPAQUE, this.depthWrite = !0,
                            this.cull = Q.CULL_BACK, this.blend = Q.BLEND_DISABLE, this.depthTest = Q.DEPTHTEST_LESS,
                            this._shaderValues.removeDefine(ee.SHADERDEFINE_TRANSPARENTBLEND);
                        break;

                    case e.PBRRenderMode.Cutout:
                        this.renderQueue = j.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0,
                            this.cull = Q.CULL_BACK, this.blend = Q.BLEND_DISABLE, this.depthTest = Q.DEPTHTEST_LESS,
                            this._shaderValues.removeDefine(ee.SHADERDEFINE_TRANSPARENTBLEND);
                        break;

                    case e.PBRRenderMode.Fade:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                            this.cull = Q.CULL_BACK, this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                            this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Q.DEPTHTEST_LESS,
                            this._shaderValues.removeDefine(ee.SHADERDEFINE_TRANSPARENTBLEND);
                        break;

                    case e.PBRRenderMode.Transparent:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                            this.cull = Q.CULL_BACK, this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_ONE,
                            this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Q.DEPTHTEST_LESS,
                            this._shaderValues.addDefine(ee.SHADERDEFINE_TRANSPARENTBLEND);
                        break;

                    default:
                        throw new Error("PBRMaterial:unknown renderMode value.");
                }
            }
        }, {
            key: "enableReflection",
            get: function get() {
                return !0;
            },
            set: function set(e) {}
        }], [{
            key: "__init__",
            value: function __init__() {
                ee.SHADERDEFINE_ALBEDOTEXTURE = H.getDefineByName("ALBEDOTEXTURE"), ee.SHADERDEFINE_NORMALTEXTURE = H.getDefineByName("NORMALTEXTURE"),
                    ee.SHADERDEFINE_PARALLAXTEXTURE = H.getDefineByName("PARALLAXTEXTURE"), ee.SHADERDEFINE_OCCLUSIONTEXTURE = H.getDefineByName("OCCLUSIONTEXTURE"),
                    ee.SHADERDEFINE_EMISSION = H.getDefineByName("EMISSION"), ee.SHADERDEFINE_EMISSIONTEXTURE = H.getDefineByName("EMISSIONTEXTURE"),
                    ee.SHADERDEFINE_TILINGOFFSET = H.getDefineByName("TILINGOFFSET"), ee.SHADERDEFINE_TRANSPARENTBLEND = H.getDefineByName("TRANSPARENTBLEND"),
                    ee.SHADERDEFINE_LAYA_PBR_BRDF_HIGH = H.getDefineByName("LAYA_PBR_BRDF_HIGH"), ee.SHADERDEFINE_LAYA_PBR_BRDF_LOW = H.getDefineByName("LAYA_PBR_BRDF_LOW");
            }
        }]);
        return ee;
    }(j);
    ee.ALBEDOTEXTURE = H.propertyNameToID("u_AlbedoTexture"), ee.ALBEDOCOLOR = H.propertyNameToID("u_AlbedoColor"),
        ee.TILINGOFFSET = H.propertyNameToID("u_TilingOffset"), ee.NORMALTEXTURE = H.propertyNameToID("u_NormalTexture"),
        ee.NORMALSCALE = H.propertyNameToID("u_NormalScale"), ee.SMOOTHNESS = H.propertyNameToID("u_Smoothness"),
        ee.SMOOTHNESSSCALE = H.propertyNameToID("u_SmoothnessScale"), ee.OCCLUSIONTEXTURE = H.propertyNameToID("u_OcclusionTexture"),
        ee.OCCLUSIONSTRENGTH = H.propertyNameToID("u_occlusionStrength"), ee.PARALLAXTEXTURE = H.propertyNameToID("u_ParallaxTexture"),
        ee.PARALLAXSCALE = H.propertyNameToID("u_ParallaxScale"), ee.EMISSIONTEXTURE = H.propertyNameToID("u_EmissionTexture"),
        ee.EMISSIONCOLOR = H.propertyNameToID("u_EmissionColor"), ee.CULL = H.propertyNameToID("s_Cull"),
        ee.BLEND = H.propertyNameToID("s_Blend"), ee.BLEND_SRC = H.propertyNameToID("s_BlendSrc"),
        ee.BLEND_DST = H.propertyNameToID("s_BlendDst"), ee.DEPTH_TEST = H.propertyNameToID("s_DepthTest"),
        ee.DEPTH_WRITE = H.propertyNameToID("s_DepthWrite"), ee.renderQuality = e.PBRRenderQuality.High;
    var te, re = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#define SETUP_BRDF_INPUT specularSetup\r\n\r\n#include "Lighting.glsl";\r\n#include "PBRFSInput.glsl";\r\n#include "LayaPBRBRDF.glsl";\r\n#include "GlobalIllumination.glsl";\r\n#include "ShadowHelper.glsl"\r\n#include "PBRCore.glsl";\r\n#include "PBRFSShadow.glsl";\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\t\t\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tfragmentForward();\r\n\t#endif  \r\n}',
        ie = '#include "PBRVSInput.glsl";\r\n#include "Lighting.glsl";\r\n#include "PBRVertex.glsl";\r\n#include "PBRVSShadow.glsl";\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tvertexForward();\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}';
    var ae = function ae() {
        _classCallCheck(this, ae);
        this.textureID = -1;
    };
    var ne = /* */ function(_t$Resource4) {
        _inherits(ne, _t$Resource4);

        function ne(e, t, r, i, a) {
            var _this13;
            _classCallCheck(this, ne);
            _this13 = _possibleConstructorReturn(this, _getPrototypeOf(ne).call(this)), _this13._stateParamsMap = [],
                _this13._uploadMark = -1, _this13._uploadRenderType = -1, _this13._vs = e, _this13._ps = t,
                _this13._attributeMap = r, _this13._uniformMap = i, _this13._shaderPass = a, _this13._create(),
                _this13.lock = !0;
            return _this13;
        }
        _createClass(ne, [{
            key: "_create",
            value: function _create() {
                var e = t.LayaGL.instance;
                for (var r in this._program = e.createProgram(), this._vshader = this._createShader(e, this._vs, e.VERTEX_SHADER),
                        this._pshader = this._createShader(e, this._ps, e.FRAGMENT_SHADER), e.attachShader(this._program, this._vshader),
                        e.attachShader(this._program, this._pshader), this._attributeMap) {
                    e.bindAttribLocation(this._program, this._attributeMap[r], r);
                }
                if (e.linkProgram(this._program), !t.Render.isConchApp && H.debugMode && !e.getProgramParameter(this._program, e.LINK_STATUS)) throw e.getProgramInfoLog(this._program);
                var i = [],
                    a = [],
                    n = [],
                    s = [],
                    o = [];
                this._customUniformParamsMap = [];
                var l, _, h, c = e.getProgramParameter(this._program, e.ACTIVE_UNIFORMS);
                for (t.WebGLContext.useProgram(e, this._program), this._curActTexIndex = 0, _ = 0; _ < c; _++) {
                    var d = e.getActiveUniform(this._program, _),
                        u = d.name;
                    (l = new ae()).location = e.getUniformLocation(this._program, u), u.indexOf("[0]") > 0 ? (l.name = u = u.substr(0, u.length - 3),
                        l.isArray = !0) : (l.name = u, l.isArray = !1), l.type = d.type, this._addShaderUnifiormFun(l);
                    var m = this._uniformMap[u];
                    if (null != m) switch (l.dataOffset = H.propertyNameToID(u), m) {
                        case H.PERIOD_CUSTOM:
                            o.push(l);
                            break;

                        case H.PERIOD_MATERIAL:
                            s.push(l);
                            break;

                        case H.PERIOD_SPRITE:
                            n.push(l);
                            break;

                        case H.PERIOD_CAMERA:
                            a.push(l);
                            break;

                        case H.PERIOD_SCENE:
                            i.push(l);
                            break;

                        default:
                            throw new Error("Shader3D: period is unkonw.");
                    }
                }
                for (this._sceneUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * i.length * 5 + 4, 64, !0),
                    _ = 0, h = i.length; _ < h; _++) {
                    this._sceneUniformParamsMap.addShaderUniform(i[_]);
                }
                for (this._cameraUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * a.length * 5 + 4, 64, !0),
                    _ = 0, h = a.length; _ < h; _++) {
                    this._cameraUniformParamsMap.addShaderUniform(a[_]);
                }
                for (this._spriteUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * n.length * 5 + 4, 64, !0),
                    _ = 0, h = n.length; _ < h; _++) {
                    this._spriteUniformParamsMap.addShaderUniform(n[_]);
                }
                for (this._materialUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * s.length * 5 + 4, 64, !0),
                    _ = 0, h = s.length; _ < h; _++) {
                    this._materialUniformParamsMap.addShaderUniform(s[_]);
                }
                for (this._customUniformParamsMap.length = o.length, _ = 0, h = o.length; _ < h; _++) {
                    var f = o[_];
                    this._customUniformParamsMap[f.dataOffset] = f;
                }
                var E = this._shaderPass._stateMap;
                for (var T in E) {
                    this._stateParamsMap[E[T]] = H.propertyNameToID(T);
                }
            }
        }, {
            key: "_getRenderState",
            value: function _getRenderState(e, t) {
                var r = this._stateParamsMap[t];
                return null == r ? null : e[r];
            }
        }, {
            key: "_disposeResource",
            value: function _disposeResource() {
                t.LayaGL.instance.deleteShader(this._vshader), t.LayaGL.instance.deleteShader(this._pshader),
                    t.LayaGL.instance.deleteProgram(this._program), this._vshader = this._pshader = this._program = null,
                    this._setGPUMemory(0), this._curActTexIndex = 0;
            }
        }, {
            key: "_addShaderUnifiormFun",
            value: function _addShaderUnifiormFun(e) {
                var r = t.LayaGL.instance;
                e.caller = this;
                var i = e.isArray;
                switch (e.type) {
                    case r.BOOL:
                        e.fun = this._uniform1i, e.uploadedValue = new Array(1);
                        break;

                    case r.INT:
                        e.fun = i ? this._uniform1iv : this._uniform1i, e.uploadedValue = new Array(1);
                        break;

                    case r.FLOAT:
                        e.fun = i ? this._uniform1fv : this._uniform1f, e.uploadedValue = new Array(1);
                        break;

                    case r.FLOAT_VEC2:
                        e.fun = i ? this._uniform_vec2v : this._uniform_vec2, e.uploadedValue = new Array(2);
                        break;

                    case r.FLOAT_VEC3:
                        e.fun = i ? this._uniform_vec3v : this._uniform_vec3, e.uploadedValue = new Array(3);
                        break;

                    case r.FLOAT_VEC4:
                        e.fun = i ? this._uniform_vec4v : this._uniform_vec4, e.uploadedValue = new Array(4);
                        break;

                    case r.FLOAT_MAT2:
                        e.fun = this._uniformMatrix2fv;
                        break;

                    case r.FLOAT_MAT3:
                        e.fun = this._uniformMatrix3fv;
                        break;

                    case r.FLOAT_MAT4:
                        e.fun = i ? this._uniformMatrix4fv : this._uniformMatrix4f;
                        break;

                    case r.SAMPLER_2D:
                        r.uniform1i(e.location, this._curActTexIndex), e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++],
                            e.fun = this._uniform_sampler2D;
                        break;

                    case 35679:
                        r.uniform1i(e.location, this._curActTexIndex), e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++],
                            e.fun = this._uniform_sampler3D;
                        break;

                    case r.SAMPLER_CUBE:
                        r.uniform1i(e.location, this._curActTexIndex), e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++],
                            e.fun = this._uniform_samplerCube;
                        break;

                    default:
                        throw new Error("compile shader err!");
                }
            }
        }, {
            key: "_createShader",
            value: function _createShader(e, t, r) {
                var i = e.createShader(r);
                if (e.shaderSource(i, t), e.compileShader(i), H.debugMode && !e.getShaderParameter(i, e.COMPILE_STATUS)) throw e.getShaderInfoLog(i);
                return i;
            }
        }, {
            key: "_uniform1f",
            value: function _uniform1f(e, r) {
                var i = e.uploadedValue;
                return i[0] !== r ? (t.LayaGL.instance.uniform1f(e.location, i[0] = r), 1) : 0;
            }
        }, {
            key: "_uniform1fv",
            value: function _uniform1fv(e, r) {
                if (r.length < 4) {
                    var i = e.uploadedValue;
                    return i[0] !== r[0] || i[1] !== r[1] || i[2] !== r[2] || i[3] !== r[3] ? (t.LayaGL.instance.uniform1fv(e.location, r),
                        i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3], 1) : 0;
                }
                return t.LayaGL.instance.uniform1fv(e.location, r), 1;
            }
        }, {
            key: "_uniform_vec2",
            value: function _uniform_vec2(e, r) {
                var i = e.uploadedValue;
                return i[0] !== r.x || i[1] !== r.y ? (t.LayaGL.instance.uniform2f(e.location, i[0] = r.x, i[1] = r.y),
                    1) : 0;
            }
        }, {
            key: "_uniform_vec2v",
            value: function _uniform_vec2v(e, r) {
                if (r.length < 2) {
                    var i = e.uploadedValue;
                    return i[0] !== r[0] || i[1] !== r[1] || i[2] !== r[2] || i[3] !== r[3] ? (t.LayaGL.instance.uniform2fv(e.location, r),
                        i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3], 1) : 0;
                }
                return t.LayaGL.instance.uniform2fv(e.location, r), 1;
            }
        }, {
            key: "_uniform_vec3",
            value: function _uniform_vec3(e, r) {
                var i = e.uploadedValue;
                return i[0] !== r.x || i[1] !== r.y || i[2] !== r.z ? (t.LayaGL.instance.uniform3f(e.location, i[0] = r.x, i[1] = r.y, i[2] = r.z),
                    1) : 0;
            }
        }, {
            key: "_uniform_vec3v",
            value: function _uniform_vec3v(e, r) {
                return t.LayaGL.instance.uniform3fv(e.location, r), 1;
            }
        }, {
            key: "_uniform_vec4",
            value: function _uniform_vec4(e, r) {
                var i = e.uploadedValue;
                return i[0] !== r.x || i[1] !== r.y || i[2] !== r.z || i[3] !== r.w ? (t.LayaGL.instance.uniform4f(e.location, i[0] = r.x, i[1] = r.y, i[2] = r.z, i[3] = r.w),
                    1) : 0;
            }
        }, {
            key: "_uniform_vec4v",
            value: function _uniform_vec4v(e, r) {
                return t.LayaGL.instance.uniform4fv(e.location, r), 1;
            }
        }, {
            key: "_uniformMatrix2fv",
            value: function _uniformMatrix2fv(e, r) {
                return t.LayaGL.instance.uniformMatrix2fv(e.location, !1, r), 1;
            }
        }, {
            key: "_uniformMatrix3fv",
            value: function _uniformMatrix3fv(e, r) {
                return t.LayaGL.instance.uniformMatrix3fv(e.location, !1, r), 1;
            }
        }, {
            key: "_uniformMatrix4f",
            value: function _uniformMatrix4f(e, r) {
                var i = r.elements;
                return t.LayaGL.instance.uniformMatrix4fv(e.location, !1, i), 1;
            }
        }, {
            key: "_uniformMatrix4fv",
            value: function _uniformMatrix4fv(e, r) {
                return t.LayaGL.instance.uniformMatrix4fv(e.location, !1, r), 1;
            }
        }, {
            key: "_uniform1i",
            value: function _uniform1i(e, r) {
                var i = e.uploadedValue;
                return i[0] !== r ? (t.LayaGL.instance.uniform1i(e.location, i[0] = r), 1) : 0;
            }
        }, {
            key: "_uniform1iv",
            value: function _uniform1iv(e, r) {
                return t.LayaGL.instance.uniform1iv(e.location, r), 1;
            }
        }, {
            key: "_uniform_ivec2",
            value: function _uniform_ivec2(e, r) {
                var i = e.uploadedValue;
                return i[0] !== r[0] || i[1] !== r[1] ? (t.LayaGL.instance.uniform2i(e.location, i[0] = r[0], i[1] = r[1]),
                    1) : 0;
            }
        }, {
            key: "_uniform_ivec2v",
            value: function _uniform_ivec2v(e, r) {
                return t.LayaGL.instance.uniform2iv(e.location, r), 1;
            }
        }, {
            key: "_uniform_vec3i",
            value: function _uniform_vec3i(e, r) {
                var i = e.uploadedValue;
                return i[0] !== r[0] || i[1] !== r[1] || i[2] !== r[2] ? (t.LayaGL.instance.uniform3i(e.location, i[0] = r[0], i[1] = r[1], i[2] = r[2]),
                    1) : 0;
            }
        }, {
            key: "_uniform_vec3vi",
            value: function _uniform_vec3vi(e, r) {
                return t.LayaGL.instance.uniform3iv(e.location, r), 1;
            }
        }, {
            key: "_uniform_vec4i",
            value: function _uniform_vec4i(e, r) {
                var i = e.uploadedValue;
                return i[0] !== r[0] || i[1] !== r[1] || i[2] !== r[2] || i[3] !== r[3] ? (t.LayaGL.instance.uniform4i(e.location, i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3]),
                    1) : 0;
            }
        }, {
            key: "_uniform_vec4vi",
            value: function _uniform_vec4vi(e, r) {
                return t.LayaGL.instance.uniform4iv(e.location, r), 1;
            }
        }, {
            key: "_uniform_sampler2D",
            value: function _uniform_sampler2D(e, r) {
                var i = r._getSource() || r.defaulteTexture._getSource(),
                    a = t.LayaGL.instance;
                return t.WebGLContext.activeTexture(a, e.textureID), t.WebGLContext.bindTexture(a, a.TEXTURE_2D, i),
                    0;
            }
        }, {
            key: "_uniform_sampler3D",
            value: function _uniform_sampler3D(e, r) {
                var i = r._getSource() || r.defaulteTexture._getSource(),
                    a = t.LayaGL.instance;
                return t.WebGLContext.activeTexture(a, e.textureID), t.WebGLContext.bindTexture(a, WebGL2RenderingContext.TEXTURE_3D, i),
                    0;
            }
        }, {
            key: "_uniform_samplerCube",
            value: function _uniform_samplerCube(e, r) {
                var i = r._getSource() || r.defaulteTexture._getSource(),
                    a = t.LayaGL.instance;
                return t.WebGLContext.activeTexture(a, e.textureID), t.WebGLContext.bindTexture(a, a.TEXTURE_CUBE_MAP, i),
                    0;
            }
        }, {
            key: "bind",
            value: function bind() {
                return t.WebGLContext.useProgram(t.LayaGL.instance, this._program);
            }
        }, {
            key: "uploadUniforms",
            value: function uploadUniforms(e, r, i) {
                t.Stat.shaderCall += t.LayaGLRunner.uploadShaderUniforms(t.LayaGL.instance, e, r, i);
            }
        }, {
            key: "uploadRenderStateBlendDepth",
            value: function uploadRenderStateBlendDepth(e) {
                var r = t.LayaGL.instance,
                    i = this._shaderPass.renderState,
                    a = e.getData(),
                    n = this._getRenderState(a, H.RENDER_STATE_DEPTH_WRITE),
                    s = this._getRenderState(a, H.RENDER_STATE_DEPTH_TEST),
                    o = this._getRenderState(a, H.RENDER_STATE_BLEND);
                switch (null == n && (n = i.depthWrite), null == s && (s = i.depthTest), null == o && (o = i.blend),
                    t.WebGLContext.setDepthMask(r, n), s === Q.DEPTHTEST_OFF ? t.WebGLContext.setDepthTest(r, !1) : (t.WebGLContext.setDepthTest(r, !0),
                        t.WebGLContext.setDepthFunc(r, s)), o) {
                    case Q.BLEND_DISABLE:
                        t.WebGLContext.setBlend(r, !1);
                        break;

                    case Q.BLEND_ENABLE_ALL:
                        var l = this._getRenderState(a, H.RENDER_STATE_BLEND_EQUATION),
                            _ = this._getRenderState(a, H.RENDER_STATE_BLEND_SRC),
                            h = this._getRenderState(a, H.RENDER_STATE_BLEND_DST);
                        null == l && (l = i.blendEquation), null == _ && (_ = i.srcBlend), null == h && (h = i.dstBlend),
                            t.WebGLContext.setBlend(r, !0), t.WebGLContext.setBlendEquation(r, l), t.WebGLContext.setBlendFunc(r, _, h);
                        break;

                    case Q.BLEND_ENABLE_SEPERATE:
                        var c = this._getRenderState(a, H.RENDER_STATE_BLEND_EQUATION_RGB),
                            d = this._getRenderState(a, H.RENDER_STATE_BLEND_EQUATION_ALPHA),
                            u = this._getRenderState(a, H.RENDER_STATE_BLEND_SRC_RGB),
                            m = this._getRenderState(a, H.RENDER_STATE_BLEND_DST_RGB),
                            f = this._getRenderState(a, H.RENDER_STATE_BLEND_SRC_ALPHA),
                            E = this._getRenderState(a, H.RENDER_STATE_BLEND_DST_ALPHA);
                        null == c && (c = i.blendEquationRGB), null == d && (d = i.blendEquationAlpha),
                            null == u && (u = i.srcBlendRGB), null == m && (m = i.dstBlendRGB), null == f && (f = i.srcBlendAlpha),
                            null == E && (E = i.dstBlendAlpha), t.WebGLContext.setBlend(r, !0), t.WebGLContext.setBlendEquationSeparate(r, c, d),
                            t.WebGLContext.setBlendFuncSeperate(r, u, m, f, E);
                }
            }
        }, {
            key: "uploadRenderStateFrontFace",
            value: function uploadRenderStateFrontFace(e, r, i) {
                var a, n = t.LayaGL.instance,
                    s = this._shaderPass.renderState,
                    o = e.getData(),
                    l = this._getRenderState(o, H.RENDER_STATE_CULL);
                switch (null == l && (l = s.cull), l) {
                    case Q.CULL_NONE:
                        t.WebGLContext.setCullFace(n, !1);
                        break;

                    case Q.CULL_FRONT:
                        t.WebGLContext.setCullFace(n, !0), a = r ? i ? n.CCW : n.CW : i ? n.CW : n.CCW,
                            t.WebGLContext.setFrontFace(n, a);
                        break;

                    case Q.CULL_BACK:
                        t.WebGLContext.setCullFace(n, !0), a = r ? i ? n.CW : n.CCW : i ? n.CCW : n.CW,
                            t.WebGLContext.setFrontFace(n, a);
                }
            }
        }, {
            key: "uploadCustomUniform",
            value: function uploadCustomUniform(e, r) {
                t.Stat.shaderCall += t.LayaGLRunner.uploadCustomUniform(t.LayaGL.instance, this._customUniformParamsMap, e, r);
            }
        }, {
            key: "_uniformMatrix2fvForNative",
            value: function _uniformMatrix2fvForNative(e, r) {
                return t.LayaGL.instance.uniformMatrix2fvEx(e.location, !1, r), 1;
            }
        }, {
            key: "_uniformMatrix3fvForNative",
            value: function _uniformMatrix3fvForNative(e, r) {
                return t.LayaGL.instance.uniformMatrix3fvEx(e.location, !1, r), 1;
            }
        }, {
            key: "_uniformMatrix4fvForNative",
            value: function _uniformMatrix4fvForNative(e, r) {
                return t.LayaGL.instance.uniformMatrix4fvEx(e.location, !1, r), 1;
            }
        }]);
        return ne;
    }(t.Resource);
    var se = /* */ function(_t$ShaderCompile) {
        _inherits(se, _t$ShaderCompile);

        function se(e, t, r, i) {
            var _this14;
            _classCallCheck(this, se);
            for (var a in _this14 = _possibleConstructorReturn(this, _getPrototypeOf(se).call(this, t, r, null)),
                    _this14._cacheSharders = {}, _this14._cacheShaderHierarchy = 1, _this14._renderState = new Q(),
                    _this14._validDefine = new B(), _this14._owner = e, _this14._stateMap = i, _this14.defs) {
                _this14._validDefine.add(H.getDefineByName(a));
            }
            return _possibleConstructorReturn(_this14);
        }
        _createClass(se, [{
            key: "_compileToTree",
            value: function _compileToTree(e, r, i, a, n) {
                var s, o, l, _, h, c, d, u, m, f, E;
                for (m = i; m < r.length; m++) {
                    if (!((l = r[m]).length < 1) && 0 !== (c = l.indexOf("//"))) {
                        if (c >= 0 && (l = l.substr(0, c)), s = u || new t.ShaderNode(a), u = null, s.text = l,
                            (c = l.indexOf("#")) >= 0) {
                            for (_ = "#", E = c + 1, f = l.length; E < f; E++) {
                                var T = l.charAt(E);
                                if (" " === T || "\t" === T || "?" === T) break;
                                _ += T;
                            }
                            switch (s.name = _, _) {
                                case "#ifdef":
                                case "#ifndef":
                                    if (s.setParent(e), e = s, n)
                                        for (d = l.substr(E).split(t.ShaderCompile._splitToWordExps3),
                                            E = 0; E < d.length; E++) {
                                            (l = d[E]).length && (n[l] = !0);
                                        }
                                    continue;

                                case "#if":
                                case "#elif":
                                    if (s.setParent(e), e = s, n)
                                        for (d = l.substr(E).split(t.ShaderCompile._splitToWordExps3),
                                            E = 0; E < d.length; E++) {
                                            (l = d[E]).length && "defined" != l && (n[l] = !0);
                                        }
                                    continue;

                                case "#else":
                                    o = (e = e.parent).childs[e.childs.length - 1], s.setParent(e), e = s;
                                    continue;

                                case "#endif":
                                    o = (e = e.parent).childs[e.childs.length - 1], s.setParent(e);
                                    continue;

                                case "#include":
                                    d = t.ShaderCompile.splitToWords(l, null);
                                    var p = t.ShaderCompile.includes[d[1]];
                                    if (!p) throw "ShaderCompile error no this include file:" + d[1];
                                    if ((c = d[0].indexOf("?")) < 0) {
                                        s.setParent(e), l = p.getWith("with" == d[2] ? d[3] : null), this._compileToTree(s, l.split("\n"), 0, a, n),
                                            s.text = "";
                                        continue;
                                    }
                                    s.setCondition(d[0].substr(c + 1), t.ShaderCompile.IFDEF_YES), s.text = p.getWith("with" == d[2] ? d[3] : null);
                                    break;

                                case "#import":
                                    h = (d = t.ShaderCompile.splitToWords(l, null))[1], a.push({
                                        node: s,
                                        file: t.ShaderCompile.includes[h],
                                        ofs: s.text.length
                                    });
                                    continue;
                            }
                        } else {
                            if ((o = e.childs[e.childs.length - 1]) && !o.name) {
                                a.length > 0 && t.ShaderCompile.splitToWords(l, o), u = s, o.text += "\n" + l;
                                continue;
                            }
                            a.length > 0 && t.ShaderCompile.splitToWords(l, s);
                        }
                        s.setParent(e);
                    }
                }
            }
        }, {
            key: "_resizeCacheShaderMap",
            value: function _resizeCacheShaderMap(e, t, r) {
                var i = this._cacheShaderHierarchy - 1;
                if (t == i) {
                    for (var a in e) {
                        for (var n = e[a], s = 0, o = r - i; s < o; s++) {
                            s == o - 1 ? e[0] = n : e = e[0 == s ? a : 0] = {};
                        }
                    }
                    this._cacheShaderHierarchy = r;
                } else
                    for (var a in e) {
                        this._resizeCacheShaderMap(e[a], ++t, r);
                    }
            }
        }, {
            key: "_addDebugShaderVariantCollection",
            value: function _addDebugShaderVariantCollection(e) {
                var t = H._debugShaderVariantInfo,
                    r = this._owner,
                    i = r._owner,
                    a = se._debugDefineString;
                if (H._getNamesByDefineData(e, a), !l._config._multiLighting) {
                    var n = a.indexOf("LEGACYSINGLELIGHTING"); -
                    1 !== n && a.splice(n, 1);
                }
                t ? t.setValue(i, i._subShaders.indexOf(r), r._passes.indexOf(this), a) : H._debugShaderVariantInfo = t = new G(i, i._subShaders.indexOf(r), r._passes.indexOf(this), a),
                    H.debugShaderVariantCollection.add(t);
            }
        }, {
            key: "withCompile",
            value: function withCompile(e) {
                e._intersectionDefineDatas(this._validDefine), H.debugMode && this._addDebugShaderVariantCollection(e);
                var r = this._cacheSharders,
                    i = e._length;
                i > this._cacheShaderHierarchy && (this._resizeCacheShaderMap(r, 0, i), this._cacheShaderHierarchy = i);
                for (var a = e._mask, n = e._length - 1, s = this._cacheShaderHierarchy - 1, o = 0; o < s; o++) {
                    var _ = n < o ? 0 : a[o],
                        h = r[_];
                    h || (r[_] = h = {}), r = h;
                }
                var c = n < s ? 0 : a[s],
                    d = r[c];
                if (d) return d;
                var u = se._defineString;
                H._getNamesByDefineData(e, u);
                var m, f, E = l._config,
                    T = E.lightClusterCount,
                    p = {},
                    g = "";
                t.WebGL._isWebGL2 ? (m = "#version 300 es\n\n\t\t\t\t#define attribute in\n\t\t\t\t#define varying out\n\t\t\t\t#define texture2D texture\n",
                        f = "#version 300 es\n\n\t\t\t\t#define varying in\n\t\t\t\tout highp vec4 pc_fragColor;\n\t\t\t\t#define gl_FragColor pc_fragColor\n\t\t\t\t#define gl_FragDepthEXT gl_FragDepth\n\t\t\t\t#define texture2D texture\n\t\t\t\t#define textureCube texture\n\t\t\t\t#define texture2DProj textureProj\n\t\t\t\t#define texture2DLodEXT textureLod\n\t\t\t\t#define texture2DProjLodEXT textureProjLod\n\t\t\t\t#define textureCubeLodEXT textureLod\n\t\t\t\t#define texture2DGradEXT textureGrad\n\t\t\t\t#define texture2DProjGradEXT textureProjGrad\n\t\t\t\t#define textureCubeGradEXT textureGrad\n") : (m = "",
                        f = "#ifdef GL_EXT_shader_texture_lod\n\t\t\t\t\t#extension GL_EXT_shader_texture_lod : enable\n\t\t\t\t#endif\n\t\t\t\t#if !defined(GL_EXT_shader_texture_lod)\n\t\t\t\t\t#define texture1DLodEXT texture1D\n\t\t\t\t\t#define texture2DLodEXT texture2D\n\t\t\t\t\t#define texture2DProjLodEXT texture2DProj\n\t\t\t\t\t#define texture3DLodEXT texture3D\n\t\t\t\t\t#define textureCubeLodEXT textureCube\n\t\t\t\t#endif\n"),
                    g += "#define MAX_LIGHT_COUNT " + E.maxLightCount + "\n", g += "#define MAX_LIGHT_COUNT_PER_CLUSTER " + E._maxAreaLightCountPerClusterAverage + "\n",
                    g += "#define CLUSTER_X_COUNT " + T.x + "\n", g += "#define CLUSTER_Y_COUNT " + T.y + "\n",
                    g += "#define CLUSTER_Z_COUNT " + T.z + "\n", g += "#define SHADER_CAPAILITY_LEVEL " + t.SystemUtils._shaderCapailityLevel + "\n";
                o = 0;
                for (var S = u.length; o < S; o++) {
                    var R = u[o];
                    g += "#define " + R + "\n", p[R] = !0;
                }
                var v = this._VS.toscript(p, []),
                    x = "";
                0 == v[0].indexOf("#version") && (x = v[0] + "\n", v.shift());
                var I = this._PS.toscript(p, []),
                    A = "";
                if (0 == I[0].indexOf("#version") && (A = I[0] + "\n", I.shift()), d = new ne(x + m + g + v.join("\n"), A + f + g + I.join("\n"), this._owner._attributeMap || this._owner._owner._attributeMap, this._owner._uniformMap || this._owner._owner._uniformMap, this),
                    r[c] = d, H.debugMode) {
                    var M = "",
                        D = "";
                    if (!E._multiLighting) {
                        e.remove(H.SHADERDEFINE_LEGACYSINGALLIGHTING);
                        var L = u.indexOf("LEGACYSINGLELIGHTING"); -
                        1 !== L && u.splice(L, 1);
                    }
                    for (o = 0, S = e._length; o < S; o++) {
                        D += o == S - 1 ? a[o] : a[o] + ",";
                    }
                    for (o = 0, S = u.length; o < S; o++) {
                        M += o == S - 1 ? u[o] : u[o] + ",";
                    }
                    console.log("%cLayaAir: Shader Compile Information---ShaderName:" + this._owner._owner._name + " SubShaderIndex:" + this._owner._owner._subShaders.indexOf(this._owner) + " PassIndex:" + this._owner._passes.indexOf(this) + " DefineMask:[" + D + "] DefineNames:[" + M + "]", "color:green");
                }
                return d;
            }
        }, {
            key: "renderState",
            get: function get() {
                return this._renderState;
            }
        }]);
        return se;
    }(t.ShaderCompile);
    se._defineString = [], se._debugDefineString = [];
    var oe = /* */ function() {
        function oe(e, t) {
            _classCallCheck(this, oe);
            this._flags = {}, this._passes = [], this._attributeMap = e, this._uniformMap = t;
        }
        _createClass(oe, [{
            key: "setFlag",
            value: function setFlag(e, t) {
                t ? this._flags[e] = t : delete this._flags[e];
            }
        }, {
            key: "getFlag",
            value: function getFlag(e) {
                return this._flags[e];
            }
        }, {
            key: "addShaderPass",
            value: function addShaderPass(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i = new se(this, e, t, r);
                return this._passes.push(i), i;
            }
        }]);
        return oe;
    }();
    var le = /* */ function() {
        function le() {
            _classCallCheck(this, le);
        }
        _createClass(le, null, [{
            key: "__init__",
            value: function __init__() {
                var e = t.LayaGL.instance;
                le._elementInfos = {
                    single: [1, e.FLOAT, 0],
                    vector2: [2, e.FLOAT, 0],
                    vector3: [3, e.FLOAT, 0],
                    vector4: [4, e.FLOAT, 0],
                    color: [4, e.FLOAT, 0],
                    byte4: [4, e.UNSIGNED_BYTE, 0],
                    short2: [2, e.FLOAT, 0],
                    short4: [4, e.FLOAT, 0],
                    normalizedshort2: [2, e.FLOAT, 0],
                    normalizedshort4: [4, e.FLOAT, 0],
                    halfvector2: [2, e.FLOAT, 0],
                    halfvector4: [4, e.FLOAT, 0]
                };
            }
        }, {
            key: "getElementInfos",
            value: function getElementInfos(e) {
                var t = le._elementInfos[e];
                if (t) return t;
                throw "VertexElementFormat: this vertexElementFormat is not implement.";
            }
        }]);
        return le;
    }();
    le.Single = "single", le.Vector2 = "vector2", le.Vector3 = "vector3", le.Vector4 = "vector4",
        le.Color = "color", le.Byte4 = "byte4", le.Short2 = "short2", le.Short4 = "short4",
        le.NormalizedShort2 = "normalizedshort2", le.NormalizedShort4 = "normalizedshort4",
        le.HalfVector2 = "halfvector2", le.HalfVector4 = "halfvector4";
    var _e = /* */ function() {
        function _e(e, t) {
            _classCallCheck(this, _e);
            this._id = ++_e._uniqueIDCounter, this._vertexElementsDic = {}, this._vertexStride = e,
                this._vertexElements = t;
            var r = t.length;
            this._shaderValues = new k(null);
            for (var i = 0; i < r; i++) {
                var a = t[i],
                    n = a._elementUsage;
                this._vertexElementsDic[n] = a;
                var s = new Int32Array(5),
                    o = le.getElementInfos(a._elementFormat);
                s[0] = o[0], s[1] = o[1], s[2] = o[2], s[3] = this._vertexStride, s[4] = a._offset,
                    this._shaderValues.setAttribute(n, s);
            }
        }
        _createClass(_e, [{
            key: "getVertexElementByIndex",
            value: function getVertexElementByIndex(e) {
                return this._vertexElements[e];
            }
        }, {
            key: "getVertexElementByUsage",
            value: function getVertexElementByUsage(e) {
                return this._vertexElementsDic[e];
            }
        }, {
            key: "id",
            get: function get() {
                return this._id;
            }
        }, {
            key: "vertexStride",
            get: function get() {
                return this._vertexStride;
            }
        }, {
            key: "vertexElementCount",
            get: function get() {
                return this._vertexElements.length;
            }
        }]);
        return _e;
    }();
    _e._uniqueIDCounter = 1;
    var he = /* */ function() {
        _createClass(he, [{
            key: "offset",
            get: function get() {
                return this._offset;
            }
        }, {
            key: "elementFormat",
            get: function get() {
                return this._elementFormat;
            }
        }, {
            key: "elementUsage",
            get: function get() {
                return this._elementUsage;
            }
        }]);

        function he(e, t, r) {
            _classCallCheck(this, he);
            this._offset = e, this._elementFormat = t, this._elementUsage = r;
        }
        return he;
    }();
    var ce = /* */ function() {
        function ce() {
            _classCallCheck(this, ce);
        }
        _createClass(ce, null, [{
            key: "__init__",
            value: function __init__() {
                ce.instanceWorldMatrixDeclaration = new _e(64, [new he(0, le.Vector4, ce.MESH_WORLDMATRIX_ROW0), new he(16, le.Vector4, ce.MESH_WORLDMATRIX_ROW1), new he(32, le.Vector4, ce.MESH_WORLDMATRIX_ROW2), new he(48, le.Vector4, ce.MESH_WORLDMATRIX_ROW3)]),
                    ce.instanceMVPMatrixDeclaration = new _e(64, [new he(0, le.Vector4, ce.MESH_MVPMATRIX_ROW0), new he(16, le.Vector4, ce.MESH_MVPMATRIX_ROW1), new he(32, le.Vector4, ce.MESH_MVPMATRIX_ROW2), new he(48, le.Vector4, ce.MESH_MVPMATRIX_ROW3)]);
            }
        }, {
            key: "getVertexDeclaration",
            value: function getVertexDeclaration(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
                var r = ce._vertexDeclarationMap[e + (t ? "_0" : "_1")];
                if (!r) {
                    for (var i = e.split(","), a = 0, n = [], s = 0, o = i.length; s < o; s++) {
                        var l;
                        switch (i[s]) {
                            case "POSITION":
                                l = new he(a, le.Vector3, ce.MESH_POSITION0), a += 12;
                                break;

                            case "NORMAL":
                                l = new he(a, le.Vector3, ce.MESH_NORMAL0), a += 12;
                                break;

                            case "COLOR":
                                l = new he(a, le.Vector4, ce.MESH_COLOR0), a += 16;
                                break;

                            case "UV":
                                l = new he(a, le.Vector2, ce.MESH_TEXTURECOORDINATE0), a += 8;
                                break;

                            case "UV1":
                                l = new he(a, le.Vector2, ce.MESH_TEXTURECOORDINATE1), a += 8;
                                break;

                            case "BLENDWEIGHT":
                                l = new he(a, le.Vector4, ce.MESH_BLENDWEIGHT0), a += 16;
                                break;

                            case "BLENDINDICES":
                                t ? (l = new he(a, le.Vector4, ce.MESH_BLENDINDICES0), a += 16) : (l = new he(a, le.Byte4, ce.MESH_BLENDINDICES0),
                                    a += 4);
                                break;

                            case "TANGENT":
                                l = new he(a, le.Vector4, ce.MESH_TANGENT0), a += 16;
                                break;

                            default:
                                throw "VertexMesh: unknown vertex flag.";
                        }
                        n.push(l);
                    }
                    r = new _e(a, n), ce._vertexDeclarationMap[e + (t ? "_0" : "_1")] = r;
                }
                return r;
            }
        }]);
        return ce;
    }();
    ce.MESH_POSITION0 = 0, ce.MESH_COLOR0 = 1, ce.MESH_TEXTURECOORDINATE0 = 2, ce.MESH_NORMAL0 = 3,
        ce.MESH_TANGENT0 = 4, ce.MESH_BLENDINDICES0 = 5, ce.MESH_BLENDWEIGHT0 = 6, ce.MESH_TEXTURECOORDINATE1 = 7,
        ce.MESH_WORLDMATRIX_ROW0 = 8, ce.MESH_WORLDMATRIX_ROW1 = 9, ce.MESH_WORLDMATRIX_ROW2 = 10,
        ce.MESH_WORLDMATRIX_ROW3 = 11, ce.MESH_MVPMATRIX_ROW0 = 12, ce.MESH_MVPMATRIX_ROW1 = 13,
        ce.MESH_MVPMATRIX_ROW2 = 14, ce.MESH_MVPMATRIX_ROW3 = 15, ce._vertexDeclarationMap = {},
        (te = e.PBRSpecularSmoothnessSource || (e.PBRSpecularSmoothnessSource = {}))[te.SpecularTextureAlpha = 0] = "SpecularTextureAlpha",
        te[te.AlbedoTextureAlpha = 1] = "AlbedoTextureAlpha";
    var de = /* */ function(_ee) {
        _inherits(de, _ee);

        function de() {
            var _this15;
            _classCallCheck(this, de);
            _this15 = _possibleConstructorReturn(this, _getPrototypeOf(de).call(this)), _this15.setShaderName("PBRSpecular"),
                _this15._shaderValues.setVector(de.SPECULARCOLOR, new a(.2, .2, .2, 1));
            return _this15;
        }
        _createClass(de, [{
            key: "clone",
            value: function clone() {
                var e = new de();
                return this.cloneTo(e), e;
            }
        }, {
            key: "specularTexture",
            get: function get() {
                return this._shaderValues.getTexture(de.SPECULARTEXTURE);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(de.SHADERDEFINE_SPECULARGLOSSTEXTURE) : this._shaderValues.removeDefine(de.SHADERDEFINE_SPECULARGLOSSTEXTURE),
                    this._shaderValues.setTexture(de.SPECULARTEXTURE, e);
            }
        }, {
            key: "specularColor",
            get: function get() {
                return this._shaderValues.getVector(de.SPECULARCOLOR);
            },
            set: function set(e) {
                this._shaderValues.setVector(de.SPECULARCOLOR, e);
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                de.SHADERDEFINE_SPECULARGLOSSTEXTURE = H.getDefineByName("SPECULARGLOSSTEXTURE"),
                    de.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = H.getDefineByName("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
                var e = {
                        a_Position: ce.MESH_POSITION0,
                        a_Normal: ce.MESH_NORMAL0,
                        a_Tangent0: ce.MESH_TANGENT0,
                        a_Texcoord0: ce.MESH_TEXTURECOORDINATE0,
                        a_Texcoord1: ce.MESH_TEXTURECOORDINATE1,
                        a_BoneWeights: ce.MESH_BLENDWEIGHT0,
                        a_BoneIndices: ce.MESH_BLENDINDICES0,
                        a_MvpMatrix: ce.MESH_MVPMATRIX_ROW0,
                        a_WorldMat: ce.MESH_WORLDMATRIX_ROW0
                    },
                    t = {
                        u_Bones: H.PERIOD_CUSTOM,
                        u_MvpMatrix: H.PERIOD_SPRITE,
                        u_WorldMat: H.PERIOD_SPRITE,
                        u_LightmapScaleOffset: H.PERIOD_SPRITE,
                        u_LightMap: H.PERIOD_SPRITE,
                        u_CameraPos: H.PERIOD_CAMERA,
                        u_View: H.PERIOD_CAMERA,
                        u_ProjectionParams: H.PERIOD_CAMERA,
                        u_Viewport: H.PERIOD_CAMERA,
                        u_AlphaTestValue: H.PERIOD_MATERIAL,
                        u_AlbedoColor: H.PERIOD_MATERIAL,
                        u_EmissionColor: H.PERIOD_MATERIAL,
                        u_AlbedoTexture: H.PERIOD_MATERIAL,
                        u_NormalTexture: H.PERIOD_MATERIAL,
                        u_ParallaxTexture: H.PERIOD_MATERIAL,
                        u_OcclusionTexture: H.PERIOD_MATERIAL,
                        u_EmissionTexture: H.PERIOD_MATERIAL,
                        u_Smoothness: H.PERIOD_MATERIAL,
                        u_SmoothnessScale: H.PERIOD_MATERIAL,
                        u_occlusionStrength: H.PERIOD_MATERIAL,
                        u_NormalScale: H.PERIOD_MATERIAL,
                        u_ParallaxScale: H.PERIOD_MATERIAL,
                        u_TilingOffset: H.PERIOD_MATERIAL,
                        u_SpecGlossTexture: H.PERIOD_MATERIAL,
                        u_SpecularColor: H.PERIOD_MATERIAL,
                        u_ReflectTexture: H.PERIOD_SCENE,
                        u_ReflectIntensity: H.PERIOD_SCENE,
                        u_AmbientColor: H.PERIOD_SCENE,
                        u_FogStart: H.PERIOD_SCENE,
                        u_FogRange: H.PERIOD_SCENE,
                        u_FogColor: H.PERIOD_SCENE,
                        u_DirationLightCount: H.PERIOD_SCENE,
                        u_LightBuffer: H.PERIOD_SCENE,
                        u_LightClusterBuffer: H.PERIOD_SCENE,
                        u_shadowMap1: H.PERIOD_SCENE,
                        u_shadowMap2: H.PERIOD_SCENE,
                        u_shadowMap3: H.PERIOD_SCENE,
                        u_shadowPSSMDistance: H.PERIOD_SCENE,
                        u_lightShadowVP: H.PERIOD_SCENE,
                        u_shadowPCFoffset: H.PERIOD_SCENE,
                        u_AmbientSHAr: H.PERIOD_SCENE,
                        u_AmbientSHAg: H.PERIOD_SCENE,
                        u_AmbientSHAb: H.PERIOD_SCENE,
                        u_AmbientSHBr: H.PERIOD_SCENE,
                        u_AmbientSHBg: H.PERIOD_SCENE,
                        u_AmbientSHBb: H.PERIOD_SCENE,
                        u_AmbientSHC: H.PERIOD_SCENE,
                        u_ReflectionProbe: H.PERIOD_SCENE,
                        u_ReflectCubeHDRParams: H.PERIOD_SCENE,
                        "u_DirectionLight.direction": H.PERIOD_SCENE,
                        "u_DirectionLight.color": H.PERIOD_SCENE,
                        "u_PointLight.position": H.PERIOD_SCENE,
                        "u_PointLight.range": H.PERIOD_SCENE,
                        "u_PointLight.color": H.PERIOD_SCENE,
                        "u_SpotLight.position": H.PERIOD_SCENE,
                        "u_SpotLight.direction": H.PERIOD_SCENE,
                        "u_SpotLight.range": H.PERIOD_SCENE,
                        "u_SpotLight.spot": H.PERIOD_SCENE,
                        "u_SpotLight.color": H.PERIOD_SCENE
                    },
                    r = {
                        s_Cull: H.RENDER_STATE_CULL,
                        s_Blend: H.RENDER_STATE_BLEND,
                        s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                        s_BlendDst: H.RENDER_STATE_BLEND_DST,
                        s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                        s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
                    },
                    i = H.add("PBRSpecular"),
                    a = new oe(e, t);
                i.addSubShader(a), a.addShaderPass(ie, re, r);
            }
        }]);
        return de;
    }(ee);
    de.SPECULARTEXTURE = H.propertyNameToID("u_SpecularTexture"), de.SPECULARCOLOR = H.propertyNameToID("u_SpecularColor");
    var ue, me, fe, Ee, Te, pe = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n#include "PBRFSInput.glsl";\r\n#include "LayaPBRBRDF.glsl";\r\n#include "GlobalIllumination.glsl";\r\n#include "ShadowHelper.glsl"\r\n#include "PBRCore.glsl";\r\n#include "PBRFSShadow.glsl";\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\t\t\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tfragmentForward();\r\n\t#endif  \r\n}',
        ge = '#include "PBRVSInput.glsl";\r\n#include "Lighting.glsl";\r\n#include "PBRVertex.glsl";\r\n#include "PBRVSShadow.glsl";\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tvertexForward();\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}';
    (ue = e.PBRMetallicSmoothnessSource || (e.PBRMetallicSmoothnessSource = {}))[ue.MetallicGlossTextureAlpha = 0] = "MetallicGlossTextureAlpha",
    ue[ue.AlbedoTextureAlpha = 1] = "AlbedoTextureAlpha";
    var Se = /* */ function(_ee2) {
        _inherits(Se, _ee2);

        function Se() {
            var _this16;
            _classCallCheck(this, Se);
            _this16 = _possibleConstructorReturn(this, _getPrototypeOf(Se).call(this)), _this16._smoothnessSource = 0,
                _this16.setShaderName("PBR"), _this16._shaderValues.setNumber(Se.METALLIC, 0);
            return _this16;
        }
        _createClass(Se, [{
            key: "clone",
            value: function clone() {
                var e = new Se();
                return this.cloneTo(e), e;
            }
        }, {
            key: "metallicGlossTexture",
            get: function get() {
                return this._shaderValues.getTexture(Se.METALLICGLOSSTEXTURE);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(Se.SHADERDEFINE_METALLICGLOSSTEXTURE) : this._shaderValues.removeDefine(Se.SHADERDEFINE_METALLICGLOSSTEXTURE),
                    this._shaderValues.setTexture(Se.METALLICGLOSSTEXTURE, e);
            }
        }, {
            key: "metallic",
            get: function get() {
                return this._shaderValues.getNumber(Se.METALLIC);
            },
            set: function set(e) {
                this._shaderValues.setNumber(Se.METALLIC, Math.max(0, Math.min(1, e)));
            }
        }, {
            key: "smoothnessSource",
            get: function get() {
                return this._smoothnessSource;
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(Se.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA) : this._shaderValues.removeDefine(Se.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA),
                    this._smoothnessSource = e;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                Se.SHADERDEFINE_METALLICGLOSSTEXTURE = H.getDefineByName("METALLICGLOSSTEXTURE"),
                    Se.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = H.getDefineByName("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
                var e = {
                        a_Position: ce.MESH_POSITION0,
                        a_Normal: ce.MESH_NORMAL0,
                        a_Tangent0: ce.MESH_TANGENT0,
                        a_Texcoord0: ce.MESH_TEXTURECOORDINATE0,
                        a_Texcoord1: ce.MESH_TEXTURECOORDINATE1,
                        a_BoneWeights: ce.MESH_BLENDWEIGHT0,
                        a_BoneIndices: ce.MESH_BLENDINDICES0,
                        a_MvpMatrix: ce.MESH_MVPMATRIX_ROW0,
                        a_WorldMat: ce.MESH_WORLDMATRIX_ROW0
                    },
                    t = {
                        u_Bones: H.PERIOD_CUSTOM,
                        u_MvpMatrix: H.PERIOD_SPRITE,
                        u_WorldMat: H.PERIOD_SPRITE,
                        u_LightmapScaleOffset: H.PERIOD_SPRITE,
                        u_LightMap: H.PERIOD_SPRITE,
                        u_CameraPos: H.PERIOD_CAMERA,
                        u_View: H.PERIOD_CAMERA,
                        u_ProjectionParams: H.PERIOD_CAMERA,
                        u_Viewport: H.PERIOD_CAMERA,
                        u_AlphaTestValue: H.PERIOD_MATERIAL,
                        u_AlbedoColor: H.PERIOD_MATERIAL,
                        u_EmissionColor: H.PERIOD_MATERIAL,
                        u_AlbedoTexture: H.PERIOD_MATERIAL,
                        u_NormalTexture: H.PERIOD_MATERIAL,
                        u_ParallaxTexture: H.PERIOD_MATERIAL,
                        u_OcclusionTexture: H.PERIOD_MATERIAL,
                        u_EmissionTexture: H.PERIOD_MATERIAL,
                        u_Smoothness: H.PERIOD_MATERIAL,
                        u_SmoothnessScale: H.PERIOD_MATERIAL,
                        u_occlusionStrength: H.PERIOD_MATERIAL,
                        u_NormalScale: H.PERIOD_MATERIAL,
                        u_ParallaxScale: H.PERIOD_MATERIAL,
                        u_TilingOffset: H.PERIOD_MATERIAL,
                        u_MetallicGlossTexture: H.PERIOD_MATERIAL,
                        u_Metallic: H.PERIOD_MATERIAL,
                        u_ReflectTexture: H.PERIOD_SCENE,
                        u_ReflectIntensity: H.PERIOD_SCENE,
                        u_AmbientColor: H.PERIOD_SCENE,
                        u_FogStart: H.PERIOD_SCENE,
                        u_FogRange: H.PERIOD_SCENE,
                        u_FogColor: H.PERIOD_SCENE,
                        u_DirationLightCount: H.PERIOD_SCENE,
                        u_LightBuffer: H.PERIOD_SCENE,
                        u_LightClusterBuffer: H.PERIOD_SCENE,
                        u_shadowMap1: H.PERIOD_SCENE,
                        u_shadowMap2: H.PERIOD_SCENE,
                        u_shadowMap3: H.PERIOD_SCENE,
                        u_shadowPSSMDistance: H.PERIOD_SCENE,
                        u_lightShadowVP: H.PERIOD_SCENE,
                        u_shadowPCFoffset: H.PERIOD_SCENE,
                        u_AmbientSHAr: H.PERIOD_SCENE,
                        u_AmbientSHAg: H.PERIOD_SCENE,
                        u_AmbientSHAb: H.PERIOD_SCENE,
                        u_AmbientSHBr: H.PERIOD_SCENE,
                        u_AmbientSHBg: H.PERIOD_SCENE,
                        u_AmbientSHBb: H.PERIOD_SCENE,
                        u_AmbientSHC: H.PERIOD_SCENE,
                        u_ReflectionProbe: H.PERIOD_SCENE,
                        u_ReflectCubeHDRParams: H.PERIOD_SCENE,
                        "u_DirectionLight.direction": H.PERIOD_SCENE,
                        "u_DirectionLight.color": H.PERIOD_SCENE,
                        "u_PointLight.position": H.PERIOD_SCENE,
                        "u_PointLight.range": H.PERIOD_SCENE,
                        "u_PointLight.color": H.PERIOD_SCENE,
                        "u_SpotLight.position": H.PERIOD_SCENE,
                        "u_SpotLight.direction": H.PERIOD_SCENE,
                        "u_SpotLight.range": H.PERIOD_SCENE,
                        "u_SpotLight.spot": H.PERIOD_SCENE,
                        "u_SpotLight.color": H.PERIOD_SCENE
                    },
                    r = {
                        s_Cull: H.RENDER_STATE_CULL,
                        s_Blend: H.RENDER_STATE_BLEND,
                        s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                        s_BlendDst: H.RENDER_STATE_BLEND_DST,
                        s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                        s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
                    },
                    i = H.add("PBR"),
                    a = new oe(e, t);
                i.addSubShader(a), a.addShaderPass(ge, pe, r);
            }
        }]);
        return Se;
    }(ee);
    Se.METALLICGLOSSTEXTURE = H.propertyNameToID("u_MetallicGlossTexture"), Se.METALLIC = H.propertyNameToID("u_Metallic");
    var Re = /* */ function(_j5) {
        _inherits(Re, _j5);

        function Re() {
            var _this17;
            _classCallCheck(this, Re);
            _this17 = _possibleConstructorReturn(this, _getPrototypeOf(Re).call(this)), _this17.setShaderName("SkyBox"),
                _this17.tintColor = new a(.5, .5, .5, .5), _this17.exposure = 1, _this17.rotation = 0;
            return _this17;
        }
        _createClass(Re, [{
            key: "clone",
            value: function clone() {
                var e = new Re();
                return this.cloneTo(e), e;
            }
        }, {
            key: "tintColor",
            get: function get() {
                return this._shaderValues.getVector(Re.TINTCOLOR);
            },
            set: function set(e) {
                this._shaderValues.setVector(Re.TINTCOLOR, e);
            }
        }, {
            key: "exposure",
            get: function get() {
                return this._shaderValues.getNumber(Re.EXPOSURE);
            },
            set: function set(e) {
                this._shaderValues.setNumber(Re.EXPOSURE, e);
            }
        }, {
            key: "rotation",
            get: function get() {
                return this._shaderValues.getNumber(Re.ROTATION);
            },
            set: function set(e) {
                this._shaderValues.setNumber(Re.ROTATION, e);
            }
        }, {
            key: "textureCube",
            get: function get() {
                return this._shaderValues.getTexture(Re.TEXTURECUBE);
            },
            set: function set(e) {
                this._shaderValues.setTexture(Re.TEXTURECUBE, e);
            }
        }], [{
            key: "__initDefine__",
            value: function __initDefine__() {}
        }]);
        return Re;
    }(j);
    Re.TINTCOLOR = H.propertyNameToID("u_TintColor"), Re.EXPOSURE = H.propertyNameToID("u_Exposure"),
        Re.ROTATION = H.propertyNameToID("u_Rotation"), Re.TEXTURECUBE = H.propertyNameToID("u_CubeTexture");
    var ve = /* */ function(_j6) {
        _inherits(ve, _j6);

        function ve() {
            var _this18;
            _classCallCheck(this, ve);
            _this18 = _possibleConstructorReturn(this, _getPrototypeOf(ve).call(this)), _this18.setShaderName("SkyBoxProcedural"),
                _this18.sunDisk = ve.SUN_HIGH_QUALITY, _this18.sunSize = .04, _this18.sunSizeConvergence = 5,
                _this18.atmosphereThickness = 1, _this18.skyTint = new a(.5, .5, .5, 1), _this18.groundTint = new a(.369, .349, .341, 1),
                _this18.exposure = 1.3;
            return _this18;
        }
        _createClass(ve, [{
            key: "clone",
            value: function clone() {
                var e = new ve();
                return this.cloneTo(e), e;
            }
        }, {
            key: "sunDisk",
            get: function get() {
                return this._sunDisk;
            },
            set: function set(e) {
                switch (e) {
                    case ve.SUN_HIGH_QUALITY:
                        this._shaderValues.removeDefine(ve.SHADERDEFINE_SUN_SIMPLE), this._shaderValues.addDefine(ve.SHADERDEFINE_SUN_HIGH_QUALITY);
                        break;

                    case ve.SUN_SIMPLE:
                        this._shaderValues.removeDefine(ve.SHADERDEFINE_SUN_HIGH_QUALITY), this._shaderValues.addDefine(ve.SHADERDEFINE_SUN_SIMPLE);
                        break;

                    case ve.SUN_NODE:
                        this._shaderValues.removeDefine(ve.SHADERDEFINE_SUN_HIGH_QUALITY), this._shaderValues.removeDefine(ve.SHADERDEFINE_SUN_SIMPLE);
                        break;

                    default:
                        throw "SkyBoxProceduralMaterial: unknown sun value.";
                }
                this._sunDisk = e;
            }
        }, {
            key: "sunSize",
            get: function get() {
                return this._shaderValues.getNumber(ve.SUNSIZE);
            },
            set: function set(e) {
                e = Math.min(Math.max(0, e), 1), this._shaderValues.setNumber(ve.SUNSIZE, e);
            }
        }, {
            key: "sunSizeConvergence",
            get: function get() {
                return this._shaderValues.getNumber(ve.SUNSIZECONVERGENCE);
            },
            set: function set(e) {
                e = Math.min(Math.max(0, e), 20), this._shaderValues.setNumber(ve.SUNSIZECONVERGENCE, e);
            }
        }, {
            key: "atmosphereThickness",
            get: function get() {
                return this._shaderValues.getNumber(ve.ATMOSPHERETHICKNESS);
            },
            set: function set(e) {
                e = Math.min(Math.max(0, e), 5), this._shaderValues.setNumber(ve.ATMOSPHERETHICKNESS, e);
            }
        }, {
            key: "skyTint",
            get: function get() {
                return this._shaderValues.getVector(ve.SKYTINT);
            },
            set: function set(e) {
                this._shaderValues.setVector(ve.SKYTINT, e);
            }
        }, {
            key: "groundTint",
            get: function get() {
                return this._shaderValues.getVector(ve.GROUNDTINT);
            },
            set: function set(e) {
                this._shaderValues.setVector(ve.GROUNDTINT, e);
            }
        }, {
            key: "exposure",
            get: function get() {
                return this._shaderValues.getNumber(ve.EXPOSURE);
            },
            set: function set(e) {
                e = Math.min(Math.max(0, e), 8), this._shaderValues.setNumber(ve.EXPOSURE, e);
            }
        }], [{
            key: "__initDefine__",
            value: function __initDefine__() {
                ve.SHADERDEFINE_SUN_HIGH_QUALITY = H.getDefineByName("SUN_HIGH_QUALITY"), ve.SHADERDEFINE_SUN_SIMPLE = H.getDefineByName("SUN_SIMPLE");
            }
        }]);
        return ve;
    }(j);
    ve.SUN_NODE = 0, ve.SUN_SIMPLE = 1, ve.SUN_HIGH_QUALITY = 2, ve.SUNSIZE = H.propertyNameToID("u_SunSize"),
        ve.SUNSIZECONVERGENCE = H.propertyNameToID("u_SunSizeConvergence"), ve.ATMOSPHERETHICKNESS = H.propertyNameToID("u_AtmosphereThickness"),
        ve.SKYTINT = H.propertyNameToID("u_SkyTint"), ve.GROUNDTINT = H.propertyNameToID("u_GroundTint"),
        ve.EXPOSURE = H.propertyNameToID("u_Exposure");
    var xe = /* */ function(_j7) {
        _inherits(xe, _j7);

        function xe() {
            var _this19;
            _classCallCheck(this, xe);
            _this19 = _possibleConstructorReturn(this, _getPrototypeOf(xe).call(this)), _this19._albedoColor = new a(1, 1, 1, 1),
                _this19._albedoIntensity = 1, _this19._enableVertexColor = !1, _this19.setShaderName("Unlit"),
                _this19._shaderValues.setVector(xe.ALBEDOCOLOR, new a(1, 1, 1, 1)), _this19.renderMode = xe.RENDERMODE_OPAQUE;
            return _this19;
        }
        _createClass(xe, [{
            key: "clone",
            value: function clone() {
                var e = new xe();
                return this.cloneTo(e), e;
            }
        }, {
            key: "_ColorR",
            get: function get() {
                return this._albedoColor.x;
            },
            set: function set(e) {
                this._albedoColor.x = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorG",
            get: function get() {
                return this._albedoColor.y;
            },
            set: function set(e) {
                this._albedoColor.y = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorB",
            get: function get() {
                return this._albedoColor.z;
            },
            set: function set(e) {
                this._albedoColor.z = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorA",
            get: function get() {
                return this._albedoColor.w;
            },
            set: function set(e) {
                this._albedoColor.w = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_AlbedoIntensity",
            get: function get() {
                return this._albedoIntensity;
            },
            set: function set(e) {
                if (this._albedoIntensity !== e) {
                    var t = this._shaderValues.getVector(xe.ALBEDOCOLOR);
                    a.scale(this._albedoColor, e, t), this._albedoIntensity = e, this._shaderValues.setVector(xe.ALBEDOCOLOR, t);
                }
            }
        }, {
            key: "_MainTex_STX",
            get: function get() {
                return this._shaderValues.getVector(xe.TILINGOFFSET).x;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(xe.TILINGOFFSET);
                t.x = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function get() {
                return this._shaderValues.getVector(xe.TILINGOFFSET).y;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(xe.TILINGOFFSET);
                t.y = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function get() {
                return this._shaderValues.getVector(xe.TILINGOFFSET).z;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(xe.TILINGOFFSET);
                t.z = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function get() {
                return this._shaderValues.getVector(xe.TILINGOFFSET).w;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(xe.TILINGOFFSET);
                t.w = e, this.tilingOffset = t;
            }
        }, {
            key: "_Cutoff",
            get: function get() {
                return this.alphaTestValue;
            },
            set: function set(e) {
                this.alphaTestValue = e;
            }
        }, {
            key: "albedoColorR",
            get: function get() {
                return this._ColorR;
            },
            set: function set(e) {
                this._ColorR = e;
            }
        }, {
            key: "albedoColorG",
            get: function get() {
                return this._ColorG;
            },
            set: function set(e) {
                this._ColorG = e;
            }
        }, {
            key: "albedoColorB",
            get: function get() {
                return this._ColorB;
            },
            set: function set(e) {
                this._ColorB = e;
            }
        }, {
            key: "albedoColorA",
            get: function get() {
                return this._ColorA;
            },
            set: function set(e) {
                this._ColorA = e;
            }
        }, {
            key: "albedoColor",
            get: function get() {
                return this._albedoColor;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(xe.ALBEDOCOLOR);
                a.scale(e, this._albedoIntensity, t), this._albedoColor = e, this._shaderValues.setVector(xe.ALBEDOCOLOR, t);
            }
        }, {
            key: "albedoIntensity",
            get: function get() {
                return this._albedoIntensity;
            },
            set: function set(e) {
                this._AlbedoIntensity = e;
            }
        }, {
            key: "albedoTexture",
            get: function get() {
                return this._shaderValues.getTexture(xe.ALBEDOTEXTURE);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(xe.SHADERDEFINE_ALBEDOTEXTURE) : this._shaderValues.removeDefine(xe.SHADERDEFINE_ALBEDOTEXTURE),
                    this._shaderValues.setTexture(xe.ALBEDOTEXTURE, e);
            }
        }, {
            key: "tilingOffsetX",
            get: function get() {
                return this._MainTex_STX;
            },
            set: function set(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function get() {
                return this._MainTex_STY;
            },
            set: function set(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function get() {
                return this._MainTex_STZ;
            },
            set: function set(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function get() {
                return this._MainTex_STW;
            },
            set: function set(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function get() {
                return this._shaderValues.getVector(xe.TILINGOFFSET);
            },
            set: function set(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(xe.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(xe.SHADERDEFINE_TILINGOFFSET),
                    this._shaderValues.setVector(xe.TILINGOFFSET, e);
            }
        }, {
            key: "enableVertexColor",
            get: function get() {
                return this._enableVertexColor;
            },
            set: function set(e) {
                this._enableVertexColor = e, e ? this._shaderValues.addDefine(xe.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._shaderValues.removeDefine(xe.SHADERDEFINE_ENABLEVERTEXCOLOR);
            }
        }, {
            key: "renderMode",
            set: function set(e) {
                switch (e) {
                    case xe.RENDERMODE_OPAQUE:
                        this.alphaTest = !1, this.renderQueue = j.RENDERQUEUE_OPAQUE, this.depthWrite = !0,
                            this.cull = Q.CULL_BACK, this.blend = Q.BLEND_DISABLE, this.depthTest = Q.DEPTHTEST_LESS;
                        break;

                    case xe.RENDERMODE_CUTOUT:
                        this.renderQueue = j.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0,
                            this.cull = Q.CULL_BACK, this.blend = Q.BLEND_DISABLE, this.depthTest = Q.DEPTHTEST_LESS;
                        break;

                    case xe.RENDERMODE_TRANSPARENT:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                            this.cull = Q.CULL_BACK, this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                            this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Q.DEPTHTEST_LESS;
                        break;

                    default:
                        throw new Error("UnlitMaterial : renderMode value error.");
                }
            }
        }, {
            key: "depthWrite",
            get: function get() {
                return this._shaderValues.getBool(xe.DEPTH_WRITE);
            },
            set: function set(e) {
                this._shaderValues.setBool(xe.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function get() {
                return this._shaderValues.getInt(xe.CULL);
            },
            set: function set(e) {
                this._shaderValues.setInt(xe.CULL, e);
            }
        }, {
            key: "blend",
            get: function get() {
                return this._shaderValues.getInt(xe.BLEND);
            },
            set: function set(e) {
                this._shaderValues.setInt(xe.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function get() {
                return this._shaderValues.getInt(xe.BLEND_SRC);
            },
            set: function set(e) {
                this._shaderValues.setInt(xe.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function get() {
                return this._shaderValues.getInt(xe.BLEND_DST);
            },
            set: function set(e) {
                this._shaderValues.setInt(xe.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function get() {
                return this._shaderValues.getInt(xe.DEPTH_TEST);
            },
            set: function set(e) {
                this._shaderValues.setInt(xe.DEPTH_TEST, e);
            }
        }], [{
            key: "__initDefine__",
            value: function __initDefine__() {
                xe.SHADERDEFINE_ALBEDOTEXTURE = H.getDefineByName("ALBEDOTEXTURE"), xe.SHADERDEFINE_TILINGOFFSET = H.getDefineByName("TILINGOFFSET"),
                    xe.SHADERDEFINE_ENABLEVERTEXCOLOR = H.getDefineByName("ENABLEVERTEXCOLOR");
            }
        }]);
        return xe;
    }(j);
    xe.RENDERMODE_OPAQUE = 0, xe.RENDERMODE_CUTOUT = 1, xe.RENDERMODE_TRANSPARENT = 2,
        xe.RENDERMODE_ADDTIVE = 3, xe.ALBEDOTEXTURE = H.propertyNameToID("u_AlbedoTexture"),
        xe.ALBEDOCOLOR = H.propertyNameToID("u_AlbedoColor"), xe.TILINGOFFSET = H.propertyNameToID("u_TilingOffset"),
        xe.CULL = H.propertyNameToID("s_Cull"), xe.BLEND = H.propertyNameToID("s_Blend"),
        xe.BLEND_SRC = H.propertyNameToID("s_BlendSrc"), xe.BLEND_DST = H.propertyNameToID("s_BlendDst"),
        xe.DEPTH_TEST = H.propertyNameToID("s_DepthTest"), xe.DEPTH_WRITE = H.propertyNameToID("s_DepthWrite");
    var Ie = /* */ function(_j8) {
        _inherits(Ie, _j8);

        function Ie() {
            var _this20;
            _classCallCheck(this, Ie);
            _this20 = _possibleConstructorReturn(this, _getPrototypeOf(Ie).call(this)), _this20.setShaderName("WaterPrimary"),
                _this20._shaderValues.setVector(Ie.HORIZONCOLOR, new a(.172, .463, .435, 0)), _this20._shaderValues.setNumber(Ie.WAVESCALE, .15),
                _this20._shaderValues.setVector(Ie.WAVESPEED, new a(19, 9, -16, -7));
            return _this20;
        }
        _createClass(Ie, [{
            key: "clone",
            value: function clone() {
                var e = new Ie();
                return this.cloneTo(e), e;
            }
        }, {
            key: "horizonColor",
            get: function get() {
                return this._shaderValues.getVector(Ie.HORIZONCOLOR);
            },
            set: function set(e) {
                this._shaderValues.setVector(Ie.HORIZONCOLOR, e);
            }
        }, {
            key: "mainTexture",
            get: function get() {
                return this._shaderValues.getTexture(Ie.MAINTEXTURE);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(Ie.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(Ie.SHADERDEFINE_MAINTEXTURE),
                    this._shaderValues.setTexture(Ie.MAINTEXTURE, e);
            }
        }, {
            key: "normalTexture",
            get: function get() {
                return this._shaderValues.getTexture(Ie.NORMALTEXTURE);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(Ie.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(Ie.SHADERDEFINE_NORMALTEXTURE),
                    this._shaderValues.setTexture(Ie.NORMALTEXTURE, e);
            }
        }, {
            key: "waveScale",
            get: function get() {
                return this._shaderValues.getNumber(Ie.WAVESCALE);
            },
            set: function set(e) {
                this._shaderValues.setNumber(Ie.WAVESCALE, e);
            }
        }, {
            key: "waveSpeed",
            get: function get() {
                return this._shaderValues.getVector(Ie.WAVESPEED);
            },
            set: function set(e) {
                this._shaderValues.setVector(Ie.WAVESPEED, e);
            }
        }], [{
            key: "__initDefine__",
            value: function __initDefine__() {
                Ie.SHADERDEFINE_MAINTEXTURE = H.getDefineByName("MAINTEXTURE"), Ie.SHADERDEFINE_NORMALTEXTURE = H.getDefineByName("NORMALTEXTURE");
            }
        }]);
        return Ie;
    }(j);
    Ie.HORIZONCOLOR = H.propertyNameToID("u_HorizonColor"), Ie.MAINTEXTURE = H.propertyNameToID("u_MainTexture"),
        Ie.NORMALTEXTURE = H.propertyNameToID("u_NormalTexture"), Ie.WAVESCALE = H.propertyNameToID("u_WaveScale"),
        Ie.WAVESPEED = H.propertyNameToID("u_WaveSpeed");
    var Ae = /* */ function() {
        function Ae() {
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            _classCallCheck(this, Ae);
            this.r = e, this.g = t, this.b = r, this.a = i;
        }
        _createClass(Ae, [{
            key: "toLinear",
            value: function toLinear(e) {
                e.r = Ae.gammaToLinearSpace(this.r), e.g = Ae.gammaToLinearSpace(this.g), e.b = Ae.gammaToLinearSpace(this.b);
            }
        }, {
            key: "toGamma",
            value: function toGamma(e) {
                e.r = Ae.linearToGammaSpace(this.r), e.g = Ae.linearToGammaSpace(this.g), e.b = Ae.linearToGammaSpace(this.b);
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t.r = this.r, t.g = this.g, t.b = this.b, t.a = this.a;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Ae();
                return this.cloneTo(e), e;
            }
        }, {
            key: "forNativeElement",
            value: function forNativeElement() {}
        }], [{
            key: "gammaToLinearSpace",
            value: function gammaToLinearSpace(e) {
                return e <= .04045 ? e / 12.92 : e < 1 ? Math.pow((e + .055) / 1.055, 2.4) : Math.pow(e, 2.4);
            }
        }, {
            key: "linearToGammaSpace",
            value: function linearToGammaSpace(e) {
                return e <= 0 ? 0 : e <= .0031308 ? 12.92 * e : e <= 1 ? 1.055 * Math.pow(e, .41666) - .055 : Math.pow(e, .41666);
            }
        }]);
        return Ae;
    }();
    Ae.RED = new Ae(1, 0, 0, 1), Ae.GREEN = new Ae(0, 1, 0, 1), Ae.BLUE = new Ae(0, 0, 1, 1),
        Ae.CYAN = new Ae(0, 1, 1, 1), Ae.YELLOW = new Ae(1, .92, .016, 1), Ae.MAGENTA = new Ae(1, 0, 1, 1),
        Ae.GRAY = new Ae(.5, .5, .5, 1), Ae.WHITE = new Ae(1, 1, 1, 1), Ae.BLACK = new Ae(0, 0, 0, 1);
    var Me = /* */ function() {
        function Me() {
            _classCallCheck(this, Me);
            this._batchRenderElementPool = [];
        }
        _createClass(Me, [{
            key: "_clear",
            value: function _clear() {
                this._batchRenderElementPoolIndex = 0;
            }
        }, {
            key: "_getBatchRenderElementFromPool",
            value: function _getBatchRenderElementFromPool() {
                throw "StaticBatch:must override this function.";
            }
        }, {
            key: "dispose",
            value: function dispose() {}
        }], [{
            key: "_registerManager",
            value: function _registerManager(e) {
                Me._managers.push(e);
            }
        }]);
        return Me;
    }();
    Me._managers = [];
    var De = /* */ function(_t$EventDispatcher2) {
        _inherits(De, _t$EventDispatcher2);

        function De(e) {
            var _this21;
            _classCallCheck(this, De);
            _this21 = _possibleConstructorReturn(this, _getPrototypeOf(De).call(this)), _this21._localPosition = new n(0, 0, 0),
                _this21._localRotation = new f(0, 0, 0, 1), _this21._localScale = new n(1, 1, 1),
                _this21._localRotationEuler = new n(0, 0, 0), _this21._localMatrix = new C(), _this21._position = new n(0, 0, 0),
                _this21._rotation = new f(0, 0, 0, 1), _this21._scale = new n(1, 1, 1), _this21._rotationEuler = new n(0, 0, 0),
                _this21._worldMatrix = new C(), _this21._children = null, _this21._parent = null,
                _this21._dummy = null, _this21._transformFlag = 0, _this21._owner = e, _this21._children = [],
                _this21._setTransformFlag(De.TRANSFORM_LOCALQUATERNION | De.TRANSFORM_LOCALEULER | De.TRANSFORM_LOCALMATRIX, !1),
                _this21._setTransformFlag(De.TRANSFORM_WORLDPOSITION | De.TRANSFORM_WORLDQUATERNION | De.TRANSFORM_WORLDEULER | De.TRANSFORM_WORLDSCALE | De.TRANSFORM_WORLDMATRIX, !0);
            return _this21;
        }
        _createClass(De, [{
            key: "_getScaleMatrix",
            value: function _getScaleMatrix() {
                var e = De._tempQuaternion0,
                    t = De._tempMatrix3x30,
                    r = De._tempMatrix3x31,
                    i = De._tempMatrix3x32;
                return m.createFromMatrix4x4(this.worldMatrix, r), this.rotation.invert(e), m.createRotationQuaternion(e, t),
                    m.multiply(t, r, i), i;
            }
        }, {
            key: "_setTransformFlag",
            value: function _setTransformFlag(e, t) {
                t ? this._transformFlag |= e : this._transformFlag &= ~e;
            }
        }, {
            key: "_getTransformFlag",
            value: function _getTransformFlag(e) {
                return 0 != (this._transformFlag & e);
            }
        }, {
            key: "_setParent",
            value: function _setParent(e) {
                if (this._parent !== e) {
                    if (this._parent) {
                        var t = this._parent._children,
                            r = t.indexOf(this);
                        t.splice(r, 1);
                    }
                    e && (e._children.push(this), e && this._onWorldTransform()), this._parent = e;
                }
            }
        }, {
            key: "_onWorldPositionRotationTransform",
            value: function _onWorldPositionRotationTransform() {
                if (!(this._getTransformFlag(De.TRANSFORM_WORLDMATRIX) && this._getTransformFlag(De.TRANSFORM_WORLDPOSITION) && this._getTransformFlag(De.TRANSFORM_WORLDQUATERNION) && this._getTransformFlag(De.TRANSFORM_WORLDEULER))) {
                    this._setTransformFlag(De.TRANSFORM_WORLDMATRIX | De.TRANSFORM_WORLDPOSITION | De.TRANSFORM_WORLDQUATERNION | De.TRANSFORM_WORLDEULER, !0),
                        this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++) {
                        this._children[e]._onWorldPositionRotationTransform();
                    }
                }
            }
        }, {
            key: "_onWorldPositionScaleTransform",
            value: function _onWorldPositionScaleTransform() {
                if (!this._getTransformFlag(De.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(De.TRANSFORM_WORLDPOSITION) || !this._getTransformFlag(De.TRANSFORM_WORLDSCALE)) {
                    this._setTransformFlag(De.TRANSFORM_WORLDMATRIX | De.TRANSFORM_WORLDPOSITION | De.TRANSFORM_WORLDSCALE, !0),
                        this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++) {
                        this._children[e]._onWorldPositionScaleTransform();
                    }
                }
            }
        }, {
            key: "_onWorldPositionTransform",
            value: function _onWorldPositionTransform() {
                if (!this._getTransformFlag(De.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(De.TRANSFORM_WORLDPOSITION)) {
                    this._setTransformFlag(De.TRANSFORM_WORLDMATRIX | De.TRANSFORM_WORLDPOSITION, !0),
                        this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++) {
                        this._children[e]._onWorldPositionTransform();
                    }
                }
            }
        }, {
            key: "_onWorldRotationTransform",
            value: function _onWorldRotationTransform() {
                if (!this._getTransformFlag(De.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(De.TRANSFORM_WORLDQUATERNION) || !this._getTransformFlag(De.TRANSFORM_WORLDEULER)) {
                    this._setTransformFlag(De.TRANSFORM_WORLDMATRIX | De.TRANSFORM_WORLDQUATERNION | De.TRANSFORM_WORLDEULER, !0),
                        this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++) {
                        this._children[e]._onWorldPositionRotationTransform();
                    }
                }
            }
        }, {
            key: "_onWorldScaleTransform",
            value: function _onWorldScaleTransform() {
                if (!this._getTransformFlag(De.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(De.TRANSFORM_WORLDSCALE)) {
                    this._setTransformFlag(De.TRANSFORM_WORLDMATRIX | De.TRANSFORM_WORLDSCALE, !0),
                        this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++) {
                        this._children[e]._onWorldPositionScaleTransform();
                    }
                }
            }
        }, {
            key: "_onWorldTransform",
            value: function _onWorldTransform() {
                if (!(this._getTransformFlag(De.TRANSFORM_WORLDMATRIX) && this._getTransformFlag(De.TRANSFORM_WORLDPOSITION) && this._getTransformFlag(De.TRANSFORM_WORLDQUATERNION) && this._getTransformFlag(De.TRANSFORM_WORLDEULER) && this._getTransformFlag(De.TRANSFORM_WORLDSCALE))) {
                    this._setTransformFlag(De.TRANSFORM_WORLDMATRIX | De.TRANSFORM_WORLDPOSITION | De.TRANSFORM_WORLDQUATERNION | De.TRANSFORM_WORLDEULER | De.TRANSFORM_WORLDSCALE, !0),
                        this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++) {
                        this._children[e]._onWorldTransform();
                    }
                }
            }
        }, {
            key: "translate",
            value: function translate(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
                t ? (C.createFromQuaternion(this.localRotation, De._tempMatrix0), n.transformCoordinate(e, De._tempMatrix0, De._tempVector30),
                    n.add(this.localPosition, De._tempVector30, this._localPosition), this.localPosition = this._localPosition) : (n.add(this.position, e, this._position),
                    this.position = this._position);
            }
        }, {
            key: "rotate",
            value: function rotate(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
                var i;
                r ? i = e : (n.scale(e, Math.PI / 180, De._tempVector30), i = De._tempVector30),
                    f.createFromYawPitchRoll(i.y, i.x, i.z, De._tempQuaternion0), t ? (f.multiply(this._localRotation, De._tempQuaternion0, this._localRotation),
                        this.localRotation = this._localRotation) : (f.multiply(De._tempQuaternion0, this.rotation, this._rotation),
                        this.rotation = this._rotation);
            }
        }, {
            key: "getForward",
            value: function getForward(e) {
                var t = this.worldMatrix.elements;
                e.x = -t[8], e.y = -t[9], e.z = -t[10];
            }
        }, {
            key: "getUp",
            value: function getUp(e) {
                var t = this.worldMatrix.elements;
                e.x = t[4], e.y = t[5], e.z = t[6];
            }
        }, {
            key: "getRight",
            value: function getRight(e) {
                var t = this.worldMatrix.elements;
                e.x = t[0], e.y = t[1], e.z = t[2];
            }
        }, {
            key: "lookAt",
            value: function lookAt(e, t) {
                var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
                var a;
                if (i) {
                    if (a = this._localPosition, Math.abs(a.x - e.x) < r.zeroTolerance && Math.abs(a.y - e.y) < r.zeroTolerance && Math.abs(a.z - e.z) < r.zeroTolerance) return;
                    f.lookAt(this._localPosition, e, t, this._localRotation), this._localRotation.invert(this._localRotation),
                        this.localRotation = this._localRotation;
                } else {
                    var n = this.position;
                    if (a = n, Math.abs(a.x - e.x) < r.zeroTolerance && Math.abs(a.y - e.y) < r.zeroTolerance && Math.abs(a.z - e.z) < r.zeroTolerance) return;
                    f.lookAt(n, e, t, this._rotation), this._rotation.invert(this._rotation), this.rotation = this._rotation;
                }
            }
        }, {
            key: "getWorldLossyScale",
            value: function getWorldLossyScale() {
                if (this._getTransformFlag(De.TRANSFORM_WORLDSCALE)) {
                    if (null !== this._parent) {
                        var e = this._getScaleMatrix().elements;
                        this._scale.x = e[0], this._scale.y = e[4], this._scale.z = e[8];
                    } else this._localScale.cloneTo(this._scale);
                    this._setTransformFlag(De.TRANSFORM_WORLDSCALE, !1);
                }
                return this._scale;
            }
        }, {
            key: "setWorldLossyScale",
            value: function setWorldLossyScale(e) {
                if (null !== this._parent) {
                    var t = De._tempMatrix3x33,
                        r = De._tempMatrix3x33,
                        i = r.elements,
                        a = this._parent._getScaleMatrix();
                    a.invert(a), m.createFromScaling(e, t), m.multiply(a, t, r), this._localScale.x = i[0],
                        this._localScale.y = i[4], this._localScale.z = i[8];
                } else e.cloneTo(this._localScale);
                this.localScale = this._localScale, this._scale !== e && e.cloneTo(this._scale),
                    this._setTransformFlag(De.TRANSFORM_WORLDSCALE, !1);
            }
        }, {
            key: "_isFrontFaceInvert",
            get: function get() {
                var e = this.getWorldLossyScale(),
                    t = e.x < 0;
                return e.y < 0 && (t = !t), e.z < 0 && (t = !t), t;
            }
        }, {
            key: "owner",
            get: function get() {
                return this._owner;
            }
        }, {
            key: "worldNeedUpdate",
            get: function get() {
                return this._getTransformFlag(De.TRANSFORM_WORLDMATRIX);
            }
        }, {
            key: "localPositionX",
            get: function get() {
                return this._localPosition.x;
            },
            set: function set(e) {
                this._localPosition.x = e, this.localPosition = this._localPosition;
            }
        }, {
            key: "localPositionY",
            get: function get() {
                return this._localPosition.y;
            },
            set: function set(e) {
                this._localPosition.y = e, this.localPosition = this._localPosition;
            }
        }, {
            key: "localPositionZ",
            get: function get() {
                return this._localPosition.z;
            },
            set: function set(e) {
                this._localPosition.z = e, this.localPosition = this._localPosition;
            }
        }, {
            key: "localPosition",
            get: function get() {
                return this._localPosition;
            },
            set: function set(e) {
                this._localPosition !== e && e.cloneTo(this._localPosition), this._setTransformFlag(De.TRANSFORM_LOCALMATRIX, !0),
                    this._onWorldPositionTransform();
            }
        }, {
            key: "localRotationX",
            get: function get() {
                return this.localRotation.x;
            },
            set: function set(e) {
                this._localRotation.x = e, this.localRotation = this._localRotation;
            }
        }, {
            key: "localRotationY",
            get: function get() {
                return this.localRotation.y;
            },
            set: function set(e) {
                this._localRotation.y = e, this.localRotation = this._localRotation;
            }
        }, {
            key: "localRotationZ",
            get: function get() {
                return this.localRotation.z;
            },
            set: function set(e) {
                this._localRotation.z = e, this.localRotation = this._localRotation;
            }
        }, {
            key: "localRotationW",
            get: function get() {
                return this.localRotation.w;
            },
            set: function set(e) {
                this._localRotation.w = e, this.localRotation = this._localRotation;
            }
        }, {
            key: "localRotation",
            get: function get() {
                if (this._getTransformFlag(De.TRANSFORM_LOCALQUATERNION)) {
                    var e = this._localRotationEuler;
                    f.createFromYawPitchRoll(e.y / De._angleToRandin, e.x / De._angleToRandin, e.z / De._angleToRandin, this._localRotation),
                        this._setTransformFlag(De.TRANSFORM_LOCALQUATERNION, !1);
                }
                return this._localRotation;
            },
            set: function set(e) {
                this._localRotation !== e && e.cloneTo(this._localRotation), this._localRotation.normalize(this._localRotation),
                    this._setTransformFlag(De.TRANSFORM_LOCALEULER | De.TRANSFORM_LOCALMATRIX, !0),
                    this._setTransformFlag(De.TRANSFORM_LOCALQUATERNION, !1), this._onWorldRotationTransform();
            }
        }, {
            key: "localScaleX",
            get: function get() {
                return this._localScale.x;
            },
            set: function set(e) {
                this._localScale.x = e, this.localScale = this._localScale;
            }
        }, {
            key: "localScaleY",
            get: function get() {
                return this._localScale.y;
            },
            set: function set(e) {
                this._localScale.y = e, this.localScale = this._localScale;
            }
        }, {
            key: "localScaleZ",
            get: function get() {
                return this._localScale.z;
            },
            set: function set(e) {
                this._localScale.z = e, this.localScale = this._localScale;
            }
        }, {
            key: "localScale",
            get: function get() {
                return this._localScale;
            },
            set: function set(e) {
                this._localScale !== e && e.cloneTo(this._localScale), this._setTransformFlag(De.TRANSFORM_LOCALMATRIX, !0),
                    this._onWorldScaleTransform();
            }
        }, {
            key: "localRotationEulerX",
            get: function get() {
                return this.localRotationEuler.x;
            },
            set: function set(e) {
                this._localRotationEuler.x = e, this.localRotationEuler = this._localRotationEuler;
            }
        }, {
            key: "localRotationEulerY",
            get: function get() {
                return this.localRotationEuler.y;
            },
            set: function set(e) {
                this._localRotationEuler.y = e, this.localRotationEuler = this._localRotationEuler;
            }
        }, {
            key: "localRotationEulerZ",
            get: function get() {
                return this.localRotationEuler.z;
            },
            set: function set(e) {
                this._localRotationEuler.z = e, this.localRotationEuler = this._localRotationEuler;
            }
        }, {
            key: "localRotationEuler",
            get: function get() {
                if (this._getTransformFlag(De.TRANSFORM_LOCALEULER)) {
                    this._localRotation.getYawPitchRoll(De._tempVector30);
                    var e = De._tempVector30,
                        t = this._localRotationEuler;
                    t.x = e.y * De._angleToRandin, t.y = e.x * De._angleToRandin, t.z = e.z * De._angleToRandin,
                        this._setTransformFlag(De.TRANSFORM_LOCALEULER, !1);
                }
                return this._localRotationEuler;
            },
            set: function set(e) {
                this._localRotationEuler !== e && e.cloneTo(this._localRotationEuler), this._setTransformFlag(De.TRANSFORM_LOCALEULER, !1),
                    this._setTransformFlag(De.TRANSFORM_LOCALQUATERNION | De.TRANSFORM_LOCALMATRIX, !0),
                    this._onWorldRotationTransform();
            }
        }, {
            key: "localMatrix",
            get: function get() {
                return this._getTransformFlag(De.TRANSFORM_LOCALMATRIX) && (C.createAffineTransformation(this._localPosition, this.localRotation, this._localScale, this._localMatrix),
                    this._setTransformFlag(De.TRANSFORM_LOCALMATRIX, !1)), this._localMatrix;
            },
            set: function set(e) {
                this._localMatrix !== e && e.cloneTo(this._localMatrix), this._localMatrix.decomposeTransRotScale(this._localPosition, this._localRotation, this._localScale),
                    this._setTransformFlag(De.TRANSFORM_LOCALEULER, !0), this._setTransformFlag(De.TRANSFORM_LOCALMATRIX, !1),
                    this._onWorldTransform();
            }
        }, {
            key: "position",
            get: function get() {
                if (this._getTransformFlag(De.TRANSFORM_WORLDPOSITION)) {
                    if (null != this._parent) {
                        var e = this.worldMatrix.elements;
                        this._position.x = e[12], this._position.y = e[13], this._position.z = e[14];
                    } else this._localPosition.cloneTo(this._position);
                    this._setTransformFlag(De.TRANSFORM_WORLDPOSITION, !1);
                }
                return this._position;
            },
            set: function set(e) {
                if (null != this._parent) {
                    var t = De._tempMatrix0;
                    this._parent.worldMatrix.invert(t), n.transformCoordinate(e, t, this._localPosition);
                } else e.cloneTo(this._localPosition);
                this.localPosition = this._localPosition, this._position !== e && e.cloneTo(this._position),
                    this._setTransformFlag(De.TRANSFORM_WORLDPOSITION, !1);
            }
        }, {
            key: "rotation",
            get: function get() {
                return this._getTransformFlag(De.TRANSFORM_WORLDQUATERNION) && (null != this._parent ? f.multiply(this._parent.rotation, this.localRotation, this._rotation) : this.localRotation.cloneTo(this._rotation),
                    this._setTransformFlag(De.TRANSFORM_WORLDQUATERNION, !1)), this._rotation;
            },
            set: function set(e) {
                null != this._parent ? (this._parent.rotation.invert(De._tempQuaternion0), f.multiply(De._tempQuaternion0, e, this._localRotation)) : e.cloneTo(this._localRotation),
                    this.localRotation = this._localRotation, e !== this._rotation && e.cloneTo(this._rotation),
                    this._setTransformFlag(De.TRANSFORM_WORLDQUATERNION, !1);
            }
        }, {
            key: "rotationEuler",
            get: function get() {
                if (this._getTransformFlag(De.TRANSFORM_WORLDEULER)) {
                    this.rotation.getYawPitchRoll(De._tempVector30);
                    var e = De._tempVector30,
                        t = this._rotationEuler;
                    t.x = e.y * De._angleToRandin, t.y = e.x * De._angleToRandin, t.z = e.z * De._angleToRandin,
                        this._setTransformFlag(De.TRANSFORM_WORLDEULER, !1);
                }
                return this._rotationEuler;
            },
            set: function set(e) {
                f.createFromYawPitchRoll(e.y / De._angleToRandin, e.x / De._angleToRandin, e.z / De._angleToRandin, this._rotation),
                    this.rotation = this._rotation, this._rotationEuler !== e && e.cloneTo(this._rotationEuler),
                    this._setTransformFlag(De.TRANSFORM_WORLDEULER, !1);
            }
        }, {
            key: "worldMatrix",
            get: function get() {
                return this._getTransformFlag(De.TRANSFORM_WORLDMATRIX) && (null != this._parent ? C.multiply(this._parent.worldMatrix, this.localMatrix, this._worldMatrix) : this.localMatrix.cloneTo(this._worldMatrix),
                    this._setTransformFlag(De.TRANSFORM_WORLDMATRIX, !1)), this._worldMatrix;
            },
            set: function set(e) {
                null === this._parent ? e.cloneTo(this._localMatrix) : (this._parent.worldMatrix.invert(this._localMatrix),
                        C.multiply(this._localMatrix, e, this._localMatrix)), this.localMatrix = this._localMatrix,
                    this._worldMatrix !== e && e.cloneTo(this._worldMatrix), this._setTransformFlag(De.TRANSFORM_WORLDMATRIX, !1);
            }
        }, {
            key: "scale",
            get: function get() {
                return console.warn("Transfrm3D: discard function,please use getWorldLossyScale instead."),
                    this.getWorldLossyScale();
            },
            set: function set(e) {
                console.warn("Transfrm3D: discard function,please use setWorldLossyScale instead."),
                    this.setWorldLossyScale(e);
            }
        }]);
        return De;
    }(t.EventDispatcher);
    De._tempVector30 = new n(), De._tempQuaternion0 = new f(), De._tempMatrix0 = new C(),
        De._tempMatrix3x30 = new m(), De._tempMatrix3x31 = new m(), De._tempMatrix3x32 = new m(),
        De._tempMatrix3x33 = new m(), De.TRANSFORM_LOCALQUATERNION = 1, De.TRANSFORM_LOCALEULER = 2,
        De.TRANSFORM_LOCALMATRIX = 4, De.TRANSFORM_WORLDPOSITION = 8, De.TRANSFORM_WORLDQUATERNION = 16,
        De.TRANSFORM_WORLDSCALE = 32, De.TRANSFORM_WORLDMATRIX = 64, De.TRANSFORM_WORLDEULER = 128,
        De._angleToRandin = 180 / Math.PI;
    var Le = /* */ function(_t$Node) {
        _inherits(Le, _t$Node);

        function Le() {
            var _this22;
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
            _classCallCheck(this, Le);
            _this22 = _possibleConstructorReturn(this, _getPrototypeOf(Le).call(this)), _this22._needProcessCollisions = !1,
                _this22._needProcessTriggers = !1, _this22._id = ++Le._uniqueIDCounter, _this22._transform = new De(_assertThisInitialized(_this22)),
                _this22._isStatic = t, _this22.layer = 0, _this22.name = e || "New Sprite3D";
            return _this22;
        }
        _createClass(Le, [{
            key: "_setCreateURL",
            value: function _setCreateURL(e) {
                this._url = t.URL.formatURL(e);
            }
        }, {
            key: "_changeAnimatorsToLinkSprite3D",
            value: function _changeAnimatorsToLinkSprite3D(e, t, r) {
                var i = this.getComponent(b);
                if (i && (i.avatar || e._changeAnimatorToLinkSprite3DNoAvatar(i, t, r)), this._parent && this._parent instanceof Le) {
                    r.unshift(this._parent.name);
                    var a = this._parent;
                    a._hierarchyAnimator && a._changeAnimatorsToLinkSprite3D(e, t, r);
                }
            }
        }, {
            key: "_setHierarchyAnimator",
            value: function _setHierarchyAnimator(e, t) {
                this._changeHierarchyAnimator(e), this._changeAnimatorAvatar(e.avatar);
                for (var r = 0, i = this._children.length; r < i; r++) {
                    var a = this._children[r];
                    a._hierarchyAnimator == t && a._setHierarchyAnimator(e, t);
                }
            }
        }, {
            key: "_clearHierarchyAnimator",
            value: function _clearHierarchyAnimator(e, t) {
                this._changeHierarchyAnimator(t), this._changeAnimatorAvatar(t ? t.avatar : null);
                for (var r = 0, i = this._children.length; r < i; r++) {
                    var a = this._children[r];
                    a._hierarchyAnimator == e && a._clearHierarchyAnimator(e, t);
                }
            }
        }, {
            key: "_changeHierarchyAnimatorAvatar",
            value: function _changeHierarchyAnimatorAvatar(e, t) {
                this._changeAnimatorAvatar(t);
                for (var r = 0, i = this._children.length; r < i; r++) {
                    var a = this._children[r];
                    a._hierarchyAnimator == e && a._changeHierarchyAnimatorAvatar(e, t);
                }
            }
        }, {
            key: "_changeAnimatorToLinkSprite3DNoAvatar",
            value: function _changeAnimatorToLinkSprite3DNoAvatar(e, t, r) {
                e._handleSpriteOwnersBySprite(t, r, this);
                for (var i = 0, a = this._children.length; i < a; i++) {
                    var n = this._children[i],
                        s = r.length;
                    r.push(n.name), n._changeAnimatorToLinkSprite3DNoAvatar(e, t, r), r.splice(s, 1);
                }
            }
        }, {
            key: "_changeHierarchyAnimator",
            value: function _changeHierarchyAnimator(e) {
                this._hierarchyAnimator = e;
            }
        }, {
            key: "_changeAnimatorAvatar",
            value: function _changeAnimatorAvatar(e) {}
        }, {
            key: "_onAdded",
            value: function _onAdded() {
                if (this._parent instanceof Le) {
                    var e = this._parent;
                    this.transform._setParent(e.transform), e._hierarchyAnimator && (!this._hierarchyAnimator && this._setHierarchyAnimator(e._hierarchyAnimator, null),
                        e._changeAnimatorsToLinkSprite3D(this, !0, [this.name]));
                }
                _get(_getPrototypeOf(Le.prototype), "_onAdded", this).call(this);
            }
        }, {
            key: "_onRemoved",
            value: function _onRemoved() {
                if (_get(_getPrototypeOf(Le.prototype), "_onRemoved", this).call(this), this._parent instanceof Le) {
                    var e = this._parent;
                    this.transform._setParent(null), e._hierarchyAnimator && (this._hierarchyAnimator == e._hierarchyAnimator && this._clearHierarchyAnimator(e._hierarchyAnimator, null),
                        e._changeAnimatorsToLinkSprite3D(this, !1, [this.name]));
                }
            }
        }, {
            key: "_parse",
            value: function _parse(e, t) {
                if (void 0 !== e.isStatic && (this._isStatic = e.isStatic), void 0 !== e.active && (this.active = e.active),
                    null != e.name && (this.name = e.name), void 0 !== e.position) {
                    var r = this.transform.localPosition;
                    r.fromArray(e.position), this.transform.localPosition = r;
                }
                if (void 0 !== e.rotationEuler) {
                    var i = this.transform.localRotationEuler;
                    i.fromArray(e.rotationEuler), this.transform.localRotationEuler = i;
                }
                if (void 0 !== e.rotation) {
                    var a = this.transform.localRotation;
                    a.fromArray(e.rotation), this.transform.localRotation = a;
                }
                if (void 0 !== e.scale) {
                    var n = this.transform.localScale;
                    n.fromArray(e.scale), this.transform.localScale = n;
                }
                null != e.layer && (this.layer = e.layer);
            }
        }, {
            key: "_cloneTo",
            value: function _cloneTo(e, t, r) {
                if (this.destroyed) throw new Error("Sprite3D: Can't be cloned if the Sprite3D has destroyed.");
                var i = e,
                    a = this._transform,
                    n = i._transform;
                i.name = this.name, i.destroyed = this.destroyed, i.active = this.active, n.localPosition = a.localPosition,
                    n.localRotation = a.localRotation, n.localScale = a.localScale, i._isStatic = this._isStatic,
                    i.layer = this.layer, _get(_getPrototypeOf(Le.prototype), "_cloneTo", this).call(this, i, t, r);
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = Le._createSprite3DInstance(this);
                return Le._parseSprite3DInstance(this, e, this, e), e;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
                this.destroyed || (_get(_getPrototypeOf(Le.prototype), "destroy", this).call(this, e),
                    this._transform = null, this._scripts = null, this._url && t.Loader.clearRes(this._url));
            }
        }, {
            key: "_create",
            value: function _create() {
                return new Le();
            }
        }, {
            key: "id",
            get: function get() {
                return this._id;
            }
        }, {
            key: "layer",
            get: function get() {
                return this._layer;
            },
            set: function set(e) {
                if (this._layer !== e) {
                    if (!(e >= 0 && e <= 30)) throw new Error("Layer value must be 0-30.");
                    this._layer = e;
                }
            }
        }, {
            key: "url",
            get: function get() {
                return this._url;
            }
        }, {
            key: "isStatic",
            get: function get() {
                return this._isStatic;
            }
        }, {
            key: "transform",
            get: function get() {
                return this._transform;
            }
        }], [{
            key: "__init__",
            value: function __init__() {}
        }, {
            key: "instantiate",
            value: function instantiate(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
                var n = e.clone();
                t && t.addChild(n);
                var s = n.transform;
                if (r) {
                    var o = s.worldMatrix;
                    e.transform.worldMatrix.cloneTo(o), s.worldMatrix = o;
                } else i && (s.position = i), a && (s.rotation = a);
                return n;
            }
        }, {
            key: "load",
            value: function load(e, r) {
                t.Laya.loader.create(e, r, null, Le.HIERARCHY);
            }
        }, {
            key: "_createSprite3DInstance",
            value: function _createSprite3DInstance(e) {
                for (var t = e._create(), r = e._children, i = 0, a = r.length; i < a; i++) {
                    var n = Le._createSprite3DInstance(r[i]);
                    t.addChild(n);
                }
                return t;
            }
        }, {
            key: "_parseSprite3DInstance",
            value: function _parseSprite3DInstance(e, t, r, i) {
                for (var a = r._children, n = i._children, s = 0, o = a.length; s < o; s++) {
                    Le._parseSprite3DInstance(e, t, a[s], n[s]);
                }
                r._cloneTo(i, e, t);
            }
        }]);
        return Le;
    }(t.Node);
    Le.HIERARCHY = "HIERARCHY", Le.WORLDMATRIX = H.propertyNameToID("u_WorldMat"), Le.MVPMATRIX = H.propertyNameToID("u_MvpMatrix"),
        Le._uniqueIDCounter = 0;
    var ye = /* */ function(_Le) {
        _inherits(ye, _Le);

        function ye(e) {
            _classCallCheck(this, ye);
            return _possibleConstructorReturn(this, _getPrototypeOf(ye).call(this, e));
        }
        _createClass(ye, [{
            key: "_onInActive",
            value: function _onInActive() {
                _get(_getPrototypeOf(ye.prototype), "_onInActive", this).call(this), this._scene._removeRenderObject(this._render);
            }
        }, {
            key: "_onActive",
            value: function _onActive() {
                _get(_getPrototypeOf(ye.prototype), "_onActive", this).call(this), this._scene._addRenderObject(this._render);
            }
        }, {
            key: "_onActiveInScene",
            value: function _onActiveInScene() {
                if (_get(_getPrototypeOf(ye.prototype), "_onActiveInScene", this).call(this), _.Laya3D._editerEnvironment) {
                    var e = this._scene,
                        t = new a();
                    e._allotPickColorByID(this.id, t), e._pickIdToSprite[this.id] = this, this._render._shaderValues.setVector(ye.PICKCOLOR, t);
                }
            }
        }, {
            key: "_addToInitStaticBatchManager",
            value: function _addToInitStaticBatchManager() {}
        }, {
            key: "_setBelongScene",
            value: function _setBelongScene(e) {
                _get(_getPrototypeOf(ye.prototype), "_setBelongScene", this).call(this, e), this._render._setBelongScene(e);
            }
        }, {
            key: "_setUnBelongScene",
            value: function _setUnBelongScene() {
                this._render._shaderValues.removeDefine(ye.SAHDERDEFINE_LIGHTMAP), _get(_getPrototypeOf(ye.prototype), "_setUnBelongScene", this).call(this);
            }
        }, {
            key: "_changeHierarchyAnimator",
            value: function _changeHierarchyAnimator(e) {
                if (this._hierarchyAnimator) {
                    var t = this._hierarchyAnimator._renderableSprites;
                    t.splice(t.indexOf(this), 1);
                }
                e && e._renderableSprites.push(this), _get(_getPrototypeOf(ye.prototype), "_changeHierarchyAnimator", this).call(this, e);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
                _get(_getPrototypeOf(ye.prototype), "destroy", this).call(this, e), this._render._destroy(),
                    this._render = null;
            }
        }, {
            key: "_create",
            value: function _create() {
                return new ye(this.name);
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                ye.SHADERDEFINE_RECEIVE_SHADOW = H.getDefineByName("RECEIVESHADOW"), ye.SAHDERDEFINE_LIGHTMAP = H.getDefineByName("LIGHTMAP");
            }
        }]);
        return ye;
    }(Le);
    ye.LIGHTMAPSCALEOFFSET = H.propertyNameToID("u_LightmapScaleOffset"), ye.LIGHTMAP = H.propertyNameToID("u_LightMap"),
        ye.PICKCOLOR = H.propertyNameToID("u_PickColor");
    var Ce = /* */ function() {
        function Ce() {
            _classCallCheck(this, Ce);
            this._initBatchSprites = [], this._staticBatches = {}, this._batchRenderElementPoolIndex = 0,
                this._batchRenderElementPool = [];
        }
        _createClass(Ce, [{
            key: "_partition",
            value: function _partition(e, t, r) {
                for (var i = e[Math.floor((r + t) / 2)]; t <= r;) {
                    for (; this._compare(e[t], i) < 0;) {
                        t++;
                    }
                    for (; this._compare(e[r], i) > 0;) {
                        r--;
                    }
                    if (t < r) {
                        var a = e[t];
                        e[t] = e[r], e[r] = a, t++, r--;
                    } else if (t === r) {
                        t++;
                        break;
                    }
                }
                return t;
            }
        }, {
            key: "_quickSort",
            value: function _quickSort(e, t, r) {
                if (e.length > 1) {
                    var i = this._partition(e, t, r),
                        a = i - 1;
                    t < a && this._quickSort(e, t, a), i < r && this._quickSort(e, i, r);
                }
            }
        }, {
            key: "_compare",
            value: function _compare(e, t) {
                throw "StaticBatch:must override this function.";
            }
        }, {
            key: "_initStaticBatchs",
            value: function _initStaticBatchs(e) {
                throw "StaticBatch:must override this function.";
            }
        }, {
            key: "_getBatchRenderElementFromPool",
            value: function _getBatchRenderElementFromPool() {
                throw "StaticBatch:must override this function.";
            }
        }, {
            key: "_addBatchSprite",
            value: function _addBatchSprite(e) {
                this._initBatchSprites.push(e);
            }
        }, {
            key: "_clear",
            value: function _clear() {
                this._batchRenderElementPoolIndex = 0;
            }
        }, {
            key: "_garbageCollection",
            value: function _garbageCollection() {
                throw "StaticBatchManager: must override it.";
            }
        }, {
            key: "dispose",
            value: function dispose() {
                this._staticBatches = null;
            }
        }], [{
            key: "_addToStaticBatchQueue",
            value: function _addToStaticBatchQueue(e, t) {
                e instanceof ye && t.push(e);
                for (var r = 0, i = e.numChildren; r < i; r++) {
                    Ce._addToStaticBatchQueue(e._children[r], t);
                }
            }
        }, {
            key: "_registerManager",
            value: function _registerManager(e) {
                Ce._managers.push(e);
            }
        }, {
            key: "combine",
            value: function combine(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                t || (t = [], e && Ce._addToStaticBatchQueue(e, t));
                var r = t.length;
                if (r > 0) {
                    for (var i = 0; i < r; i++) {
                        var a = t[i];
                        a.destroyed || (a._render._isPartOfStaticBatch ? console.warn("StaticBatchManager: Sprite " + a.name + " has a part of Static Batch,it will be ignore.") : a._addToInitStaticBatchManager());
                    }
                    for (var n = 0, s = Ce._managers.length; n < s; n++) {
                        Ce._managers[n]._initStaticBatchs(e);
                    }
                }
            }
        }]);
        return Ce;
    }();
    Ce._managers = [];
    var Oe = /* */ function() {
        function Oe() {
            _classCallCheck(this, Oe);
        }
        _createClass(Oe, null, [{
            key: "__init__",
            value: function __init__() {
                t.Render.supportWebGLPlusCulling && (Oe._cullingBufferLength = 0, Oe._cullingBuffer = new Float32Array(4096));
            }
        }, {
            key: "_drawTraversalCullingBound",
            value: function _drawTraversalCullingBound(e, t) {
                e.length;
                for (var r = e.elements, i = 0, a = e.length; i < a; i++) {
                    var n = Oe._tempColor0;
                    n.r = 0, n.g = 1, n.b = 0, n.a = 1, I._drawBound(t, r[i].bounds._getBoundBox(), n);
                }
            }
        }, {
            key: "_traversalCulling",
            value: function _traversalCulling(e, r, i, a, s, o, l) {
                for (var _ = a.elements, h = e.boundFrustum, c = e._transform.position, d = t.Stat.loopCount, u = 0, m = a.length; u < m; u++) {
                    var f = _[u];
                    if ((l ? f._castShadow && f._enable : e._isLayerVisible(f._owner._layer) && f._enable) && (t.Stat.frustumCulling++, !e.useOcclusionCulling || f._needRender(h, i))) {
                        f._renderMark = d, f._distanceForSort = n.distance(f.bounds.getCenter(), c);
                        for (var E = f._renderElements, T = 0, p = E.length; T < p; T++) {
                            E[T]._update(r, i, s, o);
                        }
                    }
                }
            }
        }, {
            key: "renderObjectCulling",
            value: function renderObjectCulling(e, t, r, i, a, n) {
                var s, o, l = t._opaqueQueue,
                    _ = t._transparentQueue,
                    h = t._renders;
                l.clear(), _.clear();
                var c = Ce._managers;
                for (s = 0, o = c.length; s < o; s++) {
                    c[s]._clear();
                }
                var d = Me._managers;
                for (s = 0, o = d.length; s < o; s++) {
                    d[s]._clear();
                }
                var u = t._octree;
                if (u && (u.updateMotionObjects(), u.shrinkRootIfPossible(), u.getCollidingWithFrustum(r, i, a, n)),
                    Oe._traversalCulling(e, t, r, h, i, a, n), Oe.debugFrustumCulling) {
                    var m = t._debugTool;
                    m.clear(), u && (u.drawAllBounds(m), u.drawAllObjects(m)), Oe._drawTraversalCullingBound(h, m);
                }
                var f = l.elements.length;
                f > 0 && l._quickSort(0, f - 1), (f = _.elements.length) > 0 && _._quickSort(0, f - 1);
            }
        }, {
            key: "renderObjectCullingNative",
            value: function renderObjectCullingNative(e, r, i, a, s, o) {
                var l, _, h, c, d = r._opaqueQueue,
                    u = r._transparentQueue;
                d.clear(), u.clear();
                var m = Ce._managers;
                for (l = 0, _ = m.length; l < _; l++) {
                    m[l]._clear();
                }
                var f = Me._managers;
                for (l = 0, _ = f.length; l < _; l++) {
                    f[l]._clear();
                }
                var E = a.length,
                    T = a.elements;
                for (l = 0; l < E; l++) {
                    T[l].bounds, T[l]._updateForNative && T[l]._updateForNative(i);
                }
                e.boundFrustum;
                Oe.cullingNative(e._boundFrustumBuffer, Oe._cullingBuffer, r._cullingBufferIndices, E, r._cullingBufferResult);
                var p = t.Stat.loopCount,
                    g = i.camera._transform.position;
                for (l = 0; l < E; l++) {
                    var S = T[l];
                    if (!e.useOcclusionCulling || e._isLayerVisible(S._owner._layer) && S._enable && r._cullingBufferResult[l]) {
                        S._renderMark = p, S._distanceForSort = n.distance(S.bounds.getCenter(), g);
                        var R = S._renderElements;
                        for (h = 0, c = R.length; h < c; h++) {
                            R[h]._update(r, i, s, o);
                        }
                    }
                }
                var v = d.elements.length;
                v > 0 && d._quickSort(0, v - 1), (v = u.elements.length) > 0 && u._quickSort(0, v - 1);
            }
        }, {
            key: "cullingNative",
            value: function cullingNative(e, r, i, a, n) {
                return t.LayaGL.instance.culling(e, r, i, a, n);
            }
        }]);
        return Oe;
    }();
    Oe._tempVector3 = new n(), Oe._tempColor0 = new Ae(), Oe.debugFrustumCulling = !1;
    var Ne = function Ne() {
        _classCallCheck(this, Ne);
        this.updateMark = -1, this.indexInList = -1, this.batched = !1;
    };
    var Pe = /* */ function() {
        function Pe() {
            _classCallCheck(this, Pe);
            this._destroyed = !1;
        }
        _createClass(Pe, [{
            key: "_getType",
            value: function _getType() {
                throw "GeometryElement:must override it.";
            }
        }, {
            key: "_prepareRender",
            value: function _prepareRender(e) {
                return !0;
            }
        }, {
            key: "_render",
            value: function _render(e) {
                throw "GeometryElement:must override it.";
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._destroyed || (this._destroyed = !0);
            }
        }, {
            key: "destroyed",
            get: function get() {
                return this._destroyed;
            }
        }]);
        return Pe;
    }();
    Pe._typeCounter = 0;
    var be = /* */ function(_t$Buffer) {
        _inherits(be, _t$Buffer);

        function be(e, r) {
            var _this23;
            var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
            _classCallCheck(this, be);
            _this23 = _possibleConstructorReturn(this, _getPrototypeOf(be).call(this)), _this23._vertexDeclaration = null,
                _this23._float32Reader = null;
            var a = t.LayaGL.instance;
            _this23._bufferUsage = r, _this23._bufferType = a.ARRAY_BUFFER, _this23._canRead = i,
                _this23._byteLength = e, _this23.bind(), a.bufferData(_this23._bufferType, _this23._byteLength, _this23._bufferUsage),
                i && (_this23._buffer = new Uint8Array(e), _this23._float32Reader = new Float32Array(_this23._buffer.buffer));
            return _this23;
        }
        _createClass(be, [{
            key: "bind",
            value: function bind() {
                if (t.Buffer._bindedVertexBuffer !== this._glBuffer) {
                    var e = t.LayaGL.instance;
                    return e.bindBuffer(e.ARRAY_BUFFER, this._glBuffer), t.Buffer._bindedVertexBuffer = this._glBuffer, !0;
                }
                return !1;
            }
        }, {
            key: "setData",
            value: function setData(e) {
                var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Number.MAX_SAFE_INTEGER;
                if (this.bind(), 0 !== i || a !== Number.MAX_SAFE_INTEGER) {
                    var n = new Uint8Array(e, i, a);
                    t.LayaGL.instance.bufferSubData(this._bufferType, r, n), this._canRead && this._buffer.set(n, r);
                } else t.LayaGL.instance.bufferSubData(this._bufferType, r, e), this._canRead && this._buffer.set(new Uint8Array(e), r);
            }
        }, {
            key: "getUint8Data",
            value: function getUint8Data() {
                if (this._canRead) return this._buffer;
                throw new Error("Can't read data from VertexBuffer with only write flag!");
            }
        }, {
            key: "getFloat32Data",
            value: function getFloat32Data() {
                if (this._canRead) return this._float32Reader;
                throw new Error("Can't read data from VertexBuffer with only write flag!");
            }
        }, {
            key: "markAsUnreadbale",
            value: function markAsUnreadbale() {
                this._canRead = !1, this._buffer = null, this._float32Reader = null;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                _get(_getPrototypeOf(be.prototype), "destroy", this).call(this), this._buffer = null,
                    this._float32Reader = null, this._vertexDeclaration = null;
            }
        }, {
            key: "vertexDeclaration",
            get: function get() {
                return this._vertexDeclaration;
            },
            set: function set(e) {
                this._vertexDeclaration = e;
            }
        }, {
            key: "canRead",
            get: function get() {
                return this._canRead;
            }
        }]);
        return be;
    }(t.Buffer);
    be.DATATYPE_FLOAT32ARRAY = 0, be.DATATYPE_UINT8ARRAY = 1;
    var Ve = /* */ function(_Pe) {
        _inherits(Ve, _Pe);

        function Ve() {
            var _this24;
            _classCallCheck(this, Ve);
            _this24 = _possibleConstructorReturn(this, _getPrototypeOf(Ve).call(this)), _this24.maxInstanceCount = 1024,
                _this24.instanceWorldMatrixData = new Float32Array(16 * _this24.maxInstanceCount),
                _this24.instanceMVPMatrixData = new Float32Array(16 * _this24.maxInstanceCount);
            var e = t.LayaGL.instance;
            _this24.instanceWorldMatrixBuffer = new be(4 * _this24.instanceWorldMatrixData.length, e.DYNAMIC_DRAW),
                _this24.instanceMVPMatrixBuffer = new be(4 * _this24.instanceMVPMatrixData.length, e.DYNAMIC_DRAW),
                _this24.instanceWorldMatrixBuffer.vertexDeclaration = ce.instanceWorldMatrixDeclaration,
                _this24.instanceMVPMatrixBuffer.vertexDeclaration = ce.instanceMVPMatrixDeclaration;
            return _this24;
        }
        _createClass(Ve, [{
            key: "_render",
            value: function _render(e) {
                var r = t.LayaGL.instance,
                    i = e.renderElement,
                    a = i.instanceSubMesh,
                    n = i.instanceBatchElementList.length,
                    s = a._indexCount;
                a._mesh._instanceBufferState.bind(), t.LayaGL.layaGPUInstance.drawElementsInstanced(r.TRIANGLES, s, r.UNSIGNED_SHORT, 2 * a._indexStart, n),
                    t.Stat.renderBatches++, t.Stat.savedRenderBatches += n - 1, t.Stat.trianglesFaces += s * n / 3;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                Ve.instance = new Ve();
            }
        }]);
        return Ve;
    }(Pe);
    var we = function we() {
        _classCallCheck(this, we);
        this.updateMark = -1, this.pointLightCount = 0, this.spotLightCount = 0, this.indices = [];
    };
    var Fe = /* */ function() {
        function Fe(e, t, r, a) {
            _classCallCheck(this, Fe);
            this._updateMark = 0, this._depthSliceParam = new i(), this._xSlices = e, this._ySlices = t,
                this._zSlices = r;
            var n = e * t,
                s = r * (1 + Math.ceil(a / 4));
            this._clusterTexture = I._createFloatTextureBuffer(n, s), this._clusterTexture.lock = !0,
                this._clusterPixels = new Float32Array(n * s * 4);
            for (var o = new Array(this._zSlices), l = 0; l < this._zSlices; l++) {
                o[l] = new Array(this._ySlices);
                for (var _ = 0; _ < this._ySlices; _++) {
                    o[l][_] = new Array(this._xSlices);
                    for (var h = 0; h < this._xSlices; h++) {
                        o[l][_][h] = new we();
                    }
                }
            }
            this._clusterDatas = o;
        }
        _createClass(Fe, [{
            key: "_insertSpotLightSphere",
            value: function _insertSpotLightSphere(e, t, r, i, a) {
                var s = Fe._tempVector35;
                s.x = a.x - e.x, s.y = a.y - e.y, s.z = a.z - e.z;
                var o = n.dot(s, s),
                    l = a.w;
                if (!(o > l * l)) return !1;
                var _ = n.dot(s, t);
                return !(Math.cos(i) * Math.sqrt(o - _ * _) - _ * Math.sin(i) > l || _ > l + r || _ < -l);
            }
        }, {
            key: "_placePointLightToClusters",
            value: function _placePointLightToClusters(e, t) {
                for (var r = this._clusterDatas, i = this._updateMark, a = t.zMin, n = t.zMax; a < n; a++) {
                    for (var s = t.yMin, o = t.yMax; s < o; s++) {
                        for (var l = t.xMin, _ = t.xMax; l < _; l++) {
                            var h = r[a][s][l];
                            h.updateMark != i && (h.pointLightCount = 0, h.spotLightCount = 0, h.updateMark = i);
                            var c = h.indices,
                                d = h.pointLightCount++;
                            d < c.length ? c[d] = e : c.push(e);
                        }
                    }
                }
            }
        }, {
            key: "_placeSpotLightToClusters",
            value: function _placeSpotLightToClusters(e, t) {
                for (var r = this._clusterDatas, i = this._updateMark, a = t.zMin, n = t.zMax; a < n; a++) {
                    for (var s = t.yMin, o = t.yMax; s < o; s++) {
                        for (var l = t.xMin, _ = t.xMax; l < _; l++) {
                            var h = r[a][s][l];
                            h.updateMark != i && (h.pointLightCount = 0, h.spotLightCount = 0, h.updateMark = i);
                            var c = h.indices,
                                d = h.pointLightCount + h.spotLightCount++;
                            d < c.length ? c[d] = e : c.push(e);
                        }
                    }
                }
            }
        }, {
            key: "_insertConePlane",
            value: function _insertConePlane(e, t, r, i, a) {
                var s = Fe._tempVector36,
                    o = Fe._tempVector37;
                n.cross(a, t, s), n.cross(s, t, o), n.normalize(o, o);
                var l = r * Math.tan(i),
                    _ = e.x + r * t.x + l * o.x,
                    h = e.y + r * t.y + l * o.y,
                    c = e.z + r * t.z + l * o.z;
                return _ * a.x + h * a.y + c * a.z <= 0 || e.x * a.x + e.y * a.y + e.z * a.z <= 0;
            }
        }, {
            key: "_shrinkSphereLightZPerspective",
            value: function _shrinkSphereLightZPerspective(e, t, r, i, a) {
                var n = r.z,
                    s = n - i,
                    o = n + i;
                if (s > t || o <= e) return !1;
                var l = this._depthSliceParam;
                return a.zMin = Math.floor(Math.log2(Math.max(s, e)) * l.x - l.y), a.zMax = Math.min(Math.ceil(Math.log2(o) * l.x - l.y), this._zSlices), !0;
            }
        }, {
            key: "_shrinkSpotLightZPerspective",
            value: function _shrinkSpotLightZPerspective(e, t, r, i, a, n, s) {
                var o = i.x,
                    l = i.y,
                    _ = i.z,
                    h = Math.tan(n) * a,
                    c = r.x,
                    d = r.y,
                    u = r.z,
                    m = o - c,
                    f = l - d,
                    E = _ - u,
                    T = m * m + f * f + E * E,
                    p = Math.sqrt(1 - E * E / T),
                    g = Math.max(Math.min(u, _ - p * h), r.z - a),
                    S = Math.min(Math.max(u, _ + p * h), r.z + a);
                if (g > t || S <= e) return !1;
                var R = this._depthSliceParam;
                return s.zMin = Math.floor(Math.log2(Math.max(g, e)) * R.x - R.y), s.zMax = Math.min(Math.ceil(Math.log2(S) * R.x - R.y), this._zSlices), !0;
            }
        }, {
            key: "_shrinkSphereLightByBoundOrth",
            value: function _shrinkSphereLightByBoundOrth(e, t, r, i, a, n, s) {
                var o = a.z,
                    l = o - n,
                    _ = o + n;
                if (l > i || _ <= r) return !1;
                var h = a.x,
                    c = h - n,
                    d = h + n;
                if (c > e || d <= -e) return !1;
                var u = a.y,
                    m = u - n,
                    f = u + n;
                if (m > t || f <= -t) return !1;
                var E = this._xSlices,
                    T = this._ySlices,
                    p = this._depthSliceParam,
                    g = 2 * e / E,
                    S = 2 * t / T;
                return s.xMin = Math.max(Math.floor((c + e) / g), 0), s.xMax = Math.min(Math.ceil((d + e) / g), E),
                    s.yMin = Math.max(Math.floor((t - f) / S), 0), s.yMax = Math.min(Math.ceil((t - m) / S), T),
                    s.zMin = Math.floor(Math.log2(Math.max(l, r)) * p.x - p.y), s.zMax = Math.min(Math.ceil(Math.log2(_) * p.x - p.y), this._zSlices), !0;
            }
        }, {
            key: "_shrinkSpotLightByBoundOrth",
            value: function _shrinkSpotLightByBoundOrth(e, t, r, i, a, n, s, o, l) {
                var _ = n.x,
                    h = n.y,
                    c = n.z,
                    d = Math.tan(o) * s,
                    u = a.x,
                    m = a.y,
                    f = a.z,
                    E = _ - u,
                    T = h - m,
                    p = c - f,
                    g = E * E + T * T + p * p,
                    S = Math.sqrt(1 - p * p / g),
                    R = Math.max(Math.min(f, c - S * d), a.z - s),
                    v = Math.min(Math.max(f, c + S * d), a.z + s);
                if (R > i || v <= r) return !1;
                var x = Math.sqrt(1 - E * E / g),
                    I = Math.max(Math.min(u, _ - x * d), a.x - s),
                    A = Math.min(Math.max(u, _ + x * d), a.x + s);
                if (I > e || A <= -e) return !1;
                var M = Math.sqrt(1 - T * T / g),
                    D = Math.max(Math.min(m, h - M * d), a.y - s),
                    L = Math.min(Math.max(m, h + M * d), a.y + s);
                if (D > t || L <= -t) return !1;
                var y = this._xSlices,
                    C = this._ySlices,
                    O = this._depthSliceParam,
                    N = 2 * e / y,
                    P = 2 * t / C;
                return l.xMin = Math.max(Math.floor((I + e) / N), 0), l.xMax = Math.min(Math.ceil((A + e) / N), y),
                    l.yMin = Math.max(Math.floor((t - L) / P), 0), l.yMax = Math.min(Math.ceil((t - D) / P), C),
                    l.zMin = Math.floor(Math.log2(Math.max(R, r)) * O.x - O.y), l.zMax = Math.min(Math.ceil(Math.log2(v) * O.x - O.y), this._zSlices), !0;
            }
        }, {
            key: "_shrinkXYByRadiusPerspective",
            value: function _shrinkXYByRadiusPerspective(e, t, r, i, a) {
                var n, s, o, l, _, h = e.x,
                    c = e.y,
                    d = e.z,
                    u = this._ySlices + 1;
                for (_ = 0; _ < u; _++) {
                    if (c * (m = a[_]).y + d * m.z < t) {
                        s = Math.max(0, _ - 1);
                        break;
                    }
                }
                if (_ == u) return !1;
                for (l = this._ySlices, _ = s + 1; _ < u; _++) {
                    if (c * (m = a[_]).y + d * m.z <= -t) {
                        l = Math.max(0, _);
                        break;
                    }
                }
                for (u = this._xSlices + 1, _ = 0; _ < u; _++) {
                    if (h * (m = i[_]).x + d * m.z < t) {
                        n = Math.max(0, _ - 1);
                        break;
                    }
                }
                for (o = this._xSlices, _ = n + 1; _ < u; _++) {
                    var m;
                    if (h * (m = i[_]).x + d * m.z <= -t) {
                        o = Math.max(0, _);
                        break;
                    }
                }
                return r.xMin = n, r.xMax = o, r.yMin = s, r.yMax = l, !0;
            }
        }, {
            key: "_shrinkSpotXYByConePerspective",
            value: function _shrinkSpotXYByConePerspective(e, t, r, i, a, n, s) {
                for (var o, l, _, h, c = Fe._tempVector32, d = a.yMax + 1, u = a.yMin + 1; u < d; u++) {
                    if (this._insertConePlane(e, t, r, i, s[u])) {
                        l = Math.max(0, u - 1);
                        break;
                    }
                }
                h = a.yMax;
                for (u = l + 1; u < d; u++) {
                    var m = s[u];
                    if (c.setValue(0, -m.y, -m.z), !this._insertConePlane(e, t, r, i, c)) {
                        h = Math.max(0, u);
                        break;
                    }
                }
                d = a.xMax + 1;
                for (u = a.xMin + 1; u < d; u++) {
                    if (this._insertConePlane(e, t, r, i, n[u])) {
                        o = Math.max(0, u - 1);
                        break;
                    }
                }
                _ = a.xMax;
                for (u = o + 1; u < d; u++) {
                    m = n[u];
                    if (c.setValue(-m.x, 0, -m.z), !this._insertConePlane(e, t, r, i, c)) {
                        _ = Math.max(0, u);
                        break;
                    }
                }
                a.xMin = o, a.xMax = _, a.yMin = l, a.yMax = h;
            }
        }, {
            key: "_updatePointLightPerspective",
            value: function _updatePointLightPerspective(e, t, r, i, a, s, o) {
                var l = Fe._tempLightBound,
                    _ = Fe._tempVector30;
                n.transformV3ToV3(i._transform.position, r, _), _.z *= -1, this._shrinkSphereLightZPerspective(e, t, _, i.range, l) && this._shrinkXYByRadiusPerspective(_, i.range, l, s, o) && this._placePointLightToClusters(a, l);
            }
        }, {
            key: "_updateSpotLightPerspective",
            value: function _updateSpotLightPerspective(e, t, r, i, a, s, o) {
                var l = Fe._tempLightBound,
                    _ = Fe._tempVector30,
                    h = Fe._tempVector31,
                    c = Fe._tempVector34,
                    d = i._transform.position,
                    u = i.range;
                i._transform.worldMatrix.getForward(h), n.normalize(h, h), n.scale(h, u, c), n.add(d, c, c),
                    n.transformV3ToV3(d, r, _), n.transformV3ToV3(c, r, c), _.z *= -1, c.z *= -1;
                var m = i.spotAngle / 2 * Math.PI / 180;
                if (this._shrinkSpotLightZPerspective(e, t, _, c, u, m, l) && this._shrinkXYByRadiusPerspective(_, u, l, s, o)) {
                    var f = Fe._tempVector33;
                    f.x = c.x - _.x, f.y = c.y - _.y, f.z = c.z - _.z, n.normalize(f, f), this._shrinkSpotXYByConePerspective(_, f, u, m, l, s, o),
                        this._placeSpotLightToClusters(a, l);
                }
            }
        }, {
            key: "_updatePointLightOrth",
            value: function _updatePointLightOrth(e, t, r, i, a, s, o) {
                var l = Fe._tempLightBound,
                    _ = Fe._tempVector30;
                n.transformV3ToV3(s._transform.position, a, _), _.z *= -1, this._shrinkSphereLightByBoundOrth(e, t, r, i, _, s.range, l) && this._placePointLightToClusters(o, l);
            }
        }, {
            key: "_updateSpotLightOrth",
            value: function _updateSpotLightOrth(e, t, r, i, a, s, o) {
                var l = Fe._tempLightBound,
                    _ = Fe._tempVector30,
                    h = Fe._tempVector31,
                    c = Fe._tempVector34,
                    d = s._transform.position,
                    u = s.range;
                s._transform.worldMatrix.getForward(h), n.normalize(h, h), n.scale(h, u, c), n.add(d, c, c),
                    n.transformV3ToV3(d, a, _), n.transformV3ToV3(c, a, c), _.z *= -1, c.z *= -1;
                var m = s.spotAngle / 2 * Math.PI / 180;
                this._shrinkSpotLightByBoundOrth(e, t, r, i, _, c, u, m, l) && this._placeSpotLightToClusters(o, l);
            }
        }, {
            key: "update",
            value: function update(e, t) {
                this._updateMark++;
                var r = e.nearPlane;
                this._depthSliceParam.x = l._config.lightClusterCount.z / Math.log2(e.farPlane / r),
                    this._depthSliceParam.y = Math.log2(r) * this._depthSliceParam.x;
                var i = e.nearPlane,
                    a = e.farPlane,
                    n = e.viewMatrix,
                    s = t._directionLights._length,
                    o = t._pointLights,
                    _ = o._length,
                    h = o._elements,
                    c = t._spotLights,
                    d = c._length,
                    u = c._elements;
                if (e.orthographic) {
                    for (var m = e.orthographicVerticalSize / 2, f = m * e.aspectRatio, E = 0; E < _; E++,
                        s++) {
                        this._updatePointLightOrth(f, m, i, a, n, h[E], s);
                    }
                    for (E = 0; E < d; E++, s++) {
                        this._updateSpotLightOrth(f, m, i, a, n, u[E], s);
                    }
                } else {
                    e._updateClusterPlaneXY();
                    var T = e._clusterXPlanes,
                        p = e._clusterYPlanes;
                    for (E = 0; E < _; E++, s++) {
                        this._updatePointLightPerspective(i, a, n, h[E], s, T, p);
                    }
                    for (E = 0; E < d; E++, s++) {
                        this._updateSpotLightPerspective(i, a, n, u[E], s, T, p);
                    }
                }
                if (_ + d > 0) {
                    for (var g = this._xSlices, S = this._ySlices, R = this._zSlices, v = g * S * 4, x = v * R, I = this._clusterPixels, A = I.length, M = this._clusterDatas, D = this._updateMark, L = !0, y = 0; y < R; y++) {
                        for (var C = 0; C < S; C++) {
                            for (var O = 0; O < g; O++) {
                                var N = M[y][C][O],
                                    P = 4 * (O + C * g + y * g * S);
                                if (N.updateMark !== D) I[P] = 0, I[P + 1] = 0;
                                else if (L) {
                                    var b = N.indices,
                                        V = N.pointLightCount,
                                        w = N.spotLightCount,
                                        F = V + w;
                                    if (x + F < A) {
                                        I[P] = V, I[P + 1] = w, I[P + 2] = Math.floor(x / v), I[P + 3] = x % v;
                                        for (E = 0; E < F; E++) {
                                            I[x++] = b[E];
                                        }
                                    } else {
                                        F = A - (x + F), V = Math.min(V, F), I[P] = V, I[P + 1] = Math.min(w, F - V), I[P + 2] = Math.floor(x / v),
                                            I[P + 3] = x % v;
                                        for (E = 0; E < F; E++) {
                                            I[x++] = b[E];
                                        }
                                        L = !1;
                                    }
                                }
                            }
                        }
                    }
                    var B = this._clusterTexture.width;
                    this._clusterTexture.setSubPixels(0, 0, B, Math.ceil(x / (4 * B)), I);
                }
            }
        }]);
        return Fe;
    }();
    Fe._tempVector30 = new n(), Fe._tempVector31 = new n(), Fe._tempVector32 = new n(),
        Fe._tempVector33 = new n(), Fe._tempVector34 = new n(), Fe._tempVector35 = new n(),
        Fe._tempVector36 = new n(), Fe._tempVector37 = new n(), Fe._tempLightBound = new( /* */ function() {
            function _class() {
                _classCallCheck(this, _class);
            }
            return _class;
        }())();
    var Be = /* */ function() {
        function Be(e) {
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            _classCallCheck(this, Be);
            this.normal = e, this.distance = t;
        }
        _createClass(Be, [{
            key: "normalize",
            value: function normalize() {
                var e = this.normal.x,
                    t = this.normal.y,
                    r = this.normal.z,
                    i = 1 / Math.sqrt(e * e + t * t + r * r);
                this.normal.x = e * i, this.normal.y = t * i, this.normal.z = r * i, this.distance *= i;
            }
        }], [{
            key: "createPlaneBy3P",
            value: function createPlaneBy3P(e, t, r) {
                var i = t.x - e.x,
                    a = t.y - e.y,
                    n = t.z - e.z,
                    s = r.x - e.x,
                    o = r.y - e.y,
                    l = r.z - e.z,
                    _ = a * l - n * o,
                    h = n * s - i * l,
                    c = i * o - a * s,
                    d = 1 / Math.sqrt(_ * _ + h * h + c * c),
                    u = _ * d,
                    m = h * d,
                    f = c * d;
                Be._TEMPVec3.x = u, Be._TEMPVec3.y = m, Be._TEMPVec3.z = f;
                var E = -(u * e.x + m * e.y + f * e.z);
                return new Be(Be._TEMPVec3, E);
            }
        }]);
        return Be;
    }();
    Be._TEMPVec3 = new n(), Be.PlaneIntersectionType_Back = 0, Be.PlaneIntersectionType_Front = 1,
        Be.PlaneIntersectionType_Intersecting = 2;
    var Ue = function Ue(e, t) {
        _classCallCheck(this, Ue);
        this.origin = e, this.direction = t;
    };
    var Ge = function Ge() {
        _classCallCheck(this, Ge);
    };
    Ge.Disjoint = 0, Ge.Contains = 1, Ge.Intersects = 2;
    var ze = /* */ function() {
        function ze() {
            _classCallCheck(this, ze);
        }
        _createClass(ze, null, [{
            key: "distancePlaneToPoint",
            value: function distancePlaneToPoint(e, t) {
                return n.dot(e.normal, t) - e.distance;
            }
        }, {
            key: "distanceBoxToPoint",
            value: function distanceBoxToPoint(e, t) {
                var r = e.min,
                    i = r.x,
                    a = r.y,
                    n = r.z,
                    s = e.max,
                    o = s.x,
                    l = s.y,
                    _ = s.z,
                    h = t.x,
                    c = t.y,
                    d = t.z,
                    u = 0;
                return h < i && (u += (i - h) * (i - h)), h > o && (u += (o - h) * (o - h)), c < a && (u += (a - c) * (a - c)),
                    c > l && (u += (l - c) * (l - c)), d < n && (u += (n - d) * (n - d)), d > _ && (u += (_ - d) * (_ - d)),
                    Math.sqrt(u);
            }
        }, {
            key: "distanceBoxToBox",
            value: function distanceBoxToBox(e, t) {
                var r, i = e.min,
                    a = i.x,
                    n = i.y,
                    s = i.z,
                    o = e.max,
                    l = o.x,
                    _ = o.y,
                    h = o.z,
                    c = t.min,
                    d = c.x,
                    u = c.y,
                    m = c.z,
                    f = t.max,
                    E = f.x,
                    T = f.y,
                    p = f.z,
                    g = 0;
                return a > E ? g += (r = a - E) * r : d > l && (g += (r = d - l) * r), n > T ? g += (r = n - T) * r : u > _ && (g += (r = u - _) * r),
                    s > p ? g += (r = s - p) * r : m > h && (g += (r = m - h) * r), Math.sqrt(g);
            }
        }, {
            key: "distanceSphereToPoint",
            value: function distanceSphereToPoint(e, t) {
                var r = Math.sqrt(n.distanceSquared(e.center, t));
                return r -= e.radius, Math.max(r, 0);
            }
        }, {
            key: "distanceSphereToSphere",
            value: function distanceSphereToSphere(e, t) {
                var r = Math.sqrt(n.distanceSquared(e.center, t.center));
                return r -= e.radius + t.radius, Math.max(r, 0);
            }
        }, {
            key: "intersectsRayAndTriangleRD",
            value: function intersectsRayAndTriangleRD(e, t, i, a, n) {
                var s = e.origin,
                    o = s.x,
                    l = s.y,
                    _ = s.z,
                    h = e.direction,
                    c = h.x,
                    d = h.y,
                    u = h.z,
                    m = t.x,
                    f = t.y,
                    E = t.z,
                    T = i.x,
                    p = i.y,
                    g = i.z,
                    S = a.x,
                    R = a.y,
                    v = a.z,
                    x = ze._tempV30.x,
                    I = ze._tempV30.y,
                    A = ze._tempV30.z;
                x = T - m, I = p - f, A = g - E;
                var M = ze._tempV31.x,
                    D = ze._tempV31.y,
                    L = ze._tempV31.z;
                M = S - m, D = R - f, L = v - E;
                var y = ze._tempV32.x,
                    C = ze._tempV32.y,
                    O = ze._tempV32.z,
                    N = x * (y = d * L - u * D) + I * (C = u * M - c * L) + A * (O = c * D - d * M);
                if (r.isZero(N)) return !1;
                var P = 1 / N,
                    b = ze._tempV33.x,
                    V = ze._tempV33.y,
                    w = ze._tempV33.z,
                    F = (b = o - m) * y + (V = l - f) * C + (w = _ - E) * O;
                if ((F *= P) < 0 || F > 1) return !1;
                var B = ze._tempV34.x,
                    U = ze._tempV34.y,
                    G = ze._tempV34.z,
                    z = c * (B = V * A - w * I) + d * (U = w * x - b * A) + u * (G = b * I - V * x);
                if ((z *= P) < 0 || F + z > 1) return !1;
                var H = M * B + D * U + L * G;
                return !((H *= P) < 0);
            }
        }, {
            key: "intersectsRayAndTriangleRP",
            value: function intersectsRayAndTriangleRP(e, t, r, i, a) {
                return ze.intersectsRayAndTriangleRD(e, t, r, i, void 0) ? (n.scale(e.direction, void 0, ze._tempV30),
                    n.add(e.origin, ze._tempV30, a), !0) : (a = n._ZERO, !1);
            }
        }, {
            key: "intersectsRayAndPoint",
            value: function intersectsRayAndPoint(e, t) {
                n.subtract(e.origin, t, ze._tempV30);
                var i = n.dot(ze._tempV30, e.direction),
                    a = n.dot(ze._tempV30, ze._tempV30) - r.zeroTolerance;
                return !(a > 0 && i > 0) && !(i * i - a < 0);
            }
        }, {
            key: "intersectsRayAndRay",
            value: function intersectsRayAndRay(e, t, i) {
                var a = e.origin,
                    s = a.x,
                    o = a.y,
                    l = a.z,
                    _ = e.direction,
                    h = _.x,
                    c = _.y,
                    d = _.z,
                    u = t.origin,
                    m = u.x,
                    f = u.y,
                    E = u.z,
                    T = t.direction,
                    p = T.x,
                    g = T.y,
                    S = T.z;
                n.cross(_, T, ze._tempV30);
                var R = ze._tempV30,
                    v = n.scalarLength(ze._tempV30);
                if (r.isZero(v) && r.nearEqual(m, s) && r.nearEqual(f, o) && r.nearEqual(E, l)) return !0;
                v *= v;
                var x = m - s,
                    I = f - o,
                    A = E - l,
                    M = p,
                    D = g,
                    L = S,
                    y = R.x,
                    C = R.y,
                    O = R.z,
                    N = x * D * O + I * L * y + A * M * C - x * L * C - I * M * O - A * D * y;
                M = h, D = c, L = d;
                var P = N / v;
                n.scale(_, P, ze._tempV30), n.scale(T, P, ze._tempV31), n.add(a, ze._tempV30, ze._tempV32),
                    n.add(u, ze._tempV31, ze._tempV33);
                var b = ze._tempV32,
                    V = ze._tempV33;
                return !!(r.nearEqual(V.x, b.x) && r.nearEqual(V.y, b.y) && r.nearEqual(V.z, b.z));
            }
        }, {
            key: "intersectsPlaneAndTriangle",
            value: function intersectsPlaneAndTriangle(e, t, r, i) {
                var a = ze.intersectsPlaneAndPoint(e, t),
                    n = ze.intersectsPlaneAndPoint(e, r),
                    s = ze.intersectsPlaneAndPoint(e, i);
                return a == Be.PlaneIntersectionType_Front && n == Be.PlaneIntersectionType_Front && s == Be.PlaneIntersectionType_Front ? Be.PlaneIntersectionType_Front : a == Be.PlaneIntersectionType_Back && n == Be.PlaneIntersectionType_Back && s == Be.PlaneIntersectionType_Back ? Be.PlaneIntersectionType_Back : Be.PlaneIntersectionType_Intersecting;
            }
        }, {
            key: "intersectsRayAndPlaneRD",
            value: function intersectsRayAndPlaneRD(e, t) {
                var i = t.normal,
                    a = n.dot(i, e.direction);
                if (Math.abs(a) < r.zeroTolerance) return -1;
                var s = n.dot(i, e.origin),
                    o = (-t.distance - s) / a;
                if (o < 0) {
                    if (o < -r.zeroTolerance) return -1;
                    o = 0;
                }
                return o;
            }
        }, {
            key: "intersectsRayAndPlaneRP",
            value: function intersectsRayAndPlaneRP(e, t, r) {
                var i = ze.intersectsRayAndPlaneRD(e, t);
                if (-1 == i) return r.setValue(0, 0, 0), !1;
                var a = ze._tempV30;
                return n.scale(e.direction, i, a), n.add(e.origin, a, r), !0;
            }
        }, {
            key: "intersectsRayAndBoxRD",
            value: function intersectsRayAndBoxRD(e, t) {
                var i = e.origin,
                    a = i.x,
                    n = i.y,
                    s = i.z,
                    o = e.direction,
                    l = o.x,
                    _ = o.y,
                    h = o.z,
                    c = t.min,
                    d = c.x,
                    u = c.y,
                    m = c.z,
                    f = t.max,
                    E = f.x,
                    T = f.y,
                    p = f.z,
                    g = 0,
                    S = r.MaxValue;
                if (r.isZero(l)) {
                    if (a < d || a > E) return -1;
                } else {
                    var R = 1 / l,
                        v = (d - a) * R,
                        x = (E - a) * R;
                    if (v > x) {
                        var I = v;
                        v = x, x = I;
                    }
                    if ((g = Math.max(v, g)) > (S = Math.min(x, S))) return -1;
                }
                if (r.isZero(_)) {
                    if (n < u || n > T) return -1;
                } else {
                    var A = 1 / _,
                        M = (u - n) * A,
                        D = (T - n) * A;
                    if (M > D) {
                        var L = M;
                        M = D, D = L;
                    }
                    if ((g = Math.max(M, g)) > (S = Math.min(D, S))) return -1;
                }
                if (r.isZero(h)) {
                    if (s < m || s > p) return -1;
                } else {
                    var y = 1 / h,
                        C = (m - s) * y,
                        O = (p - s) * y;
                    if (C > O) {
                        var N = C;
                        C = O, O = N;
                    }
                    if ((g = Math.max(C, g)) > (S = Math.min(O, S))) return -1;
                }
                return g;
            }
        }, {
            key: "intersectsRayAndBoxRP",
            value: function intersectsRayAndBoxRP(e, t, r) {
                var i = ze.intersectsRayAndBoxRD(e, t);
                return -1 === i ? (n._ZERO.cloneTo(r), i) : (n.scale(e.direction, i, ze._tempV30),
                    n.add(e.origin, ze._tempV30, ze._tempV31), ze._tempV31.cloneTo(r), i);
            }
        }, {
            key: "intersectsRayAndSphereRD",
            value: function intersectsRayAndSphereRD(e, t) {
                var r = t.radius;
                n.subtract(e.origin, t.center, ze._tempV30);
                var i = n.dot(ze._tempV30, e.direction),
                    a = n.dot(ze._tempV30, ze._tempV30) - r * r;
                if (a > 0 && i > 0) return -1;
                var s = i * i - a;
                if (s < 0) return -1;
                var o = -i - Math.sqrt(s);
                return o < 0 && (o = 0), o;
            }
        }, {
            key: "intersectsRayAndSphereRP",
            value: function intersectsRayAndSphereRP(e, t, r) {
                var i = ze.intersectsRayAndSphereRD(e, t);
                return -1 === i ? (n._ZERO.cloneTo(r), i) : (n.scale(e.direction, i, ze._tempV30),
                    n.add(e.origin, ze._tempV30, ze._tempV31), ze._tempV31.cloneTo(r), i);
            }
        }, {
            key: "intersectsSphereAndTriangle",
            value: function intersectsSphereAndTriangle(e, t, r, i) {
                var a = e.center,
                    s = e.radius;
                return ze.closestPointPointTriangle(a, t, r, i, ze._tempV30), n.subtract(ze._tempV30, a, ze._tempV31),
                    n.dot(ze._tempV31, ze._tempV31) <= s * s;
            }
        }, {
            key: "intersectsPlaneAndPoint",
            value: function intersectsPlaneAndPoint(e, t) {
                var r = n.dot(e.normal, t) + e.distance;
                return r > 0 ? Be.PlaneIntersectionType_Front : r < 0 ? Be.PlaneIntersectionType_Back : Be.PlaneIntersectionType_Intersecting;
            }
        }, {
            key: "intersectsPlaneAndPlane",
            value: function intersectsPlaneAndPlane(e, t) {
                n.cross(e.normal, t.normal, ze._tempV30);
                var i = n.dot(ze._tempV30, ze._tempV30);
                return !r.isZero(i);
            }
        }, {
            key: "intersectsPlaneAndPlaneRL",
            value: function intersectsPlaneAndPlaneRL(e, t, i) {
                var a = e.normal,
                    s = t.normal;
                n.cross(a, s, ze._tempV34);
                var o = n.dot(ze._tempV34, ze._tempV34);
                return !r.isZero(o) && (n.scale(s, e.distance, ze._tempV30), n.scale(a, t.distance, ze._tempV31),
                    n.subtract(ze._tempV30, ze._tempV31, ze._tempV32), n.cross(ze._tempV32, ze._tempV34, ze._tempV33),
                    n.normalize(ze._tempV34, ze._tempV34), !0);
            }
        }, {
            key: "intersectsPlaneAndBox",
            value: function intersectsPlaneAndBox(e, t) {
                var r = e.distance,
                    i = e.normal,
                    a = i.x,
                    s = i.y,
                    o = i.z,
                    l = t.min,
                    _ = l.x,
                    h = l.y,
                    c = l.z,
                    d = t.max,
                    u = d.x,
                    m = d.y,
                    f = d.z;
                ze._tempV30.x = a > 0 ? _ : u, ze._tempV30.y = s > 0 ? h : m, ze._tempV30.z = o > 0 ? c : f,
                    ze._tempV31.x = a > 0 ? u : _, ze._tempV31.y = s > 0 ? m : h, ze._tempV31.z = o > 0 ? f : c;
                var E = n.dot(i, ze._tempV30);
                return E + r > 0 ? Be.PlaneIntersectionType_Front : (E = n.dot(i, ze._tempV31)) + r < 0 ? Be.PlaneIntersectionType_Back : Be.PlaneIntersectionType_Intersecting;
            }
        }, {
            key: "intersectsPlaneAndSphere",
            value: function intersectsPlaneAndSphere(e, t) {
                var r = t.radius,
                    i = n.dot(e.normal, t.center) + e.distance;
                return i > r ? Be.PlaneIntersectionType_Front : i < -r ? Be.PlaneIntersectionType_Back : Be.PlaneIntersectionType_Intersecting;
            }
        }, {
            key: "intersectsBoxAndBox",
            value: function intersectsBoxAndBox(e, t) {
                var r = e.min,
                    i = e.max,
                    a = t.min,
                    n = t.max;
                return !(r.x > n.x || a.x > i.x) && !(r.y > n.y || a.y > i.y) && !(r.z > n.z || a.z > i.z);
            }
        }, {
            key: "intersectsBoxAndSphere",
            value: function intersectsBoxAndSphere(e, t) {
                var r = t.center,
                    i = t.radius;
                return n.Clamp(r, e.min, e.max, ze._tempV30), n.distanceSquared(r, ze._tempV30) <= i * i;
            }
        }, {
            key: "intersectsSphereAndSphere",
            value: function intersectsSphereAndSphere(e, t) {
                var r = e.radius + t.radius;
                return n.distanceSquared(e.center, t.center) <= r * r;
            }
        }, {
            key: "boxContainsPoint",
            value: function boxContainsPoint(e, t) {
                var r = e.min,
                    i = e.max;
                return r.x <= t.x && i.x >= t.x && r.y <= t.y && i.y >= t.y && r.z <= t.z && i.z >= t.z ? Ge.Contains : Ge.Disjoint;
            }
        }, {
            key: "boxContainsBox",
            value: function boxContainsBox(e, t) {
                var r = e.min,
                    i = r.x,
                    a = r.y,
                    n = r.z,
                    s = e.max,
                    o = s.x,
                    l = s.y,
                    _ = s.z,
                    h = t.min,
                    c = h.x,
                    d = h.y,
                    u = h.z,
                    m = t.max,
                    f = m.x,
                    E = m.y,
                    T = m.z;
                return o < c || i > f ? Ge.Disjoint : l < d || a > E ? Ge.Disjoint : _ < u || n > T ? Ge.Disjoint : i <= c && f <= o && a <= d && E <= l && n <= u && T <= _ ? Ge.Contains : Ge.Intersects;
            }
        }, {
            key: "boxContainsSphere",
            value: function boxContainsSphere(e, t) {
                var r = e.min,
                    i = r.x,
                    a = r.y,
                    s = r.z,
                    o = e.max,
                    l = o.x,
                    _ = o.y,
                    h = o.z,
                    c = t.center,
                    d = c.x,
                    u = c.y,
                    m = c.z,
                    f = t.radius;
                return n.Clamp(c, r, o, ze._tempV30), n.distanceSquared(c, ze._tempV30) > f * f ? Ge.Disjoint : i + f <= d && d <= l - f && l - i > f && a + f <= u && u <= _ - f && _ - a > f && s + f <= m && m <= h - f && h - s > f ? Ge.Contains : Ge.Intersects;
            }
        }, {
            key: "sphereContainsPoint",
            value: function sphereContainsPoint(e, t) {
                return n.distanceSquared(t, e.center) <= e.radius * e.radius ? Ge.Contains : Ge.Disjoint;
            }
        }, {
            key: "sphereContainsTriangle",
            value: function sphereContainsTriangle(e, t, r, i) {
                var a = ze.sphereContainsPoint(e, t),
                    n = ze.sphereContainsPoint(e, r),
                    s = ze.sphereContainsPoint(e, i);
                return a == Ge.Contains && n == Ge.Contains && s == Ge.Contains ? Ge.Contains : ze.intersectsSphereAndTriangle(e, t, r, i) ? Ge.Intersects : Ge.Disjoint;
            }
        }, {
            key: "sphereContainsBox",
            value: function sphereContainsBox(e, t) {
                var r = e.center,
                    i = r.x,
                    a = r.y,
                    s = r.z,
                    o = e.radius,
                    l = t.min,
                    _ = l.x,
                    h = l.y,
                    c = l.z,
                    d = t.max,
                    u = d.x,
                    m = d.y,
                    f = d.z,
                    E = ze._tempV30;
                E.x, E.y, E.z;
                if (!ze.intersectsBoxAndSphere(t, e)) return Ge.Disjoint;
                var T = o * o;
                return i - _, a - m, s - f, n.scalarLengthSquared(ze._tempV30) > T ? Ge.Intersects : (i - u,
                    a - m, s - f, n.scalarLengthSquared(ze._tempV30) > T ? Ge.Intersects : (i - u, a - h,
                        s - f, n.scalarLengthSquared(ze._tempV30) > T ? Ge.Intersects : (i - _, a - h, s - f,
                            n.scalarLengthSquared(ze._tempV30) > T ? Ge.Intersects : (i - _, a - m, s - c, n.scalarLengthSquared(ze._tempV30) > T ? Ge.Intersects : (i - u,
                                a - m, s - c, n.scalarLengthSquared(ze._tempV30) > T ? Ge.Intersects : (i - u, a - h,
                                    s - c, n.scalarLengthSquared(ze._tempV30) > T ? Ge.Intersects : (i - _, a - h, s - c,
                                        n.scalarLengthSquared(ze._tempV30) > T ? Ge.Intersects : Ge.Contains)))))));
            }
        }, {
            key: "sphereContainsSphere",
            value: function sphereContainsSphere(e, t) {
                var r = e.radius,
                    i = t.radius,
                    a = n.distance(e.center, t.center);
                return r + i < a ? Ge.Disjoint : r - i < a ? Ge.Intersects : Ge.Contains;
            }
        }, {
            key: "closestPointPointTriangle",
            value: function closestPointPointTriangle(e, t, r, i, a) {
                n.subtract(r, t, ze._tempV30), n.subtract(i, t, ze._tempV31), n.subtract(e, t, ze._tempV32),
                    n.subtract(e, r, ze._tempV33), n.subtract(e, i, ze._tempV34);
                var s = n.dot(ze._tempV30, ze._tempV32),
                    o = n.dot(ze._tempV31, ze._tempV32),
                    l = n.dot(ze._tempV30, ze._tempV33),
                    _ = n.dot(ze._tempV31, ze._tempV33),
                    h = n.dot(ze._tempV30, ze._tempV34),
                    c = n.dot(ze._tempV31, ze._tempV34);
                if (s <= 0 && o <= 0) t.cloneTo(a);
                else if (l >= 0 && _ <= l) r.cloneTo(a);
                else {
                    var d = s * _ - l * o;
                    if (d <= 0 && s >= 0 && l <= 0) {
                        var u = s / (s - l);
                        return n.scale(ze._tempV30, u, a), void n.add(t, a, a);
                    }
                    if (c >= 0 && h <= c) i.cloneTo(a);
                    else {
                        var m = h * o - s * c;
                        if (m <= 0 && o >= 0 && c <= 0) {
                            var f = o / (o - c);
                            return n.scale(ze._tempV31, f, a), void n.add(t, a, a);
                        }
                        var E = l * c - h * _;
                        if (E <= 0 && _ - l >= 0 && h - c >= 0) {
                            var T = (_ - l) / (_ - l + (h - c));
                            return n.subtract(i, r, a), n.scale(a, T, a), void n.add(r, a, a);
                        }
                        var p = 1 / (E + m + d),
                            g = m * p,
                            S = d * p;
                        n.scale(ze._tempV30, g, ze._tempV35), n.scale(ze._tempV31, S, ze._tempV36), n.add(ze._tempV35, ze._tempV36, a),
                            n.add(t, a, a);
                    }
                }
            }
        }, {
            key: "closestPointPlanePoint",
            value: function closestPointPlanePoint(e, t, r) {
                var i = e.normal,
                    a = n.dot(i, t) - e.distance;
                n.scale(i, a, ze._tempV30), n.subtract(t, ze._tempV30, r);
            }
        }, {
            key: "closestPointBoxPoint",
            value: function closestPointBoxPoint(e, t, r) {
                n.max(t, e.min, ze._tempV30), n.min(ze._tempV30, e.max, r);
            }
        }, {
            key: "closestPointSpherePoint",
            value: function closestPointSpherePoint(e, t, r) {
                var i = e.center;
                n.subtract(t, i, r), n.normalize(r, r), n.scale(r, e.radius, r), n.add(r, i, r);
            }
        }, {
            key: "closestPointSphereSphere",
            value: function closestPointSphereSphere(e, t, r) {
                var i = e.center;
                n.subtract(t.center, i, r), n.normalize(r, r), n.scale(r, e.radius, r), n.add(r, i, r);
            }
        }]);
        return ze;
    }();
    ze._tempV30 = new n(), ze._tempV31 = new n(), ze._tempV32 = new n(), ze._tempV33 = new n(),
        ze._tempV34 = new n(), ze._tempV35 = new n(), ze._tempV36 = new n();
    var He = /* */ function() {
        function He(e) {
            _classCallCheck(this, He);
            this._matrix = e, this._near = new Be(new n()), this._far = new Be(new n()), this._left = new Be(new n()),
                this._right = new Be(new n()), this._top = new Be(new n()), this._bottom = new Be(new n()),
                He._getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
        }
        _createClass(He, [{
            key: "equalsBoundFrustum",
            value: function equalsBoundFrustum(e) {
                return this._matrix.equalsOtherMatrix(e.matrix);
            }
        }, {
            key: "equalsObj",
            value: function equalsObj(e) {
                if (e instanceof He) {
                    var t = e;
                    return this.equalsBoundFrustum(t);
                }
                return !1;
            }
        }, {
            key: "getPlane",
            value: function getPlane(e) {
                switch (e) {
                    case 0:
                        return this._near;

                    case 1:
                        return this._far;

                    case 2:
                        return this._left;

                    case 3:
                        return this._right;

                    case 4:
                        return this._top;

                    case 5:
                        return this._bottom;

                    default:
                        return null;
                }
            }
        }, {
            key: "getCorners",
            value: function getCorners(e) {
                He._get3PlaneInterPoint(this._near, this._bottom, this._right).cloneTo(e[0]), He._get3PlaneInterPoint(this._near, this._top, this._right).cloneTo(e[1]),
                    He._get3PlaneInterPoint(this._near, this._top, this._left).cloneTo(e[2]), He._get3PlaneInterPoint(this._near, this._bottom, this._left).cloneTo(e[3]),
                    He._get3PlaneInterPoint(this._far, this._bottom, this._right).cloneTo(e[4]), He._get3PlaneInterPoint(this._far, this._top, this._right).cloneTo(e[5]),
                    He._get3PlaneInterPoint(this._far, this._top, this._left).cloneTo(e[6]), He._get3PlaneInterPoint(this._far, this._bottom, this._left).cloneTo(e[7]);
            }
        }, {
            key: "containsPoint",
            value: function containsPoint(e) {
                for (var t = Be.PlaneIntersectionType_Front, r = Be.PlaneIntersectionType_Front, i = 0; i < 6; i++) {
                    switch (i) {
                        case 0:
                            r = ze.intersectsPlaneAndPoint(this._near, e);
                            break;

                        case 1:
                            r = ze.intersectsPlaneAndPoint(this._far, e);
                            break;

                        case 2:
                            r = ze.intersectsPlaneAndPoint(this._left, e);
                            break;

                        case 3:
                            r = ze.intersectsPlaneAndPoint(this._right, e);
                            break;

                        case 4:
                            r = ze.intersectsPlaneAndPoint(this._top, e);
                            break;

                        case 5:
                            r = ze.intersectsPlaneAndPoint(this._bottom, e);
                    }
                    switch (r) {
                        case Be.PlaneIntersectionType_Back:
                            return Ge.Disjoint;

                        case Be.PlaneIntersectionType_Intersecting:
                            t = Be.PlaneIntersectionType_Intersecting;
                    }
                }
                switch (t) {
                    case Be.PlaneIntersectionType_Intersecting:
                        return Ge.Intersects;

                    default:
                        return Ge.Contains;
                }
            }
        }, {
            key: "intersects",
            value: function intersects(e) {
                var t = e.min,
                    r = e.max,
                    i = t.x,
                    a = t.y,
                    n = t.z,
                    s = r.x,
                    o = r.y,
                    l = r.z,
                    _ = this._near.normal;
                if (this._near.distance + _.x * (_.x < 0 ? i : s) + _.y * (_.y < 0 ? a : o) + _.z * (_.z < 0 ? n : l) < 0) return !1;
                var h = this._left.normal;
                if (this._left.distance + h.x * (h.x < 0 ? i : s) + h.y * (h.y < 0 ? a : o) + h.z * (h.z < 0 ? n : l) < 0) return !1;
                var c = this._right.normal;
                if (this._right.distance + c.x * (c.x < 0 ? i : s) + c.y * (c.y < 0 ? a : o) + c.z * (c.z < 0 ? n : l) < 0) return !1;
                var d = this._bottom.normal;
                if (this._bottom.distance + d.x * (d.x < 0 ? i : s) + d.y * (d.y < 0 ? a : o) + d.z * (d.z < 0 ? n : l) < 0) return !1;
                var u = this._top.normal;
                if (this._top.distance + u.x * (u.x < 0 ? i : s) + u.y * (u.y < 0 ? a : o) + u.z * (u.z < 0 ? n : l) < 0) return !1;
                var m = this._far.normal;
                return !(this._far.distance + m.x * (m.x < 0 ? i : s) + m.y * (m.y < 0 ? a : o) + m.z * (m.z < 0 ? n : l) < 0);
            }
        }, {
            key: "containsBoundBox",
            value: function containsBoundBox(e) {
                for (var t = He._tempV30, r = He._tempV31, i = e.min, a = e.max, n = Ge.Contains, s = 0; s < 6; s++) {
                    var o = this.getPlane(s),
                        l = o.normal;
                    if (l.x >= 0 ? (t.x = a.x, r.x = i.x) : (t.x = i.x, r.x = a.x), l.y >= 0 ? (t.y = a.y,
                            r.y = i.y) : (t.y = i.y, r.y = a.y), l.z >= 0 ? (t.z = a.z, r.z = i.z) : (t.z = i.z,
                            r.z = a.z), ze.intersectsPlaneAndPoint(o, t) === Be.PlaneIntersectionType_Back) return Ge.Disjoint;
                    ze.intersectsPlaneAndPoint(o, r) === Be.PlaneIntersectionType_Back && (n = Ge.Intersects);
                }
                return n;
            }
        }, {
            key: "containsBoundSphere",
            value: function containsBoundSphere(e) {
                for (var t = Be.PlaneIntersectionType_Front, r = Be.PlaneIntersectionType_Front, i = 0; i < 6; i++) {
                    switch (i) {
                        case 0:
                            r = ze.intersectsPlaneAndSphere(this._near, e);
                            break;

                        case 1:
                            r = ze.intersectsPlaneAndSphere(this._far, e);
                            break;

                        case 2:
                            r = ze.intersectsPlaneAndSphere(this._left, e);
                            break;

                        case 3:
                            r = ze.intersectsPlaneAndSphere(this._right, e);
                            break;

                        case 4:
                            r = ze.intersectsPlaneAndSphere(this._top, e);
                            break;

                        case 5:
                            r = ze.intersectsPlaneAndSphere(this._bottom, e);
                    }
                    switch (r) {
                        case Be.PlaneIntersectionType_Back:
                            return Ge.Disjoint;

                        case Be.PlaneIntersectionType_Intersecting:
                            t = Be.PlaneIntersectionType_Intersecting;
                    }
                }
                switch (t) {
                    case Be.PlaneIntersectionType_Intersecting:
                        return Ge.Intersects;

                    default:
                        return Ge.Contains;
                }
            }
        }, {
            key: "matrix",
            get: function get() {
                return this._matrix;
            },
            set: function set(e) {
                this._matrix = e, He._getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
            }
        }, {
            key: "near",
            get: function get() {
                return this._near;
            }
        }, {
            key: "far",
            get: function get() {
                return this._far;
            }
        }, {
            key: "left",
            get: function get() {
                return this._left;
            }
        }, {
            key: "right",
            get: function get() {
                return this._right;
            }
        }, {
            key: "top",
            get: function get() {
                return this._top;
            }
        }, {
            key: "bottom",
            get: function get() {
                return this._bottom;
            }
        }], [{
            key: "_getPlanesFromMatrix",
            value: function _getPlanesFromMatrix(e, t, r, i, a, n, s) {
                var o = e.elements,
                    l = o[0],
                    _ = o[1],
                    h = o[2],
                    c = o[3],
                    d = o[4],
                    u = o[5],
                    m = o[6],
                    f = o[7],
                    E = o[8],
                    T = o[9],
                    p = o[10],
                    g = o[11],
                    S = o[12],
                    R = o[13],
                    v = o[14],
                    x = o[15],
                    I = t.normal;
                I.x = c + h, I.y = f + m, I.z = g + p, t.distance = x + v, t.normalize();
                var A = r.normal;
                A.x = c - h, A.y = f - m, A.z = g - p, r.distance = x - v, r.normalize();
                var M = i.normal;
                M.x = c + l, M.y = f + d, M.z = g + E, i.distance = x + S, i.normalize();
                var D = a.normal;
                D.x = c - l, D.y = f - d, D.z = g - E, a.distance = x - S, a.normalize();
                var L = n.normal;
                L.x = c - _, L.y = f - u, L.z = g - T, n.distance = x - R, n.normalize();
                var y = s.normal;
                y.x = c + _, y.y = f + u, y.z = g + T, s.distance = x + R, s.normalize();
            }
        }, {
            key: "_get3PlaneInterPoint",
            value: function _get3PlaneInterPoint(e, t, r) {
                var i = e.normal,
                    a = t.normal,
                    s = r.normal;
                n.cross(a, s, He._tempV30), n.cross(s, i, He._tempV31), n.cross(i, a, He._tempV32);
                var o = n.dot(i, He._tempV30),
                    l = n.dot(a, He._tempV31),
                    _ = n.dot(s, He._tempV32);
                return n.scale(He._tempV30, -e.distance / o, He._tempV33), n.scale(He._tempV31, -t.distance / l, He._tempV34),
                    n.scale(He._tempV32, -r.distance / _, He._tempV35), n.add(He._tempV33, He._tempV34, He._tempV36),
                    n.add(He._tempV35, He._tempV36, He._tempV37), He._tempV37;
            }
        }]);
        return He;
    }();
    He._tempV30 = new n(), He._tempV31 = new n(), He._tempV32 = new n(), He._tempV33 = new n(),
        He._tempV34 = new n(), He._tempV35 = new n(), He._tempV36 = new n(), He._tempV37 = new n();
    var ke = /* */ function() {
        function ke(e, t, r, i) {
            _classCallCheck(this, ke);
            this.minDepth = 0, this.maxDepth = 1, this.x = e, this.y = t, this.width = r, this.height = i;
        }
        _createClass(ke, [{
            key: "project",
            value: function project(e, t, r) {
                n.transformV3ToV4(e, t, r);
                var i = r.x,
                    a = r.y,
                    s = r.z,
                    o = r.w;
                1 !== o && (i /= o, a /= o, s /= o), r.x = .5 * (i + 1) * this.width + this.x, r.y = .5 * (1 - a) * this.height + this.y,
                    r.z = s * (this.maxDepth - this.minDepth) + this.minDepth;
            }
        }, {
            key: "unprojectFromMat",
            value: function unprojectFromMat(e, t, r) {
                var i = t.elements;
                r.x = (e.x - this.x) / this.width * 2 - 1, r.y = -((e.y - this.y) / this.height * 2 - 1);
                var a = (this.maxDepth - this.minDepth) / 2;
                r.z = (e.z - this.minDepth - a) / a;
                var s = r.x * i[3] + r.y * i[7] + r.z * i[11] + i[15];
                n.transformV3ToV3(r, t, r), 1 !== s && (r.x = r.x / s, r.y = r.y / s, r.z = r.z / s);
            }
        }, {
            key: "unprojectFromWVP",
            value: function unprojectFromWVP(e, t, r, i, a) {
                C.multiply(t, r, ke._tempMatrix4x4), i && C.multiply(ke._tempMatrix4x4, i, ke._tempMatrix4x4),
                    ke._tempMatrix4x4.invert(ke._tempMatrix4x4), this.unprojectFromMat(e, ke._tempMatrix4x4, a);
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e.minDepth = this.minDepth,
                    e.maxDepth = this.maxDepth;
            }
        }]);
        return ke;
    }();
    ke._tempMatrix4x4 = new C();
    var We = /* */ function() {
        function We() {
            _classCallCheck(this, We);
        }
        _createClass(We, null, [{
            key: "calculateCursorRay",
            value: function calculateCursorRay(e, t, r, i, a, s) {
                var o = e.x,
                    l = e.y,
                    _ = We._tempVector30,
                    h = _;
                h.x = o, h.y = l, h.z = t.minDepth;
                var c = We._tempVector31,
                    d = c;
                d.x = o, d.y = l, d.z = t.maxDepth;
                var u = s.origin,
                    m = We._tempVector32;
                t.unprojectFromWVP(_, r, i, a, u), t.unprojectFromWVP(c, r, i, a, m);
                var f = s.direction;
                f.x = m.x - u.x, f.y = m.y - u.y, f.z = m.z - u.z, n.normalize(s.direction, s.direction);
            }
        }, {
            key: "rayIntersectsTriangle",
            value: function rayIntersectsTriangle(e, t, r, i) {
                var a = We._tempVector30,
                    s = We._tempVector31;
                n.subtract(r, t, a), n.subtract(i, t, s);
                var o, l = We._tempVector32;
                if (n.cross(e.direction, s, l), (o = n.dot(a, l)) > -Number.MIN_VALUE && o < Number.MIN_VALUE) return Number.NaN;
                var _, h = 1 / o,
                    c = We._tempVector33;
                if (n.subtract(e.origin, t, c), _ = n.dot(c, l), (_ *= h) < 0 || _ > 1) return Number.NaN;
                var d, u, m = We._tempVector34;
                return n.cross(c, a, m), d = n.dot(e.direction, m), (d *= h) < 0 || _ + d > 1 ? Number.NaN : (u = n.dot(s, m),
                    (u *= h) < 0 ? Number.NaN : u);
            }
        }]);
        return We;
    }();
    We._tempVector30 = new n(), We._tempVector31 = new n(), We._tempVector32 = new n(),
        We._tempVector33 = new n(), We._tempVector34 = new n();
    var Xe = /* */ function(_t$BufferStateBase) {
        _inherits(Xe, _t$BufferStateBase);

        function Xe() {
            _classCallCheck(this, Xe);
            return _possibleConstructorReturn(this, _getPrototypeOf(Xe).call(this));
        }
        _createClass(Xe, [{
            key: "applyVertexBuffer",
            value: function applyVertexBuffer(e) {
                if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                var r = t.LayaGL.instance,
                    i = e.vertexDeclaration,
                    a = i._shaderValues.getData();
                for (var n in this.vertexDeclaration = i, e.bind(), a) {
                    var s = parseInt(n),
                        o = a[n];
                    r.enableVertexAttribArray(s), r.vertexAttribPointer(s, o[0], o[1], !!o[2], o[3], o[4]);
                }
            }
        }, {
            key: "applyVertexBuffers",
            value: function applyVertexBuffers(e) {
                if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                for (var r = t.LayaGL.instance, i = 0, a = e.length; i < a; i++) {
                    var n = e[i],
                        s = n.vertexDeclaration._shaderValues.getData();
                    for (var o in n.bind(), s) {
                        var l = parseInt(o),
                            _ = s[o];
                        r.enableVertexAttribArray(l), r.vertexAttribPointer(l, _[0], _[1], !!_[2], _[3], _[4]);
                    }
                }
            }
        }, {
            key: "applyInstanceVertexBuffer",
            value: function applyInstanceVertexBuffer(e) {
                if (t.LayaGL.layaGPUInstance.supportInstance()) {
                    if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                    var r = t.LayaGL.instance,
                        i = e.vertexDeclaration._shaderValues.getData();
                    for (var a in e.bind(), i) {
                        var n = parseInt(a),
                            s = i[a];
                        r.enableVertexAttribArray(n), r.vertexAttribPointer(n, s[0], s[1], !!s[2], s[3], s[4]),
                            t.LayaGL.layaGPUInstance.vertexAttribDivisor(n, 1);
                    }
                }
            }
        }, {
            key: "applyIndexBuffer",
            value: function applyIndexBuffer(e) {
                if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                this._bindedIndexBuffer !== e && (e._bindForVAO(), this._bindedIndexBuffer = e);
            }
        }]);
        return Xe;
    }(t.BufferStateBase);
    (me = e.IndexFormat || (e.IndexFormat = {}))[me.UInt8 = 0] = "UInt8", me[me.UInt16 = 1] = "UInt16",
        me[me.UInt32 = 2] = "UInt32";
    var Ye = /* */ function(_t$Buffer2) {
        _inherits(Ye, _t$Buffer2);
        _createClass(Ye, [{
            key: "indexType",
            get: function get() {
                return this._indexType;
            }
        }, {
            key: "indexTypeByteCount",
            get: function get() {
                return this._indexTypeByteCount;
            }
        }, {
            key: "indexCount",
            get: function get() {
                return this._indexCount;
            }
        }, {
            key: "canRead",
            get: function get() {
                return this._canRead;
            }
        }]);

        function Ye(r, i) {
            var _this25;
            var a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 35044;
            var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
            _classCallCheck(this, Ye);
            switch (_this25 = _possibleConstructorReturn(this, _getPrototypeOf(Ye).call(this)),
                _this25._indexType = r, _this25._indexCount = i, _this25._bufferUsage = a, _this25._bufferType = t.LayaGL.instance.ELEMENT_ARRAY_BUFFER,
                _this25._canRead = n, r) {
                case e.IndexFormat.UInt32:
                    _this25._indexTypeByteCount = 4;
                    break;

                case e.IndexFormat.UInt16:
                    _this25._indexTypeByteCount = 2;
                    break;

                case e.IndexFormat.UInt8:
                    _this25._indexTypeByteCount = 1;
                    break;

                default:
                    throw new Error("unidentification index type.");
            }
            var s = _this25._indexTypeByteCount * i,
                o = t.BufferStateBase._curBindedBufferState;
            if (_this25._byteLength = s, o ? o._bindedIndexBuffer === _assertThisInitialized(_this25) ? t.LayaGL.instance.bufferData(_this25._bufferType, s, _this25._bufferUsage) : (o.unBind(),
                    _this25.bind(), t.LayaGL.instance.bufferData(_this25._bufferType, s, _this25._bufferUsage),
                    o.bind()) : (_this25.bind(), t.LayaGL.instance.bufferData(_this25._bufferType, s, _this25._bufferUsage)),
                n) switch (r) {
                case e.IndexFormat.UInt32:
                    _this25._buffer = new Uint32Array(i);
                    break;

                case e.IndexFormat.UInt16:
                    _this25._buffer = new Uint16Array(i);
                    break;

                case e.IndexFormat.UInt8:
                    _this25._buffer = new Uint8Array(i);
            }
            return _this25;
        }
        _createClass(Ye, [{
            key: "_bindForVAO",
            value: function _bindForVAO() {
                if (!t.BufferStateBase._curBindedBufferState) throw "IndexBuffer3D: must bind current BufferState.";
                var e = t.LayaGL.instance;
                e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._glBuffer);
            }
        }, {
            key: "bind",
            value: function bind() {
                if (t.BufferStateBase._curBindedBufferState) throw "IndexBuffer3D: must unbind current BufferState.";
                if (t.Buffer._bindedIndexBuffer !== this._glBuffer) {
                    var e = t.LayaGL.instance;
                    return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._glBuffer), t.Buffer._bindedIndexBuffer = this._glBuffer, !0;
                }
                return !1;
            }
        }, {
            key: "setData",
            value: function setData(r) {
                var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4294967295;
                var s = this._indexTypeByteCount;
                if (0 !== a || 4294967295 !== n) switch (this._indexType) {
                    case e.IndexFormat.UInt32:
                        r = new Uint32Array(r.buffer, a * s, n);
                        break;

                    case e.IndexFormat.UInt16:
                        r = new Uint16Array(r.buffer, a * s, n);
                        break;

                    case e.IndexFormat.UInt8:
                        r = new Uint8Array(r.buffer, a * s, n);
                }
                var o = t.BufferStateBase._curBindedBufferState;
                if (o ? o._bindedIndexBuffer === this ? t.LayaGL.instance.bufferSubData(this._bufferType, i * s, r) : (o.unBind(),
                        this.bind(), t.LayaGL.instance.bufferSubData(this._bufferType, i * s, r), o.bind()) : (this.bind(),
                        t.LayaGL.instance.bufferSubData(this._bufferType, i * s, r)), this._canRead)
                    if (0 !== i || 0 !== a || 4294967295 !== n) {
                        var l = this._buffer.length - i;
                        n > l && (n = l);
                        for (var _ = 0; _ < n; _++) {
                            this._buffer[i + _] = r[_];
                        }
                    } else this._buffer = r;
            }
        }, {
            key: "getData",
            value: function getData() {
                if (this._canRead) return this._buffer;
                throw new Error("Can't read data from VertexBuffer with only write flag!");
            }
        }, {
            key: "destroy",
            value: function destroy() {
                _get(_getPrototypeOf(Ye.prototype), "destroy", this).call(this), this._buffer = null;
            }
        }]);
        return Ye;
    }(t.Buffer);
    var Ze = /* */ function() {
        function Ze() {
            _classCallCheck(this, Ze);
        }
        _createClass(Ze, [{
            key: "_render",
            value: function _render(e) {}
        }]);
        return Ze;
    }();
    var je = /* */ function(_Ze) {
        _inherits(je, _Ze);
        _createClass(je, null, [{
            key: "__init__",
            value: function __init__() {
                je.instance = new je();
            }
        }]);

        function je() {
            var _this26;
            _classCallCheck(this, je);
            _this26 = _possibleConstructorReturn(this, _getPrototypeOf(je).call(this));
            var r = t.LayaGL.instance,
                i = new Float32Array([-1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1]),
                a = new Uint8Array([0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 0, 3, 7, 7, 4, 0, 1, 5, 6, 6, 2, 1, 3, 2, 6, 6, 7, 3, 0, 4, 5, 5, 1, 0]),
                n = ce.getVertexDeclaration("POSITION");
            _this26._vertexBuffer = new be(8 * n.vertexStride, r.STATIC_DRAW, !1), _this26._vertexBuffer.vertexDeclaration = n,
                _this26._indexBuffer = new Ye(e.IndexFormat.UInt8, 36, r.STATIC_DRAW, !1), _this26._vertexBuffer.setData(i.buffer),
                _this26._indexBuffer.setData(a);
            var s = new Xe();
            s.bind(), s.applyVertexBuffer(_this26._vertexBuffer), s.applyIndexBuffer(_this26._indexBuffer),
                s.unBind(), _this26._bufferState = s;
            return _this26;
        }
        _createClass(je, [{
            key: "_render",
            value: function _render(e) {
                var r = t.LayaGL.instance;
                r.drawElements(r.TRIANGLES, 36, r.UNSIGNED_BYTE, 0), t.Stat.trianglesFaces += 12,
                    t.Stat.renderBatches++;
            }
        }]);
        return je;
    }(Ze);
    var qe = /* */ function() {
        function qe() {
            _classCallCheck(this, qe);
            this._mesh = je.instance;
        }
        _createClass(qe, [{
            key: "_isAvailable",
            value: function _isAvailable() {
                return !(!this._material || !this._mesh);
            }
        }, {
            key: "_render",
            value: function _render(e) {
                if (this._material && this._mesh) {
                    var r = t.LayaGL.instance,
                        i = e.scene,
                        a = e.camera,
                        s = k._SET_RUNTIME_VALUE_MODE_REFERENCE_;
                    t.ILaya.Render.supportWebGLPlusRendering && k.setRuntimeValueMode(!1), t.WebGLContext.setCullFace(r, !1),
                        t.WebGLContext.setDepthFunc(r, r.LEQUAL), t.WebGLContext.setDepthMask(r, !1);
                    var o = qe._compileDefine;
                    this._material._shaderValues._defineDatas.cloneTo(o);
                    var l = e.shader = this._material._shader.getSubShaderAt(0)._passes[0].withCompile(o),
                        _ = l.bind(),
                        h = t.Stat.loopCount !== l._uploadMark,
                        c = l._uploadScene !== i || h;
                    (c || _) && (l.uploadUniforms(l._sceneUniformParamsMap, i._shaderValues, c), l._uploadScene = i);
                    a._getRenderTexture();
                    var d = l._uploadCamera !== a || h;
                    if (d || _) {
                        var u = qe._tempMatrix0,
                            m = qe._tempMatrix1;
                        a.viewMatrix.cloneTo(u), a.projectionMatrix.cloneTo(m), u.setTranslationVector(n._ZERO),
                            a.orthographic && C.createPerspective(a.fieldOfView, a.aspectRatio, a.nearPlane, a.farPlane, m);
                        var f = 1 / Math.tan(3.1416 * a.fieldOfView / 180 * .5);
                        m.elements[0] = f / a.aspectRatio, m.elements[5] = f, m.elements[10] = 1e-6 - 1,
                            m.elements[11] = -1, m.elements[14] = -0, a._applyViewProject(e, u, m), l.uploadUniforms(l._cameraUniformParamsMap, a._shaderValues, d),
                            l._uploadCamera = a;
                    }
                    var E = l._uploadMaterial !== this._material || h;
                    (E || _) && (l.uploadUniforms(l._materialUniformParamsMap, this._material._shaderValues, E),
                        l._uploadMaterial = this._material), this._mesh._bufferState.bind(), this._mesh._render(e),
                        t.ILaya.Render.supportWebGLPlusRendering && k.setRuntimeValueMode(s), t.WebGLContext.setDepthFunc(r, r.LESS),
                        t.WebGLContext.setDepthMask(r, !0), a._applyViewProject(e, a.viewMatrix, a.projectionMatrix);
                }
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._material && (this._material._removeReference(), this._material = null);
            }
        }, {
            key: "material",
            get: function get() {
                return this._material;
            },
            set: function set(e) {
                this._material !== e && (this._material && this._material._removeReference(), e && e._addReference(),
                    this._material = e);
            }
        }, {
            key: "mesh",
            get: function get() {
                return this._mesh;
            },
            set: function set(e) {
                this._mesh !== e && (this._mesh = e);
            }
        }]);
        return qe;
    }();
    qe._tempMatrix0 = new C(), qe._tempMatrix1 = new C(), qe._compileDefine = new B();
    var Qe = /* */ function(_Le2) {
        _inherits(Qe, _Le2);

        function Qe() {
            var _this27;
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .3;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e3;
            _classCallCheck(this, Qe);
            _this27 = _possibleConstructorReturn(this, _getPrototypeOf(Qe).call(this)), _this27._skyRenderer = new qe(),
                _this27._forward = new n(), _this27._up = new n(), _this27.clearColor = new a(100 / 255, 149 / 255, 237 / 255, 1),
                _this27._shaderValues = new k(null), _this27._fieldOfView = 60, _this27._useUserProjectionMatrix = !1,
                _this27._orthographic = !1, _this27._orthographicVerticalSize = 10, _this27.renderingOrder = 0,
                _this27._nearPlane = e, _this27._farPlane = t, _this27.cullingMask = 2147483647,
                _this27.useOcclusionCulling = !0;
            return _this27;
        }
        _createClass(Qe, [{
            key: "_sortCamerasByRenderingOrder",
            value: function _sortCamerasByRenderingOrder() {
                if (this.displayedInStage)
                    for (var e = this.scene._cameraPool, t = e.length - 1, r = 0; r < t; r++) {
                        if (e[r].renderingOrder > e[t].renderingOrder) {
                            var i = e[r];
                            e[r] = e[t], e[t] = i;
                        }
                    }
            }
        }, {
            key: "_calculateProjectionMatrix",
            value: function _calculateProjectionMatrix() {}
        }, {
            key: "_onScreenSizeChanged",
            value: function _onScreenSizeChanged() {
                this._calculateProjectionMatrix();
            }
        }, {
            key: "_prepareCameraToRender",
            value: function _prepareCameraToRender() {
                var e = this._shaderValues;
                this.transform.getForward(this._forward), this.transform.getUp(this._up), e.setVector3(Qe.CAMERAPOS, this.transform.position),
                    e.setVector3(Qe.CAMERADIRECTION, this._forward), e.setVector3(Qe.CAMERAUP, this._up);
            }
        }, {
            key: "render",
            value: function render() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            }
        }, {
            key: "addLayer",
            value: function addLayer(e) {
                this.cullingMask |= Math.pow(2, e);
            }
        }, {
            key: "removeLayer",
            value: function removeLayer(e) {
                this.cullingMask &= ~Math.pow(2, e);
            }
        }, {
            key: "addAllLayers",
            value: function addAllLayers() {
                this.cullingMask = 2147483647;
            }
        }, {
            key: "removeAllLayers",
            value: function removeAllLayers() {
                this.cullingMask = 0;
            }
        }, {
            key: "resetProjectionMatrix",
            value: function resetProjectionMatrix() {
                this._useUserProjectionMatrix = !1, this._calculateProjectionMatrix();
            }
        }, {
            key: "_onActive",
            value: function _onActive() {
                this._scene._addCamera(this), _get(_getPrototypeOf(Qe.prototype), "_onActive", this).call(this);
            }
        }, {
            key: "_onInActive",
            value: function _onInActive() {
                this._scene._removeCamera(this), _get(_getPrototypeOf(Qe.prototype), "_onInActive", this).call(this);
            }
        }, {
            key: "_parse",
            value: function _parse(e, r) {
                _get(_getPrototypeOf(Qe.prototype), "_parse", this).call(this, e, r), this.orthographic = e.orthographic,
                    void 0 !== e.orthographicVerticalSize && (this.orthographicVerticalSize = e.orthographicVerticalSize),
                    void 0 !== e.fieldOfView && (this.fieldOfView = e.fieldOfView), this.nearPlane = e.nearPlane,
                    this.farPlane = e.farPlane;
                var i = e.clearColor;
                this.clearColor = new a(i[0], i[1], i[2], i[3]);
                var n = e.skyboxMaterial;
                n && (this._skyRenderer.material = t.Loader.getRes(n.path));
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
                this._skyRenderer.destroy(), this._skyRenderer = null, t.Laya.stage.off(t.Event.RESIZE, this, this._onScreenSizeChanged),
                    _get(_getPrototypeOf(Qe.prototype), "destroy", this).call(this, e);
            }
        }, {
            key: "_create",
            value: function _create() {
                return new Qe();
            }
        }, {
            key: "skyRenderer",
            get: function get() {
                return this._skyRenderer;
            }
        }, {
            key: "fieldOfView",
            get: function get() {
                return this._fieldOfView;
            },
            set: function set(e) {
                this._fieldOfView = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "nearPlane",
            get: function get() {
                return this._nearPlane;
            },
            set: function set(e) {
                this._nearPlane = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "farPlane",
            get: function get() {
                return this._farPlane;
            },
            set: function set(e) {
                this._farPlane = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "orthographic",
            get: function get() {
                return this._orthographic;
            },
            set: function set(e) {
                this._orthographic = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "orthographicVerticalSize",
            get: function get() {
                return this._orthographicVerticalSize;
            },
            set: function set(e) {
                this._orthographicVerticalSize = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "renderingOrder",
            get: function get() {
                return this._renderingOrder;
            },
            set: function set(e) {
                this._renderingOrder = e, this._sortCamerasByRenderingOrder();
            }
        }]);
        return Qe;
    }(Le);
    Qe._tempMatrix4x40 = new C(), Qe.CAMERAPOS = H.propertyNameToID("u_CameraPos"),
        Qe.VIEWMATRIX = H.propertyNameToID("u_View"), Qe.PROJECTMATRIX = H.propertyNameToID("u_Projection"),
        Qe.VIEWPROJECTMATRIX = H.propertyNameToID("u_ViewProjection"), Qe.CAMERADIRECTION = H.propertyNameToID("u_CameraDirection"),
        Qe.CAMERAUP = H.propertyNameToID("u_CameraUp"), Qe.VIEWPORT = H.propertyNameToID("u_Viewport"),
        Qe.PROJECTION_PARAMS = H.propertyNameToID("u_ProjectionParams"), Qe.RENDERINGTYPE_DEFERREDLIGHTING = "DEFERREDLIGHTING",
        Qe.RENDERINGTYPE_FORWARDRENDERING = "FORWARDRENDERING", Qe._invertYScaleMatrix = new C(1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        Qe._invertYProjectionMatrix = new C(), Qe._invertYProjectionViewMatrix = new C(),
        Qe.CLEARFLAG_SOLIDCOLOR = 0, Qe.CLEARFLAG_SKY = 1, Qe.CLEARFLAG_DEPTHONLY = 2, Qe.CLEARFLAG_NONE = 3;
    var Ke = /* */ function(_t$Resource5) {
        _inherits(Ke, _t$Resource5);

        function Ke() {
            var _this28;
            _classCallCheck(this, Ke);
            _this28 = _possibleConstructorReturn(this, _getPrototypeOf(Ke).call(this)), _this28._bufferState = new Xe(),
                _this28._bufferStateInvertUV = new Xe();
            var e = t.LayaGL.instance;
            _this28._vertexBuffer = new be(64, e.STATIC_DRAW, !1), _this28._vertexBuffer.vertexDeclaration = Ke._vertexDeclaration,
                _this28._vertexBuffer.setData(Ke._vertices.buffer), _this28._bufferState.bind(),
                _this28._bufferState.applyVertexBuffer(_this28._vertexBuffer), _this28._bufferState.unBind(),
                _this28._vertexBufferInvertUV = new be(64, e.STATIC_DRAW, !1), _this28._vertexBufferInvertUV.vertexDeclaration = Ke._vertexDeclaration,
                _this28._vertexBufferInvertUV.setData(Ke._verticesInvertUV.buffer), _this28._bufferStateInvertUV.bind(),
                _this28._bufferStateInvertUV.applyVertexBuffer(_this28._vertexBufferInvertUV), _this28._bufferStateInvertUV.unBind(),
                _this28._setGPUMemory(_this28._vertexBuffer._byteLength + _this28._vertexBufferInvertUV._byteLength);
            return _this28;
        }
        _createClass(Ke, [{
            key: "render",
            value: function render() {
                var e = t.LayaGL.instance;
                this._bufferState.bind(), e.drawArrays(e.TRIANGLE_STRIP, 0, 4), t.Stat.renderBatches++;
            }
        }, {
            key: "renderInvertUV",
            value: function renderInvertUV() {
                var e = t.LayaGL.instance;
                this._bufferStateInvertUV.bind(), e.drawArrays(e.TRIANGLE_STRIP, 0, 4), t.Stat.renderBatches++;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                _get(_getPrototypeOf(Ke.prototype), "destroy", this).call(this), this._bufferState.destroy(),
                    this._vertexBuffer.destroy(), this._bufferStateInvertUV.destroy(), this._vertexBufferInvertUV.destroy(),
                    this._setGPUMemory(0);
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                Ke._vertexDeclaration = new _e(16, [new he(0, le.Vector4, Ke.SCREENQUAD_POSITION_UV)]),
                    Ke.instance = new Ke(), Ke.instance.lock = !0;
            }
        }]);
        return Ke;
    }(t.Resource);
    Ke.SCREENQUAD_POSITION_UV = 0, Ke._vertices = new Float32Array([1, 1, 1, 1, 1, -1, 1, 0, -1, 1, 0, 1, -1, -1, 0, 0]),
        Ke._verticesInvertUV = new Float32Array([1, 1, 1, 0, 1, -1, 1, 1, -1, 1, 0, 0, -1, -1, 0, 1]);
    var Je = /* */ function(_t$Resource6) {
        _inherits(Je, _t$Resource6);

        function Je() {
            var _this29;
            _classCallCheck(this, Je);
            _this29 = _possibleConstructorReturn(this, _getPrototypeOf(Je).call(this)), _this29._bufferState = new Xe(),
                _this29._bufferStateInvertUV = new Xe();
            var e = t.LayaGL.instance;
            _this29._vertexBuffer = new be(48, e.STATIC_DRAW, !1), _this29._vertexBuffer.vertexDeclaration = Je._vertexDeclaration,
                _this29._vertexBuffer.setData(Je._vertices.buffer), _this29._bufferState.bind(),
                _this29._bufferState.applyVertexBuffer(_this29._vertexBuffer), _this29._bufferState.unBind(),
                _this29._vertexBufferInvertUV = new be(48, e.STATIC_DRAW, !1), _this29._vertexBufferInvertUV.vertexDeclaration = Je._vertexDeclaration,
                _this29._vertexBufferInvertUV.setData(Je._verticesInvertUV.buffer), _this29._bufferStateInvertUV.bind(),
                _this29._bufferStateInvertUV.applyVertexBuffer(_this29._vertexBufferInvertUV), _this29._bufferStateInvertUV.unBind(),
                _this29._setGPUMemory(_this29._vertexBuffer._byteLength + _this29._vertexBufferInvertUV._byteLength);
            return _this29;
        }
        _createClass(Je, [{
            key: "render",
            value: function render() {
                var e = t.LayaGL.instance;
                this._bufferState.bind(), e.drawArrays(e.TRIANGLES, 0, 3), t.Stat.renderBatches++;
            }
        }, {
            key: "renderInvertUV",
            value: function renderInvertUV() {
                var e = t.LayaGL.instance;
                this._bufferStateInvertUV.bind(), e.drawArrays(e.TRIANGLES, 0, 3), t.Stat.renderBatches++;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                _get(_getPrototypeOf(Je.prototype), "destroy", this).call(this), this._bufferState.destroy(),
                    this._vertexBuffer.destroy(), this._bufferStateInvertUV.destroy(), this._vertexBufferInvertUV.destroy(),
                    this._setGPUMemory(0);
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                Je._vertexDeclaration = new _e(16, [new he(0, le.Vector4, Je.SCREENTRIANGLE_POSITION_UV)]),
                    Je.instance = new Je(), Je.instance.lock = !0;
            }
        }]);
        return Je;
    }(t.Resource);
    Je.SCREENTRIANGLE_POSITION_UV = 0, Je._vertices = new Float32Array([-1, -1, 0, 0, -1, 3, 0, 2, 3, -1, 2, 0]),
        Je._verticesInvertUV = new Float32Array([-1, -1, 0, 1, -1, 3, 0, -1, 3, -1, 2, 1]);
    var $e = /* */ function() {
        function $e() {
            _classCallCheck(this, $e);
            this._commandBuffer = null;
        }
        _createClass($e, [{
            key: "run",
            value: function run() {}
        }, {
            key: "recover",
            value: function recover() {
                this._commandBuffer = null;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                $e._screenShaderData = new k(), $e._screenShader = H.find("BlitScreen");
            }
        }]);
        return $e;
    }();
    $e.SCREENTEXTURE_NAME = "u_MainTex", $e.SCREENTEXTUREOFFSETSCALE_NAME = "u_OffsetScale",
        $e.MAINTEXTURE_TEXELSIZE_NAME = "u_MainTex_TexelSize", $e.SCREENTEXTURE_ID = H.propertyNameToID($e.SCREENTEXTURE_NAME),
        $e.SCREENTEXTUREOFFSETSCALE_ID = H.propertyNameToID($e.SCREENTEXTUREOFFSETSCALE_NAME),
        $e.MAINTEXTURE_TEXELSIZE_ID = H.propertyNameToID($e.MAINTEXTURE_TEXELSIZE_NAME);
    var et = /* */ function(_$e) {
        _inherits(et, _$e);

        function et() {
            var _this30;
            _classCallCheck(this, et);
            _this30 = _possibleConstructorReturn(this, _getPrototypeOf(et).apply(this, arguments)),
                _this30._source = null, _this30._dest = null, _this30._offsetScale = null, _this30._shader = null,
                _this30._shaderData = null, _this30._subShader = 0, _this30._sourceTexelSize = new a(),
                _this30._screenType = 0;
            return _this30;
        }
        _createClass(et, [{
            key: "run",
            value: function run() {
                var e = this._shader || $e._screenShader,
                    r = this._shaderData || $e._screenShaderData,
                    i = this._dest;
                t.LayaGL.instance.viewport(0, 0, i ? i.width : w.clientWidth, i ? i.height : w.clientHeight),
                    r.setTexture($e.SCREENTEXTURE_ID, this._source), r.setVector($e.SCREENTEXTUREOFFSETSCALE_ID, this._offsetScale || et._defaultOffsetScale),
                    this._sourceTexelSize.setValue(1 / this._source.width, 1 / this._source.height, this._source.width, this._source.height),
                    r.setVector($e.MAINTEXTURE_TEXELSIZE_ID, this._sourceTexelSize), i && i._start();
                for (var a = e.getSubShaderAt(this._subShader)._passes, n = 0, s = a.length; n < s; n++) {
                    var o = et._compileDefine;
                    r._defineDatas.cloneTo(o);
                    var l = a[n].withCompile(o);
                    switch (l.bind(), l.uploadUniforms(l._materialUniformParamsMap, r, !0), l.uploadRenderStateBlendDepth(r),
                        l.uploadRenderStateFrontFace(r, !1, null), this._screenType) {
                        case et._SCREENTYPE_QUAD:
                            w._instance.invertY ? Ke.instance.renderInvertUV() : Ke.instance.render();
                            break;

                        case et._SCREENTYPE_TRIANGLE:
                            w._instance.invertY ? Je.instance.renderInvertUV() : Je.instance.render();
                            break;

                        default:
                            throw "BlitScreenQuadCMD:unknown screen Type.";
                    }
                }
                i && i._end();
            }
        }, {
            key: "recover",
            value: function recover() {
                et._pool.push(this), this._source = null, this._dest = null, this._offsetScale = null,
                    this._shader = null, this._shaderData = null, _get(_getPrototypeOf(et.prototype), "recover", this).call(this);
            }
        }], [{
            key: "create",
            value: function create(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
                var n = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
                var s = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : et._SCREENTYPE_QUAD;
                var o;
                return (o = et._pool.length > 0 ? et._pool.pop() : new et())._source = e, o._dest = t,
                    o._offsetScale = r, o._shader = i, o._shaderData = a, o._subShader = n, o._screenType = s,
                    o;
            }
        }]);
        return et;
    }($e);
    et._SCREENTYPE_QUAD = 0, et._SCREENTYPE_TRIANGLE = 1, et._compileDefine = new B(),
        et._pool = [], et._defaultOffsetScale = new a(0, 0, 1, 1);
    var tt = /* */ function(_$e2) {
        _inherits(tt, _$e2);

        function tt() {
            var _this31;
            _classCallCheck(this, tt);
            _this31 = _possibleConstructorReturn(this, _getPrototypeOf(tt).apply(this, arguments)),
                _this31._renderTexture = null;
            return _this31;
        }
        _createClass(tt, [{
            key: "run",
            value: function run() {
                this._renderTexture._start();
            }
        }, {
            key: "recover",
            value: function recover() {
                tt._pool.push(this), this._renderTexture = null;
            }
        }], [{
            key: "create",
            value: function create(e) {
                var t;
                return (t = tt._pool.length > 0 ? tt._pool.pop() : new tt())._renderTexture = e,
                    t;
            }
        }]);
        return tt;
    }($e);
    tt._pool = [];
    var rt = /* */ function(_$e3) {
        _inherits(rt, _$e3);

        function rt() {
            var _this32;
            _classCallCheck(this, rt);
            _this32 = _possibleConstructorReturn(this, _getPrototypeOf(rt).apply(this, arguments)),
                _this32._shaderData = null, _this32._nameID = 0, _this32._texture = null;
            return _this32;
        }
        _createClass(rt, [{
            key: "run",
            value: function run() {
                this._shaderData.setTexture(this._nameID, this._texture);
            }
        }, {
            key: "recover",
            value: function recover() {
                rt._pool.push(this), this._shaderData = null, this._nameID = 0, this._texture = null;
            }
        }], [{
            key: "create",
            value: function create(e, t, r) {
                var i;
                return (i = rt._pool.length > 0 ? rt._pool.pop() : new rt())._shaderData = e, i._nameID = t,
                    i._texture = r, i;
            }
        }]);
        return rt;
    }($e);
    rt._pool = [];
    var it = /* */ function() {
        function it() {
            _classCallCheck(this, it);
            this._camera = null, this._commands = [];
        }
        _createClass(it, [{
            key: "_apply",
            value: function _apply() {
                for (var e = 0, t = this._commands.length; e < t; e++) {
                    this._commands[e].run();
                }
            }
        }, {
            key: "setShaderDataTexture",
            value: function setShaderDataTexture(e, t, r) {
                this._commands.push(rt.create(e, t, r));
            }
        }, {
            key: "blitScreenQuad",
            value: function blitScreenQuad(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
                var n = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
                this._commands.push(et.create(e, t, r, i, a, n, et._SCREENTYPE_QUAD));
            }
        }, {
            key: "blitScreenTriangle",
            value: function blitScreenTriangle(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
                var n = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
                this._commands.push(et.create(e, t, r, i, a, n, et._SCREENTYPE_TRIANGLE));
            }
        }, {
            key: "setRenderTarget",
            value: function setRenderTarget(e) {
                this._commands.push(tt.create(e));
            }
        }, {
            key: "clear",
            value: function clear() {
                for (var e = 0, t = this._commands.length; e < t; e++) {
                    this._commands[e].recover();
                }
                this._commands.length = 0;
            }
        }]);
        return it;
    }();
    var at = function at() {
        _classCallCheck(this, at);
    };
    (fe = e.CameraClearFlags || (e.CameraClearFlags = {}))[fe.SolidColor = 0] = "SolidColor",
    fe[fe.Sky = 1] = "Sky", fe[fe.DepthOnly = 2] = "DepthOnly", fe[fe.Nothing = 3] = "Nothing";
    var nt = /* */ function(_Qe) {
        _inherits(nt, _Qe);

        function nt() {
            var _this33;
            var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .3;
            var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e3;
            _classCallCheck(this, nt);
            _this33 = _possibleConstructorReturn(this, _getPrototypeOf(nt).call(this, n, s)),
                _this33._updateViewMatrix = !0, _this33._postProcess = null, _this33._enableHDR = !1,
                _this33._viewportParams = new a(), _this33._projectionParams = new a(), _this33._offScreenRenderTexture = null,
                _this33._internalRenderTexture = null, _this33._postProcessCommandBuffers = [],
                _this33._clusterPlaneCacheFlag = new i(-1, -1), _this33._screenOffsetScale = new a(),
                _this33.enableRender = !0, _this33.clearFlag = e.CameraClearFlags.SolidColor, _this33._viewMatrix = new C(),
                _this33._projectionMatrix = new C(), _this33._projectionViewMatrix = new C(), _this33._viewport = new ke(0, 0, 0, 0),
                _this33._normalizedViewport = new ke(0, 0, 1, 1), _this33._aspectRatio = r, _this33._boundFrustum = new He(C.DEFAULT),
                t.Render.supportWebGLPlusCulling && (_this33._boundFrustumBuffer = new Float32Array(24)),
                _this33._calculateProjectionMatrix(), t.Laya.stage.on(t.Event.RESIZE, _assertThisInitialized(_this33), _this33._onScreenSizeChanged),
                _this33.transform.on(t.Event.TRANSFORM_CHANGED, _assertThisInitialized(_this33), _this33._onTransformChanged);
            return _this33;
        }
        _createClass(nt, [{
            key: "_calculationViewport",
            value: function _calculationViewport(e, t, r) {
                var i = e.x * t,
                    a = e.y * r,
                    n = i + Math.max(e.width * t, 0),
                    s = a + Math.max(e.height * r, 0),
                    o = Math.ceil(i),
                    l = Math.ceil(a),
                    _ = Math.floor(n),
                    h = Math.floor(s),
                    c = o - i >= .5 ? Math.floor(i) : o,
                    d = l - a >= .5 ? Math.floor(a) : l,
                    u = n - _ >= .5 ? Math.ceil(n) : _,
                    m = s - h >= .5 ? Math.ceil(s) : h;
                this._viewport.x = c, this._viewport.y = d, this._viewport.width = u - c, this._viewport.height = m - d;
            }
        }, {
            key: "_calculateProjectionMatrix",
            value: function _calculateProjectionMatrix() {
                if (!this._useUserProjectionMatrix)
                    if (this._orthographic) {
                        var e = .5 * this.orthographicVerticalSize,
                            t = e * this.aspectRatio;
                        C.createOrthoOffCenter(-t, t, -e, e, this.nearPlane, this.farPlane, this._projectionMatrix);
                    } else C.createPerspective(3.1416 * this.fieldOfView / 180, this.aspectRatio, this.nearPlane, this.farPlane, this._projectionMatrix);
            }
        }, {
            key: "_isLayerVisible",
            value: function _isLayerVisible(e) {
                return 0 != (Math.pow(2, e) & this.cullingMask);
            }
        }, {
            key: "_onTransformChanged",
            value: function _onTransformChanged(e) {
                (e &= De.TRANSFORM_WORLDMATRIX) && (this._updateViewMatrix = !0);
            }
        }, {
            key: "_parse",
            value: function _parse(e, t) {
                _get(_getPrototypeOf(nt.prototype), "_parse", this).call(this, e, t);
                var r = e.clearFlag;
                void 0 !== r && (this.clearFlag = r);
                var i = e.viewport;
                this.normalizedViewport = new ke(i[0], i[1], i[2], i[3]);
                var a = e.enableHDR;
                void 0 !== a && (this.enableHDR = a);
            }
        }, {
            key: "_getCanvasWidth",
            value: function _getCanvasWidth() {
                return this._offScreenRenderTexture ? this._offScreenRenderTexture.width : w.clientWidth;
            }
        }, {
            key: "_getCanvasHeight",
            value: function _getCanvasHeight() {
                return this._offScreenRenderTexture ? this._offScreenRenderTexture.height : w.clientHeight;
            }
        }, {
            key: "_getRenderTexture",
            value: function _getRenderTexture() {
                return this._internalRenderTexture || this._offScreenRenderTexture;
            }
        }, {
            key: "_needInternalRenderTexture",
            value: function _needInternalRenderTexture() {
                return !(!this._postProcess && !this._enableHDR);
            }
        }, {
            key: "_applyPostProcessCommandBuffers",
            value: function _applyPostProcessCommandBuffers() {
                for (var e = 0, t = this._postProcessCommandBuffers.length; e < t; e++) {
                    this._postProcessCommandBuffers[e]._apply();
                }
            }
        }, {
            key: "_getRenderTextureFormat",
            value: function _getRenderTextureFormat() {
                return this._enableHDR ? t.RenderTextureFormat.R16G16B16A16 : t.RenderTextureFormat.R8G8B8;
            }
        }, {
            key: "_prepareCameraToRender",
            value: function _prepareCameraToRender() {
                _get(_getPrototypeOf(nt.prototype), "_prepareCameraToRender", this).call(this);
                var e = this.viewport;
                this._viewportParams.setValue(e.x, e.y, e.width, e.height), this._projectionParams.setValue(this._nearPlane, this._farPlane, w._instance.invertY ? -1 : 1, 0),
                    this._shaderValues.setVector(Qe.VIEWPORT, this._viewportParams), this._shaderValues.setVector(Qe.PROJECTION_PARAMS, this._projectionParams);
            }
        }, {
            key: "_applyViewProject",
            value: function _applyViewProject(e, t, r) {
                var i, a = this._shaderValues;
                e.invertY ? (C.multiply(Qe._invertYScaleMatrix, r, Qe._invertYProjectionMatrix),
                        C.multiply(Qe._invertYProjectionMatrix, t, Qe._invertYProjectionViewMatrix), r = Qe._invertYProjectionMatrix,
                        i = Qe._invertYProjectionViewMatrix) : (C.multiply(r, t, this._projectionViewMatrix),
                        i = this._projectionViewMatrix), e.viewMatrix = t, e.projectionMatrix = r, e.projectionViewMatrix = i,
                    a.setMatrix4x4(Qe.VIEWMATRIX, t), a.setMatrix4x4(Qe.PROJECTMATRIX, r), a.setMatrix4x4(Qe.VIEWPROJECTMATRIX, i);
            }
        }, {
            key: "_updateClusterPlaneXY",
            value: function _updateClusterPlaneXY() {
                var e = this.fieldOfView,
                    t = this.aspectRatio;
                if (this._clusterPlaneCacheFlag.x !== e || this._clusterPlaneCacheFlag.y !== t) {
                    var r = l._config.lightClusterCount,
                        i = r.x,
                        a = r.y,
                        s = i + 1,
                        o = a + 1,
                        _ = this._clusterXPlanes,
                        h = this._clusterYPlanes;
                    if (!_) {
                        _ = this._clusterXPlanes = new Array(s), h = this._clusterYPlanes = new Array(o);
                        for (var c = 0; c < s; c++) {
                            _[c] = new n();
                        }
                        for (c = 0; c < o; c++) {
                            h[c] = new n();
                        }
                    }
                    var d = Math.tan(this.fieldOfView / 2 * Math.PI / 180),
                        u = this.aspectRatio * d,
                        m = 2 * d / i,
                        f = 2 * u / a;
                    for (c = 0; c < s; c++) {
                        var E = f * c - u,
                            T = 1 / Math.sqrt(1 + E * E);
                        _[c].setValue(T, 0, -E * T);
                    }
                    for (c = 0; c < o; c++) {
                        E = d - m * c;
                        var p = -1 / Math.sqrt(1 + E * E);
                        h[c].setValue(0, p, -E * p);
                    }
                    this._clusterPlaneCacheFlag.x = e, this._clusterPlaneCacheFlag.y = t;
                }
            }
        }, {
            key: "render",
            value: function render() {
                var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                if (this.activeInHierarchy) {
                    var a = this.viewport,
                        n = this._needInternalRenderTexture(),
                        s = t.LayaGL.instance,
                        o = w._instance,
                        _ = o.scene = this._scene;
                    if (this._internalRenderTexture = n ? F.createFromPool(a.width, a.height, this._getRenderTextureFormat(), t.RenderTextureDepthFormat.DEPTH_16, t.FilterMode.Bilinear) : null,
                        _.parallelSplitShadowMaps[0]) {
                        k.setRuntimeValueMode(!1);
                        var h = _.parallelSplitShadowMaps[0];
                        h._calcAllLightCameraInfo(this), _._shaderValues.addDefine(at.SHADERDEFINE_CAST_SHADOW);
                        for (var c = 0, d = h.shadowMapCount; c < d; c++) {
                            var u = h.cameras[c];
                            o.camera = u, Oe.renderObjectCulling(u, _, o, r, i, !0);
                            var m = h.cameras[c + 1].renderTarget;
                            m._start(), w._instance.invertY = !1, o.camera = u, nt._updateMark++, o.viewport = u.viewport,
                                u._prepareCameraToRender(), u._applyViewProject(o, u.viewMatrix, u.projectionMatrix),
                                _._clear(s, o), _._opaqueQueue._render(o), m._end();
                        }
                        _._shaderValues.removeDefine(at.SHADERDEFINE_CAST_SHADOW), k.setRuntimeValueMode(!0);
                    }
                    if (o.camera = this, nt._updateMark++, _._preRenderScript(), n && !this._offScreenRenderTexture && (this.clearFlag == e.CameraClearFlags.DepthOnly || this.clearFlag == e.CameraClearFlags.Nothing))
                        if (this._enableHDR) {
                            var f = F.createFromPool(a.width, a.height, t.RenderTextureFormat.R8G8B8, t.RenderTextureDepthFormat.DEPTH_16, t.FilterMode.Bilinear);
                            t.WebGLContext.bindTexture(s, s.TEXTURE_2D, f._getSource()), s.copyTexSubImage2D(s.TEXTURE_2D, 0, 0, 0, a.x, w.clientHeight - (a.y + a.height), a.width, a.height),
                                (T = et.create(f, this._internalRenderTexture)).run(), T.recover(), F.recoverToPool(f);
                        } else t.WebGLContext.bindTexture(s, s.TEXTURE_2D, this._internalRenderTexture._getSource()),
                            s.copyTexSubImage2D(s.TEXTURE_2D, 0, 0, 0, a.x, w.clientHeight - (a.y + a.height), a.width, a.height);
                    var E = this._getRenderTexture();
                    if (E && E._start(), o.viewport = a, this._prepareCameraToRender(), l._config._multiLighting && Fe.instance.update(this, this._scene),
                        this._applyViewProject(o, this.viewMatrix, this._projectionMatrix), _._preCulling(o, this, r, i),
                        _._clear(s, o), _._renderScene(o), _._postRenderScript(), E && E._end(), n) {
                        if (this._postProcess) this._postProcess._render(), this._applyPostProcessCommandBuffers();
                        else if (this._enableHDR) {
                            var T, p = this._getCanvasWidth(),
                                g = this._getCanvasHeight();
                            this._screenOffsetScale.setValue(a.x / p, a.y / g, a.width / p, a.height / g), (T = et.create(this._internalRenderTexture, this._offScreenRenderTexture ? this._offScreenRenderTexture : null, this._screenOffsetScale)).run(),
                                T.recover();
                        }
                        F.recoverToPool(this._internalRenderTexture);
                    }
                }
            }
        }, {
            key: "viewportPointToRay",
            value: function viewportPointToRay(e, t) {
                We.calculateCursorRay(e, this.viewport, this._projectionMatrix, this.viewMatrix, null, t);
            }
        }, {
            key: "normalizedViewportPointToRay",
            value: function normalizedViewportPointToRay(e, t) {
                var r = nt._tempVector20,
                    i = this.viewport;
                r.x = e.x * i.width, r.y = e.y * i.height, We.calculateCursorRay(r, this.viewport, this._projectionMatrix, this.viewMatrix, null, t);
            }
        }, {
            key: "worldToViewportPoint",
            value: function worldToViewportPoint(e, r) {
                C.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix),
                    this.viewport.project(e, this._projectionViewMatrix, r), r.x = r.x / t.Laya.stage.clientScaleX,
                    r.y = r.y / t.Laya.stage.clientScaleY;
            }
        }, {
            key: "worldToNormalizedViewportPoint",
            value: function worldToNormalizedViewportPoint(e, r) {
                C.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix),
                    this.normalizedViewport.project(e, this._projectionViewMatrix, r), r.x = r.x / t.Laya.stage.clientScaleX,
                    r.y = r.y / t.Laya.stage.clientScaleY;
            }
        }, {
            key: "convertScreenCoordToOrthographicCoord",
            value: function convertScreenCoordToOrthographicCoord(e, r) {
                if (this._orthographic) {
                    var i = w.clientWidth,
                        a = w.clientHeight,
                        s = this.orthographicVerticalSize * this.aspectRatio / i,
                        o = this.orthographicVerticalSize / a;
                    return r.x = (-i / 2 + e.x * t.Laya.stage.clientScaleX) * s, r.y = (a / 2 - e.y * t.Laya.stage.clientScaleY) * o,
                        r.z = (this.nearPlane - this.farPlane) * (e.z + 1) / 2 - this.nearPlane, n.transformCoordinate(r, this.transform.worldMatrix, r), !0;
                }
                return !1;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
                this._offScreenRenderTexture = null, this.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged),
                    _get(_getPrototypeOf(nt.prototype), "destroy", this).call(this, e);
            }
        }, {
            key: "addCommandBuffer",
            value: function addCommandBuffer(e, t) {
                switch (e) {
                    case nt.CAMERAEVENT_POSTPROCESS:
                        this._postProcessCommandBuffers.push(t), t._camera = this;
                        break;

                    default:
                        throw "Camera:unknown event.";
                }
            }
        }, {
            key: "removeCommandBuffer",
            value: function removeCommandBuffer(e, t) {
                switch (e) {
                    case nt.CAMERAEVENT_POSTPROCESS:
                        var r = this._postProcessCommandBuffers.indexOf(t); -
                        1 !== r && this._postProcessCommandBuffers.splice(r, 1);
                        break;

                    default:
                        throw "Camera:unknown event.";
                }
            }
        }, {
            key: "removeCommandBuffers",
            value: function removeCommandBuffers(e) {
                switch (e) {
                    case nt.CAMERAEVENT_POSTPROCESS:
                        this._postProcessCommandBuffers.length = 0;
                        break;

                    default:
                        throw "Camera:unknown event.";
                }
            }
        }, {
            key: "_create",
            value: function _create() {
                return new nt();
            }
        }, {
            key: "aspectRatio",
            get: function get() {
                if (0 === this._aspectRatio) {
                    var e = this.viewport;
                    return e.width / e.height;
                }
                return this._aspectRatio;
            },
            set: function set(e) {
                if (e < 0) throw new Error("Camera: the aspect ratio has to be a positive real number.");
                this._aspectRatio = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "viewport",
            get: function get() {
                return this._offScreenRenderTexture ? this._calculationViewport(this._normalizedViewport, this._offScreenRenderTexture.width, this._offScreenRenderTexture.height) : this._calculationViewport(this._normalizedViewport, w.clientWidth, w.clientHeight),
                    this._viewport;
            },
            set: function set(e) {
                var t, r;
                this._offScreenRenderTexture ? (t = this._offScreenRenderTexture.width, r = this._offScreenRenderTexture.height) : (t = w.clientWidth,
                        r = w.clientHeight), this._normalizedViewport.x = e.x / t, this._normalizedViewport.y = e.y / r,
                    this._normalizedViewport.width = e.width / t, this._normalizedViewport.height = e.height / r,
                    this._calculationViewport(this._normalizedViewport, t, r), this._calculateProjectionMatrix();
            }
        }, {
            key: "normalizedViewport",
            get: function get() {
                return this._normalizedViewport;
            },
            set: function set(e) {
                var t, r;
                this._offScreenRenderTexture ? (t = this._offScreenRenderTexture.width, r = this._offScreenRenderTexture.height) : (t = w.clientWidth,
                        r = w.clientHeight), this._normalizedViewport !== e && e.cloneTo(this._normalizedViewport),
                    this._calculationViewport(e, t, r), this._calculateProjectionMatrix();
            }
        }, {
            key: "viewMatrix",
            get: function get() {
                if (this._updateViewMatrix) {
                    var e = this.transform.getWorldLossyScale(),
                        t = e.x,
                        r = e.y,
                        i = e.z,
                        a = this._viewMatrix.elements;
                    this.transform.worldMatrix.cloneTo(this._viewMatrix), a[0] /= t, a[1] /= t, a[2] /= t,
                        a[4] /= r, a[5] /= r, a[6] /= r, a[8] /= i, a[9] /= i, a[10] /= i, this._viewMatrix.invert(this._viewMatrix),
                        this._updateViewMatrix = !1;
                }
                return this._viewMatrix;
            }
        }, {
            key: "projectionMatrix",
            get: function get() {
                return this._projectionMatrix;
            },
            set: function set(e) {
                this._projectionMatrix = e, this._useUserProjectionMatrix = !0;
            }
        }, {
            key: "projectionViewMatrix",
            get: function get() {
                return C.multiply(this.projectionMatrix, this.viewMatrix, this._projectionViewMatrix),
                    this._projectionViewMatrix;
            }
        }, {
            key: "boundFrustum",
            get: function get() {
                if (this._boundFrustum.matrix = this.projectionViewMatrix, t.Render.supportWebGLPlusCulling) {
                    var e = this._boundFrustum.near,
                        r = this._boundFrustum.far,
                        i = this._boundFrustum.left,
                        a = this._boundFrustum.right,
                        n = this._boundFrustum.top,
                        s = this._boundFrustum.bottom,
                        o = e.normal,
                        l = r.normal,
                        _ = i.normal,
                        h = a.normal,
                        c = n.normal,
                        d = s.normal,
                        u = this._boundFrustumBuffer;
                    u[0] = o.x, u[1] = o.y, u[2] = o.z, u[3] = e.distance, u[4] = l.x, u[5] = l.y, u[6] = l.z,
                        u[7] = r.distance, u[8] = _.x, u[9] = _.y, u[10] = _.z, u[11] = i.distance, u[12] = h.x,
                        u[13] = h.y, u[14] = h.z, u[15] = a.distance, u[16] = c.x, u[17] = c.y, u[18] = c.z,
                        u[19] = n.distance, u[20] = d.x, u[21] = d.y, u[22] = d.z, u[23] = s.distance;
                }
                return this._boundFrustum;
            }
        }, {
            key: "renderTarget",
            get: function get() {
                return this._offScreenRenderTexture;
            },
            set: function set(e) {
                var t = this._offScreenRenderTexture;
                t !== e && (t && (t._isCameraTarget = !1), e && (e._isCameraTarget = !0), this._offScreenRenderTexture = e,
                    this._calculateProjectionMatrix());
            }
        }, {
            key: "postProcess",
            get: function get() {
                return this._postProcess;
            },
            set: function set(e) {
                this._postProcess = e;
                var t = new it();
                this.addCommandBuffer(nt.CAMERAEVENT_POSTPROCESS, t), e._init(this, t);
            }
        }, {
            key: "enableHDR",
            get: function get() {
                return this._enableHDR;
            },
            set: function set(e) {
                !e || t.SystemUtils.supportRenderTextureFormat(t.RenderTextureFormat.R16G16B16A16) ? this._enableHDR = e : console.warn("Camera:can't enable HDR in this device.");
            }
        }]);
        return nt;
    }(Qe);
    nt.CAMERAEVENT_POSTPROCESS = 0, nt._tempVector20 = new i(), nt._updateMark = 0;
    var st = /* */ function() {
        function st() {
            _classCallCheck(this, st);
            this.renderSubShader = null, this.renderType = st.RENDERTYPE_NORMAL;
        }
        _createClass(st, [{
            key: "getInvertFront",
            value: function getInvertFront() {
                return this._transform._isFrontFaceInvert;
            }
        }, {
            key: "setTransform",
            value: function setTransform(e) {
                this._transform = e;
            }
        }, {
            key: "setGeometry",
            value: function setGeometry(e) {
                this._geometry = e;
            }
        }, {
            key: "addToOpaqueRenderQueue",
            value: function addToOpaqueRenderQueue(e, t) {
                t.elements.add(this);
            }
        }, {
            key: "addToTransparentRenderQueue",
            value: function addToTransparentRenderQueue(e, t) {
                t.elements.add(this), t.lastTransparentBatched = !1, t.lastTransparentRenderElement = this;
            }
        }, {
            key: "_update",
            value: function _update(e, t, r, i) {
                if (this.material) {
                    var a = this.material._shader.getSubShaderAt(0);
                    if (this.renderSubShader = null, r) {
                        if (i) {
                            var n = a.getFlag(i);
                            if (!n) return;
                            for (var s = r._subShaders, o = 0, l = s.length; o < l; o++) {
                                var _ = s[o];
                                if (n === _.getFlag(i)) {
                                    this.renderSubShader = _;
                                    break;
                                }
                            }
                            if (!this.renderSubShader) return;
                        } else this.renderSubShader = r.getSubShaderAt(0);
                    } else this.renderSubShader = a;
                    var h = e._getRenderQueue(this.material.renderQueue);
                    h.isTransparent ? this.addToTransparentRenderQueue(t, h) : this.addToOpaqueRenderQueue(t, h);
                }
            }
        }, {
            key: "_render",
            value: function _render(e) {
                var t, r, i, a = e.invertY,
                    n = nt._updateMark,
                    s = e.scene,
                    o = e.camera,
                    l = this._transform,
                    _ = this._geometry;
                e.renderElement = this;
                var h = n !== this.render._updateMark || this.renderType !== this.render._updateRenderType;
                if (h ? (this.render._renderUpdate(e, l), this.render._renderUpdateWithCamera(e, l),
                        this.render._updateMark = n, this.render._updateRenderType = this.renderType) : this.renderType == st.RENDERTYPE_INSTANCEBATCH && (this.render._renderUpdate(e, l),
                        this.render._renderUpdateWithCamera(e, l)), _._prepareRender(e))
                    for (var c = this.renderSubShader._passes, d = 0, u = c.length; d < u; d++) {
                        var m = st._compileDefine;
                        s._shaderValues._defineDatas.cloneTo(m), m.addDefineDatas(this.render._shaderValues._defineDatas),
                            m.addDefineDatas(this.material._shaderValues._defineDatas);
                        var f = e.shader = c[d].withCompile(m),
                            E = f.bind(),
                            T = n !== f._uploadMark,
                            p = f._uploadScene !== s || T;
                        (p || E) && (f.uploadUniforms(f._sceneUniformParamsMap, s._shaderValues, p), f._uploadScene = s);
                        var g = f._uploadRender !== this.render || f._uploadRenderType !== this.renderType || T;
                        (g || E) && (f.uploadUniforms(f._spriteUniformParamsMap, this.render._shaderValues, g),
                            f._uploadRender = this.render, f._uploadRenderType = this.renderType);
                        var S = f._uploadCamera !== o || T;
                        (S || E) && (f.uploadUniforms(f._cameraUniformParamsMap, o._shaderValues, S), f._uploadCamera = o);
                        var R = f._uploadMaterial !== this.material || T;
                        (R || E) && (f.uploadUniforms(f._materialUniformParamsMap, this.material._shaderValues, R),
                            f._uploadMaterial = this.material);
                        var v = this.material._shaderValues;
                        t !== this.material || r !== f ? (f.uploadRenderStateBlendDepth(v), f.uploadRenderStateFrontFace(v, a, this.getInvertFront()),
                            t = this.material, r = f, i = this.render) : i !== this.render && (f.uploadRenderStateFrontFace(v, a, this.getInvertFront()),
                            i = this.render), _._render(e), f._uploadMark = n;
                    }
                h && this.renderType !== st.RENDERTYPE_NORMAL && this.render._revertBatchRenderUpdate(e);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._transform = null, this._geometry = null, this.material = null, this.render = null;
            }
        }]);
        return st;
    }();
    st.RENDERTYPE_NORMAL = 0, st.RENDERTYPE_STATICBATCH = 1, st.RENDERTYPE_INSTANCEBATCH = 2,
        st.RENDERTYPE_VERTEXBATCH = 3, st._compileDefine = new B();
    var ot = /* */ function(_st) {
        _inherits(ot, _st);

        function ot() {
            var _this34;
            _classCallCheck(this, ot);
            _this34 = _possibleConstructorReturn(this, _getPrototypeOf(ot).call(this)), _this34._dynamicWorldPositionNormalNeedUpdate = !0;
            return _this34;
        }
        _createClass(ot, [{
            key: "_onWorldMatrixChanged",
            value: function _onWorldMatrixChanged() {
                this._dynamicWorldPositionNormalNeedUpdate = !0;
            }
        }, {
            key: "_computeWorldPositionsAndNormals",
            value: function _computeWorldPositionsAndNormals(e, t, r, i) {
                if (this._dynamicWorldPositionNormalNeedUpdate) {
                    for (var a = this._geometry, n = a._vertexBuffer, s = n.vertexDeclaration.vertexStride / 4, o = n.getFloat32Data(), l = this._transform.worldMatrix, _ = this._transform.rotation, h = a._indices, c = 0; c < i; c++) {
                        var d = (r ? h[c] : c) * s,
                            u = 3 * c;
                        I.transformVector3ArrayToVector3ArrayCoordinate(o, d + e, l, this._dynamicWorldPositions, u), -1 !== t && I.transformVector3ArrayByQuat(o, d + t, _, this._dynamicWorldNormals, u);
                    }
                    this._dynamicWorldPositionNormalNeedUpdate = !1;
                }
            }
        }, {
            key: "setTransform",
            value: function setTransform(e) {
                this._transform !== e && (this._transform && this._transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged),
                    e && e.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged), this._dynamicWorldPositionNormalNeedUpdate = !0,
                    this._transform = e);
            }
        }, {
            key: "setGeometry",
            value: function setGeometry(e) {
                if (this._geometry !== e) {
                    var t = e,
                        r = t._mesh;
                    if (r) {
                        var i = r._subMeshes.length > 1,
                            a = i ? t._indexCount : r._vertexCount;
                        if (a <= _.SubMeshDynamicBatch.maxAllowVertexCount) {
                            var n = 3 * a;
                            this._dynamicVertexBatch = !0, this._dynamicWorldPositions = new Float32Array(n),
                                this._dynamicWorldNormals = new Float32Array(n), this._dynamicVertexCount = a, this._dynamicMultiSubMesh = i;
                        } else this._dynamicVertexBatch = !1;
                    }
                    this._geometry = e;
                }
            }
        }, {
            key: "addToOpaqueRenderQueue",
            value: function addToOpaqueRenderQueue(e, r) {
                var i = this.staticBatch,
                    a = r.elements,
                    n = a.elements;
                if (i) {
                    var s = _.MeshRenderStaticBatchManager.instance,
                        o = s.getBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, i._batchID);
                    if (s._updateCountMark === o.updateMark) {
                        var l = o.indexInList;
                        if (o.batched) n[l].staticBatchElementList.add(this);
                        else {
                            var h = n[l],
                                c = h.render,
                                d = s._getBatchRenderElementFromPool();
                            d.renderType = st.RENDERTYPE_STATICBATCH, d.setGeometry(i), d.material = h.material;
                            var u = i.batchOwner,
                                m = u ? u._transform : null;
                            d.setTransform(m), d.render = c, d.renderSubShader = h.renderSubShader;
                            var f = d.staticBatchElementList;
                            f.length = 0, f.add(h), f.add(this), n[l] = d, o.batched = !0;
                        }
                    } else o.updateMark = s._updateCountMark, o.indexInList = a.length, o.batched = !1,
                        a.add(this);
                } else if (this.renderSubShader._owner._enableInstancing && t.LayaGL.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0) {
                    var E = this._geometry,
                        T = _.MeshRenderDynamicBatchManager.instance,
                        p = T.getInstanceBatchOpaquaMark(this.render.receiveShadow, this.material.id, E._id, this._transform._isFrontFaceInvert);
                    if (T._updateCountMark === p.updateMark) {
                        var g = p.indexInList;
                        if (p.batched) {
                            var S = n[g].instanceBatchElementList;
                            S.length === Ve.instance.maxInstanceCount ? (p.updateMark = T._updateCountMark,
                                p.indexInList = a.length, p.batched = !1, a.add(this)) : S.add(this);
                        } else {
                            var R = n[g],
                                v = R.render,
                                x = T._getBatchRenderElementFromPool();
                            x.renderType = st.RENDERTYPE_INSTANCEBATCH, x.setGeometry(Ve.instance), x.material = R.material,
                                x.setTransform(null), x.render = v, x.instanceSubMesh = E, x.renderSubShader = R.renderSubShader;
                            var I = x.instanceBatchElementList;
                            I.length = 0, I.add(R), I.add(this), n[g] = x, p.batched = !0;
                        }
                    } else p.updateMark = T._updateCountMark, p.indexInList = a.length, p.batched = !1,
                        a.add(this);
                } else if (this._dynamicVertexBatch) {
                    var A = this._geometry._vertexBuffer.vertexDeclaration,
                        M = _.MeshRenderDynamicBatchManager.instance,
                        D = M.getVertexBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, A.id);
                    if (M._updateCountMark === D.updateMark) {
                        var L = D.indexInList;
                        if (D.batched) n[L].vertexBatchElementList.add(this);
                        else {
                            var y = n[L],
                                C = y.render,
                                O = M._getBatchRenderElementFromPool();
                            O.renderType = st.RENDERTYPE_VERTEXBATCH, O.setGeometry(_.SubMeshDynamicBatch.instance),
                                O.material = y.material, O.setTransform(null), O.render = C, O.vertexBatchVertexDeclaration = A,
                                O.renderSubShader = y.renderSubShader;
                            var N = O.vertexBatchElementList;
                            N.length = 0, N.add(y), N.add(this), n[L] = O, D.batched = !0;
                        }
                    } else D.updateMark = M._updateCountMark, D.indexInList = a.length, D.batched = !1,
                        a.add(this);
                } else a.add(this);
            }
        }, {
            key: "addToTransparentRenderQueue",
            value: function addToTransparentRenderQueue(e, r) {
                var i = this.staticBatch,
                    a = r.elements,
                    n = a.elements;
                if (i) {
                    var s = _.MeshRenderStaticBatchManager.instance,
                        o = r.lastTransparentRenderElement;
                    if (o) {
                        var l = o.render;
                        if (o._geometry._getType() !== this._geometry._getType() || o.staticBatch !== i || o.material !== this.material || l.receiveShadow !== this.render.receiveShadow || l.lightmapIndex !== this.render.lightmapIndex) a.add(this),
                            r.lastTransparentBatched = !1;
                        else {
                            if (r.lastTransparentBatched) n[a.length - 1].staticBatchElementList.add(this);
                            else {
                                var h = s._getBatchRenderElementFromPool();
                                h.renderType = st.RENDERTYPE_STATICBATCH, h.setGeometry(i), h.material = o.material;
                                var c = i.batchOwner,
                                    d = c ? c._transform : null;
                                h.setTransform(d), h.render = this.render, h.renderSubShader = o.renderSubShader;
                                var u = h.staticBatchElementList;
                                u.length = 0, u.add(o), u.add(this), n[a.length - 1] = h;
                            }
                            r.lastTransparentBatched = !0;
                        }
                    } else a.add(this), r.lastTransparentBatched = !1;
                } else if (this.renderSubShader._owner._enableInstancing && t.LayaGL.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0) {
                    var m = this._geometry,
                        f = _.MeshRenderDynamicBatchManager.instance,
                        E = r.lastTransparentRenderElement;
                    if (E) {
                        var T = E.render;
                        if (E._geometry._getType() !== this._geometry._getType() || E._geometry !== m || E.material !== this.material || T.receiveShadow !== this.render.receiveShadow) a.add(this),
                            r.lastTransparentBatched = !1;
                        else if (r.lastTransparentBatched) {
                            var p = n[a.length - 1].instanceBatchElementList;
                            p.length === Ve.instance.maxInstanceCount ? (a.add(this), r.lastTransparentBatched = !1) : (p.add(this),
                                r.lastTransparentBatched = !0);
                        } else {
                            var g = f._getBatchRenderElementFromPool();
                            g.renderType = st.RENDERTYPE_INSTANCEBATCH, g.setGeometry(Ve.instance), g.material = E.material,
                                g.setTransform(null), g.render = this.render, g.instanceSubMesh = m, g.renderSubShader = E.renderSubShader;
                            var S = g.instanceBatchElementList;
                            S.length = 0, S.add(E), S.add(this), n[a.length - 1] = g, r.lastTransparentBatched = !0;
                        }
                    } else a.add(this), r.lastTransparentBatched = !1;
                } else if (this._dynamicVertexBatch) {
                    var R = this._geometry._vertexBuffer.vertexDeclaration,
                        v = _.MeshRenderDynamicBatchManager.instance,
                        x = r.lastTransparentRenderElement;
                    if (x) {
                        var I = x.render;
                        if (x._geometry._getType() !== this._geometry._getType() || x._geometry._vertexBuffer._vertexDeclaration !== R || x.material !== this.material || I.receiveShadow !== this.render.receiveShadow || I.lightmapIndex !== this.render.lightmapIndex) a.add(this),
                            r.lastTransparentBatched = !1;
                        else {
                            if (r.lastTransparentBatched) n[a.length - 1].vertexBatchElementList.add(this);
                            else {
                                var A = v._getBatchRenderElementFromPool();
                                A.renderType = st.RENDERTYPE_VERTEXBATCH, A.setGeometry(_.SubMeshDynamicBatch.instance),
                                    A.material = x.material, A.setTransform(null), A.render = this.render, A.vertexBatchVertexDeclaration = R,
                                    A.renderSubShader = x.renderSubShader;
                                var M = A.vertexBatchElementList;
                                M.length = 0, M.add(x), M.add(this), n[a.length - 1] = A;
                            }
                            r.lastTransparentBatched = !0;
                        }
                    } else a.add(this), r.lastTransparentBatched = !1;
                } else a.add(this);
                r.lastTransparentRenderElement = this;
            }
        }, {
            key: "getInvertFront",
            value: function getInvertFront() {
                switch (this.renderType) {
                    case st.RENDERTYPE_NORMAL:
                        return this._transform._isFrontFaceInvert;

                    case st.RENDERTYPE_STATICBATCH:
                    case st.RENDERTYPE_VERTEXBATCH:
                        return !1;

                    case st.RENDERTYPE_INSTANCEBATCH:
                        return this.instanceBatchElementList.elements[0]._transform._isFrontFaceInvert;

                    default:
                        throw "SubMeshRenderElement: unknown renderType";
                }
            }
        }, {
            key: "destroy",
            value: function destroy() {
                _get(_getPrototypeOf(ot.prototype), "destroy", this).call(this), this._dynamicWorldPositions = null,
                    this._dynamicWorldNormals = null, this.staticBatch = null, this.staticBatchElementList = null,
                    this.vertexBatchElementList = null, this.vertexBatchVertexDeclaration = null;
            }
        }]);
        return ot;
    }(st);
    var lt = /* */ function(_Pe2) {
        _inherits(lt, _Pe2);

        function lt(e, t) {
            var _this35;
            _classCallCheck(this, lt);
            _this35 = _possibleConstructorReturn(this, _getPrototypeOf(lt).call(this)), _this35._bufferState = new Xe(),
                _this35._batchID = lt._batchIDCounter++, _this35._batchElements = [], _this35._currentBatchVertexCount = 0,
                _this35._currentBatchIndexCount = 0, _this35._vertexDeclaration = t, _this35.batchOwner = e;
            return _this35;
        }
        _createClass(lt, [{
            key: "_getStaticBatchBakedVertexs",
            value: function _getStaticBatchBakedVertexs(e, t, r, i, a, n) {
                var s, o = n._vertexBuffer,
                    l = o.vertexDeclaration,
                    _ = l.getVertexElementByUsage(ce.MESH_POSITION0)._offset / 4,
                    h = l.getVertexElementByUsage(ce.MESH_NORMAL0),
                    c = h ? h._offset / 4 : -1,
                    d = l.getVertexElementByUsage(ce.MESH_COLOR0),
                    u = d ? d._offset / 4 : -1,
                    m = l.getVertexElementByUsage(ce.MESH_TEXTURECOORDINATE0),
                    f = m ? m._offset / 4 : -1,
                    E = l.getVertexElementByUsage(ce.MESH_TEXTURECOORDINATE1),
                    T = E ? E._offset / 4 : -1,
                    p = l.getVertexElementByUsage(ce.MESH_TANGENT0),
                    g = p ? p._offset / 4 : -1,
                    S = l.vertexStride / 4,
                    R = o.getFloat32Data();
                r ? (r.worldMatrix.invert(lt._tempMatrix4x40), s = lt._tempMatrix4x41, C.multiply(lt._tempMatrix4x40, i.worldMatrix, s)) : s = i.worldMatrix;
                var v = lt._tempMatrix4x42;
                s.invert(v), v.transpose();
                var x = lt._tempQuaternion0;
                s.decomposeTransRotScale(lt._tempVector30, x, lt._tempVector31);
                for (var A = a.lightmapScaleOffset, M = n.vertexCount, D = 0; D < M; D++) {
                    var L, y, O = D * S,
                        N = 18 * (D + t);
                    I.transformVector3ArrayToVector3ArrayCoordinate(R, O + _, s, e, N + 0), -1 !== c && I.transformVector3ArrayToVector3ArrayNormal(R, O + c, v, e, N + 3);
                    var P = N + 6;
                    if (-1 !== u) {
                        var b = O + u;
                        for (L = 0, y = 4; L < y; L++) {
                            e[P + L] = R[b + L];
                        }
                    } else
                        for (L = 0, y = 4; L < y; L++) {
                            e[P + L] = 1;
                        }
                    if (-1 !== f) {
                        var V = O + f;
                        e[N + 10] = R[V], e[N + 11] = R[V + 1];
                    }
                    if (A && (-1 !== T ? I.transformLightingMapTexcoordArray(R, O + T, A, e, N + 12) : I.transformLightingMapTexcoordArray(R, O + f, A, e, N + 12)), -1 !== g) {
                        var w = O + g;
                        e[N + 14] = R[w], e[N + 15] = R[w + 1], e[N + 16] = R[w + 2], e[N + 17] = R[w + 3];
                    }
                }
                return M;
            }
        }, {
            key: "addTest",
            value: function addTest(e) {
                var t = e.meshFilter.sharedMesh.vertexCount;
                return !(this._currentBatchVertexCount + t > lt.maxBatchVertexCount);
            }
        }, {
            key: "add",
            value: function add(e) {
                var t = e.meshFilter.sharedMesh,
                    r = t.vertexCount;
                this._batchElements.push(e);
                var i = e._render;
                i._isPartOfStaticBatch = !0, i._staticBatch = this;
                for (var a = i._renderElements, n = 0, s = a.length; n < s; n++) {
                    a[n].staticBatch = this;
                }
                this._currentBatchIndexCount += t._indexBuffer.indexCount, this._currentBatchVertexCount += r;
            }
        }, {
            key: "remove",
            value: function remove(e) {
                var t = e.meshFilter.sharedMesh,
                    r = this._batchElements.indexOf(e);
                if (-1 !== r) {
                    this._batchElements.splice(r, 1);
                    for (var i = e._render._renderElements, a = 0, n = i.length; a < n; a++) {
                        i[a].staticBatch = null;
                    }
                    this._currentBatchIndexCount = this._currentBatchIndexCount - t._indexBuffer.indexCount,
                        this._currentBatchVertexCount = this._currentBatchVertexCount - t.vertexCount, e._render._isPartOfStaticBatch = !1;
                }
            }
        }, {
            key: "finishInit",
            value: function finishInit() {
                this._vertexBuffer && (this._vertexBuffer.destroy(), this._indexBuffer.destroy(),
                    t.Resource._addGPUMemory(-(this._vertexBuffer._byteLength + this._indexBuffer._byteLength)));
                var r = t.LayaGL.instance,
                    i = 0,
                    a = 0,
                    n = this.batchOwner,
                    s = this._vertexDeclaration.vertexStride / 4,
                    o = new Float32Array(s * this._currentBatchVertexCount),
                    l = new Uint16Array(this._currentBatchIndexCount);
                this._vertexBuffer = new be(this._vertexDeclaration.vertexStride * this._currentBatchVertexCount, r.STATIC_DRAW),
                    this._vertexBuffer.vertexDeclaration = this._vertexDeclaration, this._indexBuffer = new Ye(e.IndexFormat.UInt16, this._currentBatchIndexCount, r.STATIC_DRAW);
                for (var _ = 0, h = this._batchElements.length; _ < h; _++) {
                    for (var c, d = this._batchElements[_], u = d.meshFilter.sharedMesh, m = this._getStaticBatchBakedVertexs(o, i, n ? n._transform : null, d._transform, d._render, u), f = u._indexBuffer.getData(), E = i, T = a + f.length, p = d._render._renderElements, g = 0, S = u.subMeshCount; g < S; g++) {
                        var R = u._subMeshes[g],
                            v = a + R._indexStart,
                            x = p[g];
                        x.staticBatchIndexStart = v, x.staticBatchIndexEnd = v + R._indexCount;
                    }
                    if (l.set(f, a), n ? d._transform._isFrontFaceInvert !== n.transform._isFrontFaceInvert : d._transform._isFrontFaceInvert)
                        for (c = a; c < T; c += 3) {
                            l[c] = E + l[c];
                            var I = l[c + 1],
                                A = l[c + 2];
                            l[c + 1] = E + A, l[c + 2] = E + I;
                        } else
                            for (c = a; c < T; c += 3) {
                                l[c] = E + l[c], l[c + 1] = E + l[c + 1], l[c + 2] = E + l[c + 2];
                            }
                    a += f.length, i += m;
                }
                this._vertexBuffer.setData(o.buffer), this._indexBuffer.setData(l);
                var M = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
                t.Resource._addGPUMemory(M), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer),
                    this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind();
            }
        }, {
            key: "_render",
            value: function _render(e) {
                this._bufferState.bind();
                for (var r = t.LayaGL.instance, i = e.renderElement.staticBatchElementList, a = i.elements, n = 0, s = 0, o = i.length, l = 1; l < o; l++) {
                    if (a[l - 1].staticBatchIndexEnd !== a[l].staticBatchIndexStart) {
                        var _ = a[n].staticBatchIndexStart,
                            h = a[s].staticBatchIndexEnd - _;
                        r.drawElements(r.TRIANGLES, h, r.UNSIGNED_SHORT, 2 * _), n = ++s, t.Stat.trianglesFaces += h / 3;
                    } else s++;
                }
                _ = a[n].staticBatchIndexStart, h = a[s].staticBatchIndexEnd - _, r.drawElements(r.TRIANGLES, h, r.UNSIGNED_SHORT, 2 * _),
                    t.Stat.renderBatches++, t.Stat.savedRenderBatches += o - 1, t.Stat.trianglesFaces += h / 3;
            }
        }, {
            key: "dispose",
            value: function dispose() {
                var e = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
                t.Resource._addGPUMemory(-e), this._batchElements = null, this.batchOwner = null,
                    this._vertexDeclaration = null, this._bufferState.destroy(), this._vertexBuffer.destroy(),
                    this._indexBuffer.destroy(), this._vertexBuffer = null, this._indexBuffer = null,
                    this._bufferState = null;
            }
        }]);
        return lt;
    }(Pe);
    lt._tempVector30 = new n(), lt._tempVector31 = new n(), lt._tempQuaternion0 = new f(),
        lt._tempMatrix4x40 = new C(), lt._tempMatrix4x41 = new C(), lt._tempMatrix4x42 = new C(),
        lt.maxBatchVertexCount = 65535, lt._batchIDCounter = 0;
    var _t = /* */ function() {
        function _t() {
            _classCallCheck(this, _t);
            this.elements = [], this.length = 0;
        }
        _createClass(_t, [{
            key: "_add",
            value: function _add(e) {
                this.length === this.elements.length ? this.elements.push(e) : this.elements[this.length] = e;
            }
        }, {
            key: "add",
            value: function add(e) {
                this.length === this.elements.length ? this.elements.push(e) : this.elements[this.length] = e,
                    this.length++;
            }
        }]);
        return _t;
    }();
    var ht = /* */ function(_Ce) {
        _inherits(ht, _Ce);

        function ht() {
            var _this36;
            _classCallCheck(this, ht);
            _this36 = _possibleConstructorReturn(this, _getPrototypeOf(ht).call(this)), _this36._opaqueBatchMarks = [],
                _this36._updateCountMark = 0;
            return _this36;
        }
        _createClass(ht, [{
            key: "_compare",
            value: function _compare(e, t) {
                var r = e._render,
                    i = t._render,
                    a = e.meshFilter.sharedMesh,
                    n = t.meshFilter.sharedMesh,
                    s = r.lightmapIndex - i.lightmapIndex;
                if (0 === s) {
                    var o = (r.receiveShadow ? 1 : 0) - (i.receiveShadow ? 1 : 0);
                    if (0 === o) {
                        var l = r.sharedMaterial && i.sharedMaterial ? r.sharedMaterial.id - i.sharedMaterial.id : 0;
                        if (0 === l) {
                            var _ = a._vertexBuffer.vertexDeclaration.id - n._vertexBuffer.vertexDeclaration.id;
                            return 0 === _ ? n._indexBuffer.indexCount - a._indexBuffer.indexCount : _;
                        }
                        return l;
                    }
                    return o;
                }
                return s;
            }
        }, {
            key: "_getBatchRenderElementFromPool",
            value: function _getBatchRenderElementFromPool() {
                var e = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
                return e || (e = new ot(), this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = e,
                    e.staticBatchElementList = new _t()), e;
            }
        }, {
            key: "_getStaticBatch",
            value: function _getStaticBatch(e, t, r) {
                var i = e[r];
                return i || (i = e[r] = new lt(t, ht._verDec), this._staticBatches[i._batchID] = i),
                    i;
            }
        }, {
            key: "_initStaticBatchs",
            value: function _initStaticBatchs(e) {
                var t = this._initBatchSprites;
                this._quickSort(t, 0, t.length - 1);
                for (var r, i = [], a = !1, n = 0, s = 0, o = t.length; s < o; s++) {
                    var l = t[s];
                    if (a) r.addTest(l) ? r.add(l) : (a = !1, n++);
                    else s !== o - 1 && ((r = this._getStaticBatch(i, e, n)).add(l),
                        a = !0);
                }
                for (s = 0, o = i.length; s < o; s++) {
                    var _ = i[s];
                    _ && _.finishInit();
                }
                this._initBatchSprites.length = 0;
            }
        }, {
            key: "_removeRenderSprite",
            value: function _removeRenderSprite(e) {
                var t = e._render,
                    r = t._staticBatch,
                    i = r._batchElements,
                    a = i.indexOf(e);
                if (-1 !== a) {
                    i.splice(a, 1), t._staticBatch = null;
                    for (var n = t._renderElements, s = 0, o = n.length; s < o; s++) {
                        n[s].staticBatch = null;
                    }
                }
                0 === i.length && (delete this._staticBatches[r._batchID], r.dispose());
            }
        }, {
            key: "_clear",
            value: function _clear() {
                _get(_getPrototypeOf(ht.prototype), "_clear", this).call(this), this._updateCountMark++;
            }
        }, {
            key: "_garbageCollection",
            value: function _garbageCollection() {
                for (var e in this._staticBatches) {
                    var t = this._staticBatches[e];
                    0 === t._batchElements.length && (t.dispose(), delete this._staticBatches[e]);
                }
            }
        }, {
            key: "getBatchOpaquaMark",
            value: function getBatchOpaquaMark(e, t, r, i) {
                var a = t ? 1 : 0,
                    n = this._opaqueBatchMarks[e] || (this._opaqueBatchMarks[e] = []),
                    s = n[a] || (n[a] = []),
                    o = s[r] || (s[r] = []);
                return o[i] || (o[i] = new Ne());
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                ht._verDec = ce.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT");
            }
        }]);
        return ht;
    }(Ce);
    ht.instance = new ht();
    var ct = function ct() {
        _classCallCheck(this, ct);
    };
    var dt = /* */ function() {
        function dt(e, t) {
            _classCallCheck(this, dt);
            this.min = e, this.max = t;
        }
        _createClass(dt, [{
            key: "_rotateExtents",
            value: function _rotateExtents(e, t, r) {
                var i = e.x,
                    a = e.y,
                    n = e.z,
                    s = t.elements;
                r.x = Math.abs(s[0] * i) + Math.abs(s[4] * a) + Math.abs(s[8] * n), r.y = Math.abs(s[1] * i) + Math.abs(s[5] * a) + Math.abs(s[9] * n),
                    r.z = Math.abs(s[2] * i) + Math.abs(s[6] * a) + Math.abs(s[10] * n);
            }
        }, {
            key: "getCorners",
            value: function getCorners(e) {
                e.length = 8;
                var t = this.min.x,
                    r = this.min.y,
                    i = this.min.z,
                    a = this.max.x,
                    s = this.max.y,
                    o = this.max.z;
                e[0] = new n(t, s, o), e[1] = new n(a, s, o), e[2] = new n(a, r, o), e[3] = new n(t, r, o),
                    e[4] = new n(t, s, i), e[5] = new n(a, s, i), e[6] = new n(a, r, i), e[7] = new n(t, r, i);
            }
        }, {
            key: "getCenter",
            value: function getCenter(e) {
                n.add(this.min, this.max, e), n.scale(e, .5, e);
            }
        }, {
            key: "getExtent",
            value: function getExtent(e) {
                n.subtract(this.max, this.min, e), n.scale(e, .5, e);
            }
        }, {
            key: "setCenterAndExtent",
            value: function setCenterAndExtent(e, t) {
                n.subtract(e, t, this.min), n.add(e, t, this.max);
            }
        }, {
            key: "tranform",
            value: function tranform(e, t) {
                var r = dt._tempVector30,
                    i = dt._tempVector31;
                this.getCenter(r), this.getExtent(i), n.transformCoordinate(r, e, r), this._rotateExtents(i, e, i),
                    t.setCenterAndExtent(r, i);
            }
        }, {
            key: "toDefault",
            value: function toDefault() {
                this.min.toDefault(), this.max.toDefault();
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                this.min.cloneTo(t.min), this.max.cloneTo(t.max);
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new dt(new n(), new n());
                return this.cloneTo(e), e;
            }
        }], [{
            key: "createfromPoints",
            value: function createfromPoints(e, t) {
                if (null == e) throw new Error("points");
                var r = t.min,
                    i = t.max;
                r.x = Number.MAX_VALUE, r.y = Number.MAX_VALUE, r.z = Number.MAX_VALUE, i.x = -Number.MAX_VALUE,
                    i.y = -Number.MAX_VALUE, i.z = -Number.MAX_VALUE;
                for (var a = 0, s = e.length; a < s; ++a) {
                    n.min(r, e[a], r), n.max(i, e[a], i);
                }
            }
        }, {
            key: "merge",
            value: function merge(e, t, r) {
                n.min(e.min, t.min, r.min), n.max(e.max, t.max, r.max);
            }
        }]);
        return dt;
    }();
    dt._tempVector30 = new n(), dt._tempVector31 = new n();
    var ut = /* */ function() {
        function ut(e, t) {
            _classCallCheck(this, ut);
            this._updateFlag = 0, this._center = new n(), this._extent = new n(), this._boundBox = new dt(new n(), new n()),
                e.cloneTo(this._boundBox.min), t.cloneTo(this._boundBox.max), this._setUpdateFlag(ut._UPDATE_CENTER | ut._UPDATE_EXTENT, !0);
        }
        _createClass(ut, [{
            key: "setMin",
            value: function setMin(e) {
                var t = this._boundBox.min;
                e !== t && e.cloneTo(t), this._setUpdateFlag(ut._UPDATE_CENTER | ut._UPDATE_EXTENT, !0),
                    this._setUpdateFlag(ut._UPDATE_MIN, !1);
            }
        }, {
            key: "getMin",
            value: function getMin() {
                var e = this._boundBox.min;
                return this._getUpdateFlag(ut._UPDATE_MIN) && (this._getMin(this.getCenter(), this.getExtent(), e),
                    this._setUpdateFlag(ut._UPDATE_MIN, !1)), e;
            }
        }, {
            key: "setMax",
            value: function setMax(e) {
                var t = this._boundBox.max;
                e !== t && e.cloneTo(t), this._setUpdateFlag(ut._UPDATE_CENTER | ut._UPDATE_EXTENT, !0),
                    this._setUpdateFlag(ut._UPDATE_MAX, !1);
            }
        }, {
            key: "getMax",
            value: function getMax() {
                var e = this._boundBox.max;
                return this._getUpdateFlag(ut._UPDATE_MAX) && (this._getMax(this.getCenter(), this.getExtent(), e),
                    this._setUpdateFlag(ut._UPDATE_MAX, !1)), e;
            }
        }, {
            key: "setCenter",
            value: function setCenter(e) {
                e !== this._center && e.cloneTo(this._center), this._setUpdateFlag(ut._UPDATE_MIN | ut._UPDATE_MAX, !0),
                    this._setUpdateFlag(ut._UPDATE_CENTER, !1);
            }
        }, {
            key: "getCenter",
            value: function getCenter() {
                return this._getUpdateFlag(ut._UPDATE_CENTER) && (this._getCenter(this.getMin(), this.getMax(), this._center),
                    this._setUpdateFlag(ut._UPDATE_CENTER, !1)), this._center;
            }
        }, {
            key: "setExtent",
            value: function setExtent(e) {
                e !== this._extent && e.cloneTo(this._extent), this._setUpdateFlag(ut._UPDATE_MIN | ut._UPDATE_MAX, !0),
                    this._setUpdateFlag(ut._UPDATE_EXTENT, !1);
            }
        }, {
            key: "getExtent",
            value: function getExtent() {
                return this._getUpdateFlag(ut._UPDATE_EXTENT) && (this._getExtent(this.getMin(), this.getMax(), this._extent),
                    this._setUpdateFlag(ut._UPDATE_EXTENT, !1)), this._extent;
            }
        }, {
            key: "_getUpdateFlag",
            value: function _getUpdateFlag(e) {
                return 0 != (this._updateFlag & e);
            }
        }, {
            key: "_setUpdateFlag",
            value: function _setUpdateFlag(e, t) {
                t ? this._updateFlag |= e : this._updateFlag &= ~e;
            }
        }, {
            key: "_getCenter",
            value: function _getCenter(e, t, r) {
                n.add(e, t, r), n.scale(r, .5, r);
            }
        }, {
            key: "_getExtent",
            value: function _getExtent(e, t, r) {
                n.subtract(t, e, r), n.scale(r, .5, r);
            }
        }, {
            key: "_getMin",
            value: function _getMin(e, t, r) {
                n.subtract(e, t, r);
            }
        }, {
            key: "_getMax",
            value: function _getMax(e, t, r) {
                n.add(e, t, r);
            }
        }, {
            key: "_rotateExtents",
            value: function _rotateExtents(e, t, r) {
                var i = e.x,
                    a = e.y,
                    n = e.z,
                    s = t.elements;
                r.x = Math.abs(s[0] * i) + Math.abs(s[4] * a) + Math.abs(s[8] * n), r.y = Math.abs(s[1] * i) + Math.abs(s[5] * a) + Math.abs(s[9] * n),
                    r.z = Math.abs(s[2] * i) + Math.abs(s[6] * a) + Math.abs(s[10] * n);
            }
        }, {
            key: "_tranform",
            value: function _tranform(e, t) {
                var r = t._center,
                    i = t._extent;
                n.transformCoordinate(this.getCenter(), e, r), this._rotateExtents(this.getExtent(), e, i),
                    t._boundBox.setCenterAndExtent(r, i), t._updateFlag = 0;
            }
        }, {
            key: "_getBoundBox",
            value: function _getBoundBox() {
                if (this._updateFlag & ut._UPDATE_MIN) {
                    var e = this._boundBox.min;
                    this._getMin(this.getCenter(), this.getExtent(), e), this._setUpdateFlag(ut._UPDATE_MIN, !1);
                }
                if (this._updateFlag & ut._UPDATE_MAX) {
                    var t = this._boundBox.max;
                    this._getMax(this.getCenter(), this.getExtent(), t), this._setUpdateFlag(ut._UPDATE_MAX, !1);
                }
                return this._boundBox;
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                this.getMin().cloneTo(t._boundBox.min), this.getMax().cloneTo(t._boundBox.max),
                    this.getCenter().cloneTo(t._center), this.getExtent().cloneTo(t._extent), t._updateFlag = 0;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new ut(new n(), new n());
                return this.cloneTo(e), e;
            }
        }]);
        return ut;
    }();
    ut._UPDATE_MIN = 1, ut._UPDATE_MAX = 2, ut._UPDATE_CENTER = 4, ut._UPDATE_EXTENT = 8;
    var mt = /* */ function(_t$EventDispatcher3) {
        _inherits(mt, _t$EventDispatcher3);

        function mt(e) {
            var _this37;
            _classCallCheck(this, mt);
            if (_this37 = _possibleConstructorReturn(this, _getPrototypeOf(mt).call(this)),
                _this37._lightmapScaleOffset = new a(1, 1, 0, 0), _this37._indexInList = -1, _this37._indexInCastShadowList = -1,
                _this37._boundsChange = !0, _this37._castShadow = !1, _this37._supportOctree = !0,
                _this37._sharedMaterials = [], _this37._renderMark = -1, _this37._indexInOctreeMotionList = -1,
                _this37._updateMark = -1, _this37._updateRenderType = -1, _this37._isPartOfStaticBatch = !1,
                _this37._staticBatch = null, _this37._id = ++mt._uniqueIDCounter, _this37._indexInCastShadowList = -1,
                _this37._bounds = new ut(n._ZERO, n._ZERO), t.Render.supportWebGLPlusCulling) {
                var r = Oe._cullingBufferLength;
                _this37._cullingBufferIndex = r;
                var i = Oe._cullingBuffer,
                    s = r + 7;
                if (s >= i.length) {
                    var o = i;
                    (i = Oe._cullingBuffer = new Float32Array(i.length + 4096)).set(o, 0);
                }
                i[r] = 2, Oe._cullingBufferLength = s;
            }
            _this37._renderElements = [], _this37._owner = e, _this37._enable = !0, _this37._materialsInstance = [],
                _this37._shaderValues = new k(null), _this37.lightmapIndex = -1, _this37.receiveShadow = !1,
                _this37.sortingFudge = 0, e && _this37._owner.transform.on(t.Event.TRANSFORM_CHANGED, _assertThisInitialized(_this37), _this37._onWorldMatNeedChange);
            return _possibleConstructorReturn(_this37);
        }
        _createClass(mt, [{
            key: "_getOctreeNode",
            value: function _getOctreeNode() {
                return this._octreeNode;
            }
        }, {
            key: "_setOctreeNode",
            value: function _setOctreeNode(e) {
                this._octreeNode = e;
            }
        }, {
            key: "_getIndexInMotionList",
            value: function _getIndexInMotionList() {
                return this._indexInOctreeMotionList;
            }
        }, {
            key: "_setIndexInMotionList",
            value: function _setIndexInMotionList(e) {
                this._indexInOctreeMotionList = e;
            }
        }, {
            key: "_changeMaterialReference",
            value: function _changeMaterialReference(e, t) {
                e && e._removeReference(), t._addReference();
            }
        }, {
            key: "_getInstanceMaterial",
            value: function _getInstanceMaterial(e, t) {
                var r = e.clone();
                return r.name = r.name + "(Instance)", this._materialsInstance[t] = !0, this._changeMaterialReference(this._sharedMaterials[t], r),
                    this._sharedMaterials[t] = r, r;
            }
        }, {
            key: "_applyLightMapParams",
            value: function _applyLightMapParams() {
                if (this._scene && this._lightmapIndex >= 0) {
                    var e = this._scene.getlightmaps();
                    this._lightmapIndex < e.length ? (this._shaderValues.addDefine(ye.SAHDERDEFINE_LIGHTMAP),
                        this._shaderValues.setTexture(ye.LIGHTMAP, e[this._lightmapIndex])) : this._shaderValues.removeDefine(ye.SAHDERDEFINE_LIGHTMAP);
                } else this._shaderValues.removeDefine(ye.SAHDERDEFINE_LIGHTMAP);
            }
        }, {
            key: "_onWorldMatNeedChange",
            value: function _onWorldMatNeedChange(e) {
                this._boundsChange = !0, this._octreeNode && (e &= De.TRANSFORM_WORLDPOSITION | De.TRANSFORM_WORLDQUATERNION | De.TRANSFORM_WORLDSCALE) && -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this);
            }
        }, {
            key: "_calculateBoundingBox",
            value: function _calculateBoundingBox() {
                throw "BaseRender: must override it.";
            }
        }, {
            key: "_getIndexInList",
            value: function _getIndexInList() {
                return this._indexInList;
            }
        }, {
            key: "_setIndexInList",
            value: function _setIndexInList(e) {
                this._indexInList = e;
            }
        }, {
            key: "_setBelongScene",
            value: function _setBelongScene(e) {
                this._scene !== e && (this._scene = e, this._applyLightMapParams());
            }
        }, {
            key: "_needRender",
            value: function _needRender(e, t) {
                return !0;
            }
        }, {
            key: "_renderUpdate",
            value: function _renderUpdate(e, t) {}
        }, {
            key: "_renderUpdateWithCamera",
            value: function _renderUpdateWithCamera(e, t) {}
        }, {
            key: "_revertBatchRenderUpdate",
            value: function _revertBatchRenderUpdate(e) {}
        }, {
            key: "_destroy",
            value: function _destroy() {
                -1 !== this._indexInOctreeMotionList && this._octreeNode._octree.removeMotionObject(this),
                    this.offAll();
                var e = 0,
                    t = 0;
                for (e = 0, t = this._renderElements.length; e < t; e++) {
                    this._renderElements[e].destroy();
                }
                for (e = 0, t = this._sharedMaterials.length; e < t; e++) {
                    this._sharedMaterials[e].destroyed || this._sharedMaterials[e]._removeReference();
                }
                this._renderElements = null, this._owner = null, this._sharedMaterials = null, this._bounds = null,
                    this._lightmapScaleOffset = null;
            }
        }, {
            key: "markAsUnStatic",
            value: function markAsUnStatic() {
                this._isPartOfStaticBatch && (ht.instance._removeRenderSprite(this._owner), this._isPartOfStaticBatch = !1);
            }
        }, {
            key: "id",
            get: function get() {
                return this._id;
            }
        }, {
            key: "lightmapIndex",
            get: function get() {
                return this._lightmapIndex;
            },
            set: function set(e) {
                this._lightmapIndex !== e && (this._lightmapIndex = e, this._applyLightMapParams());
            }
        }, {
            key: "lightmapScaleOffset",
            get: function get() {
                return this._lightmapScaleOffset;
            },
            set: function set(e) {
                if (!e) throw "BaseRender: lightmapScaleOffset can't be null.";
                this._lightmapScaleOffset = e, this._shaderValues.setVector(ye.LIGHTMAPSCALEOFFSET, e);
            }
        }, {
            key: "enable",
            get: function get() {
                return this._enable;
            },
            set: function set(e) {
                this._enable = !!e;
            }
        }, {
            key: "material",
            get: function get() {
                var e = this._sharedMaterials[0];
                if (e && !this._materialsInstance[0]) {
                    var t = this._getInstanceMaterial(e, 0),
                        r = this._renderElements[0];
                    r && (r.material = t);
                }
                return this._sharedMaterials[0];
            },
            set: function set(e) {
                this.sharedMaterial = e;
            }
        }, {
            key: "materials",
            get: function get() {
                for (var e = 0, t = this._sharedMaterials.length; e < t; e++) {
                    if (!this._materialsInstance[e]) {
                        var r = this._getInstanceMaterial(this._sharedMaterials[e], e),
                            i = this._renderElements[e];
                        i && (i.material = r);
                    }
                }
                return this._sharedMaterials.slice();
            },
            set: function set(e) {
                this.sharedMaterials = e;
            }
        }, {
            key: "sharedMaterial",
            get: function get() {
                return this._sharedMaterials[0];
            },
            set: function set(e) {
                var t = this._sharedMaterials[0];
                if (t !== e) {
                    this._sharedMaterials[0] = e, this._materialsInstance[0] = !1, this._changeMaterialReference(t, e);
                    var r = this._renderElements[0];
                    r && (r.material = e);
                }
            }
        }, {
            key: "sharedMaterials",
            get: function get() {
                return this._sharedMaterials.slice();
            },
            set: function set(e) {
                for (var t = this._materialsInstance, r = this._sharedMaterials, i = 0, a = r.length; i < a; i++) {
                    var n = r[i];
                    n && n._removeReference();
                }
                if (!e) throw new Error("BaseRender: shadredMaterials value can't be null.");
                var s = e.length;
                for (t.length = s, r.length = s, i = 0; i < s; i++) {
                    n = r[i];
                    var o = e[i];
                    if (n !== o) {
                        t[i] = !1;
                        var l = this._renderElements[i];
                        l && (l.material = o);
                    }
                    o && o._addReference(), r[i] = o;
                }
            }
        }, {
            key: "bounds",
            get: function get() {
                return this._boundsChange && (this._calculateBoundingBox(), this._boundsChange = !1),
                    this._bounds;
            }
        }, {
            key: "receiveShadow",
            set: function set(e) {
                this._receiveShadow !== e && (this._receiveShadow = e, e ? this._shaderValues.addDefine(ye.SHADERDEFINE_RECEIVE_SHADOW) : this._shaderValues.removeDefine(ye.SHADERDEFINE_RECEIVE_SHADOW));
            },
            get: function get() {
                return this._receiveShadow;
            }
        }, {
            key: "castShadow",
            get: function get() {
                return this._castShadow;
            },
            set: function set(e) {
                this._castShadow = e;
            }
        }, {
            key: "isPartOfStaticBatch",
            get: function get() {
                return this._isPartOfStaticBatch;
            }
        }, {
            key: "isRender",
            get: function get() {
                return -1 == this._renderMark || this._renderMark == t.Stat.loopCount - 1;
            }
        }]);
        return mt;
    }(t.EventDispatcher);
    mt._tempBoundBoxCorners = [new n(), new n(), new n(), new n(), new n(), new n(), new n(), new n()],
        mt._uniqueIDCounter = 0, mt._defaultLightmapScaleOffset = new a(1, 1, 0, 0);
    var ft = /* */ function(_mt) {
        _inherits(ft, _mt);

        function ft(e) {
            var _this38;
            _classCallCheck(this, ft);
            _this38 = _possibleConstructorReturn(this, _getPrototypeOf(ft).call(this, e)), _this38._revertStaticBatchDefineUV1 = !1,
                _this38._projectionViewWorldMatrix = new C();
            return _this38;
        }
        _createClass(ft, [{
            key: "_createRenderElement",
            value: function _createRenderElement() {
                return new ot();
            }
        }, {
            key: "_onMeshChange",
            value: function _onMeshChange(e) {
                if (e) {
                    var t = e.subMeshCount;
                    this._renderElements.length = t;
                    for (var r = 0; r < t; r++) {
                        var i = this._renderElements[r];
                        if (!i) {
                            var a = this.sharedMaterials[r];
                            (i = this._renderElements[r] = this._createRenderElement()).setTransform(this._owner._transform),
                                i.render = this, i.material = a || K.defaultMaterial;
                        }
                        i.setGeometry(e.getSubMesh(r));
                    }
                } else this._renderElements.length = 0;
                this._boundsChange = !0;
            }
        }, {
            key: "_calculateBoundingBox",
            value: function _calculateBoundingBox() {
                var e = this._owner.meshFilter.sharedMesh;
                if (e) {
                    var r = this._owner.transform.worldMatrix;
                    e.bounds._tranform(r, this._bounds);
                }
                if (t.Render.supportWebGLPlusCulling) {
                    var i = this._bounds.getMin(),
                        a = this._bounds.getMax(),
                        n = Oe._cullingBuffer;
                    n[this._cullingBufferIndex + 1] = i.x, n[this._cullingBufferIndex + 2] = i.y, n[this._cullingBufferIndex + 3] = i.z,
                        n[this._cullingBufferIndex + 4] = a.x, n[this._cullingBufferIndex + 5] = a.y, n[this._cullingBufferIndex + 6] = a.z;
                }
            }
        }, {
            key: "_needRender",
            value: function _needRender(e, t) {
                return !e || e.intersects(this.bounds._getBoundBox());
            }
        }, {
            key: "_renderUpdate",
            value: function _renderUpdate(e, t) {
                var r = e.renderElement;
                switch (r.renderType) {
                    case st.RENDERTYPE_NORMAL:
                        this._shaderValues.setMatrix4x4(Le.WORLDMATRIX, t.worldMatrix);
                        break;

                    case st.RENDERTYPE_STATICBATCH:
                        t ? this._shaderValues.setMatrix4x4(Le.WORLDMATRIX, t.worldMatrix) : this._shaderValues.setMatrix4x4(Le.WORLDMATRIX, C.DEFAULT),
                            this._shaderValues.hasDefine(ct.SHADERDEFINE_UV1) ? this._revertStaticBatchDefineUV1 = !1 : (this._shaderValues.addDefine(ct.SHADERDEFINE_UV1),
                                this._revertStaticBatchDefineUV1 = !0), this._shaderValues.setVector(ye.LIGHTMAPSCALEOFFSET, mt._defaultLightmapScaleOffset);
                        break;

                    case st.RENDERTYPE_VERTEXBATCH:
                        this._shaderValues.setMatrix4x4(Le.WORLDMATRIX, C.DEFAULT);
                        break;

                    case st.RENDERTYPE_INSTANCEBATCH:
                        for (var i = Ve.instance.instanceWorldMatrixData, a = r.instanceBatchElementList, n = a.elements, s = a.length, o = 0; o < s; o++) {
                            i.set(n[o]._transform.worldMatrix.elements, 16 * o);
                        }
                        Ve.instance.instanceWorldMatrixBuffer.setData(i.buffer, 0, 0, 16 * s * 4), this._shaderValues.addDefine(ct.SHADERDEFINE_GPU_INSTANCE);
                }
            }
        }, {
            key: "_renderUpdateWithCamera",
            value: function _renderUpdateWithCamera(e, t) {
                var r = e.projectionViewMatrix,
                    i = e.renderElement;
                switch (i.renderType) {
                    case st.RENDERTYPE_NORMAL:
                    case st.RENDERTYPE_STATICBATCH:
                    case st.RENDERTYPE_VERTEXBATCH:
                        t ? (C.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(Le.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(Le.MVPMATRIX, r);
                        break;

                    case st.RENDERTYPE_INSTANCEBATCH:
                        for (var a = Ve.instance.instanceMVPMatrixData, n = i.instanceBatchElementList, s = n.elements, o = n.length, l = 0; l < o; l++) {
                            var _ = s[l]._transform.worldMatrix;
                            I.mulMatrixByArray(r.elements, 0, _.elements, 0, a, 16 * l);
                        }
                        Ve.instance.instanceMVPMatrixBuffer.setData(a.buffer, 0, 0, 16 * o * 4);
                }
            }
        }, {
            key: "_revertBatchRenderUpdate",
            value: function _revertBatchRenderUpdate(e) {
                switch (e.renderElement.renderType) {
                    case st.RENDERTYPE_STATICBATCH:
                        this._revertStaticBatchDefineUV1 && this._shaderValues.removeDefine(ct.SHADERDEFINE_UV1),
                            this._shaderValues.setVector(ye.LIGHTMAPSCALEOFFSET, this.lightmapScaleOffset);
                        break;

                    case st.RENDERTYPE_INSTANCEBATCH:
                        this._shaderValues.removeDefine(ct.SHADERDEFINE_GPU_INSTANCE);
                }
            }
        }, {
            key: "_destroy",
            value: function _destroy() {
                this._isPartOfStaticBatch && ht.instance._removeRenderSprite(this._owner), _get(_getPrototypeOf(ft.prototype), "_destroy", this).call(this);
            }
        }]);
        return ft;
    }(mt);
    var Et = /* */ function() {
        function Et(e) {
            _classCallCheck(this, Et);
            this._owner = e;
        }
        _createClass(Et, [{
            key: "_getMeshDefine",
            value: function _getMeshDefine(e, t) {
                t.length = 0;
                for (var r = 0, i = e._subMeshes.length; r < i; r++) {
                    for (var a = e.getSubMesh(r)._vertexBuffer._vertexDeclaration._vertexElements, n = 0, s = a.length; n < s; n++) {
                        switch (a[n]._elementUsage) {
                            case ce.MESH_COLOR0:
                                t.push(ct.SHADERDEFINE_COLOR);
                                break;

                            case ce.MESH_TEXTURECOORDINATE0:
                                t.push(ct.SHADERDEFINE_UV0);
                                break;

                            case ce.MESH_TEXTURECOORDINATE1:
                                t.push(ct.SHADERDEFINE_UV1);
                        }
                    }
                }
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._owner = null, this._sharedMesh && (this._sharedMesh._removeReference(), this._sharedMesh = null);
            }
        }, {
            key: "sharedMesh",
            get: function get() {
                return this._sharedMesh;
            },
            set: function set(e) {
                if (this._sharedMesh !== e) {
                    var t = this._owner._render._shaderValues,
                        r = this._sharedMesh;
                    if (r) {
                        r._removeReference(), this._getMeshDefine(r, Et._meshVerticeDefine);
                        for (var i = 0, a = Et._meshVerticeDefine.length; i < a; i++) {
                            t.removeDefine(Et._meshVerticeDefine[i]);
                        }
                    }
                    if (e) {
                        e._addReference(), this._getMeshDefine(e, Et._meshVerticeDefine);
                        for (i = 0, a = Et._meshVerticeDefine.length; i < a; i++) {
                            t.addDefine(Et._meshVerticeDefine[i]);
                        }
                    }
                    this._owner._render._onMeshChange(e), this._sharedMesh = e;
                }
            }
        }]);
        return Et;
    }();
    Et._meshVerticeDefine = [];
    var Tt = /* */ function(_Pe3) {
        _inherits(Tt, _Pe3);

        function Tt() {
            var _this39;
            _classCallCheck(this, Tt);
            _this39 = _possibleConstructorReturn(this, _getPrototypeOf(Tt).call(this)), _this39._bufferState = new Xe();
            var r = t.LayaGL.instance,
                i = ce.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT").vertexStride * Tt.maxIndicesCount;
            _this39._vertices = new Float32Array(i / 4), _this39._vertexBuffer = new be(i, r.DYNAMIC_DRAW),
                _this39._indices = new Int16Array(Tt.maxIndicesCount), _this39._indexBuffer = new Ye(e.IndexFormat.UInt16, _this39._indices.length, r.DYNAMIC_DRAW);
            var a = _this39._vertexBuffer._byteLength + _this39._indexBuffer._byteLength;
            t.Resource._addMemory(a, a);
            return _this39;
        }
        _createClass(Tt, [{
            key: "_getBatchVertices",
            value: function _getBatchVertices(e, t, r, i, a, n) {
                var s = e.vertexStride / 4,
                    o = n._vertexBuffer.getFloat32Data(),
                    l = (a.render.lightmapScaleOffset,
                        a._dynamicMultiSubMesh),
                    _ = a._dynamicVertexCount;
                a._computeWorldPositionsAndNormals(this._positionOffset, this._normalOffset, l, _);
                for (var h = a._dynamicWorldPositions, c = a._dynamicWorldNormals, d = n._indices, u = 0; u < _; u++) {
                    var m = (l ? d[u] : u) * s,
                        f = (u + r) * s,
                        E = 3 * u,
                        T = f + this._positionOffset;
                    t[T] = h[E], t[T + 1] = h[E + 1], t[T + 2] = h[E + 2], -1 !== this._normalOffset && (t[T = f + this._normalOffset] = c[E],
                        t[T + 1] = c[E + 1], t[T + 2] = c[E + 2]), -1 !== this._colorOffset && (T = f + this._colorOffset,
                        E = m + this._colorOffset, t[T] = o[E], t[T + 1] = o[E + 1], t[T + 2] = o[E + 2],
                        t[T + 3] = o[E + 3]), -1 !== this._uv0Offset && (T = f + this._uv0Offset, E = m + this._uv0Offset,
                        t[T] = o[E], t[T + 1] = o[E + 1]), -1 !== this._sTangentOffset && (T = f + this._sTangentOffset,
                        E = m + this._sTangentOffset, t[T] = o[E], t[T + 1] = o[E + 1], t[T + 2] = o[E + 2],
                        t[T + 3] = o[E + 3], T = f + this._sTangentOffset, E = m + this._sTangentOffset,
                        t[T] = o[E], t[T + 1] = o[E + 1], t[T + 2] = o[E + 2], t[T + 3] = o[E + 3]);
                }
            }
        }, {
            key: "_getBatchIndices",
            value: function _getBatchIndices(e, t, r, i, a, n) {
                var s, o, l, _ = a._indices,
                    h = i._isFrontFaceInvert;
                if (n) {
                    if (h)
                        for (s = 0, o = _.length; s < o; s += 3) {
                            var c = r + s;
                            e[l = t + s] = c, e[l + 1] = c + 2, e[l + 2] = c + 1;
                        } else
                            for (s = 0, o = _.length; s < o; s += 3) {
                                c = r + s, e[l = t + s] = c, e[l + 1] = c + 1, e[l + 2] = c + 2;
                            }
                } else if (h)
                    for (s = 0, o = _.length; s < o; s += 3) {
                        e[l = t + s] = r + _[s], e[l + 1] = r + _[s + 2], e[l + 2] = r + _[s + 1];
                    } else
                        for (s = 0, o = _.length; s < o; s += 3) {
                            e[l = t + s] = r + _[s], e[l + 1] = r + _[s + 1], e[l + 2] = r + _[s + 2];
                        }
            }
        }, {
            key: "_flush",
            value: function _flush(e, r) {
                var i = t.LayaGL.instance;
                this._vertexBuffer.setData(this._vertices.buffer, 0, 0, e * this._bufferState.vertexDeclaration.vertexStride),
                    this._indexBuffer.setData(this._indices, 0, 0, r), i.drawElements(i.TRIANGLES, r, i.UNSIGNED_SHORT, 0);
            }
        }, {
            key: "_prepareRender",
            value: function _prepareRender(e) {
                var t = e.renderElement.vertexBatchVertexDeclaration;
                this._bufferState = _.MeshRenderDynamicBatchManager.instance._getBufferState(t),
                    this._positionOffset = t.getVertexElementByUsage(ce.MESH_POSITION0)._offset / 4;
                var r = t.getVertexElementByUsage(ce.MESH_NORMAL0);
                this._normalOffset = r ? r._offset / 4 : -1;
                var i = t.getVertexElementByUsage(ce.MESH_COLOR0);
                this._colorOffset = i ? i._offset / 4 : -1;
                var a = t.getVertexElementByUsage(ce.MESH_TEXTURECOORDINATE0);
                this._uv0Offset = a ? a._offset / 4 : -1;
                var n = t.getVertexElementByUsage(ce.MESH_TEXTURECOORDINATE1);
                this._uv1Offset = n ? n._offset / 4 : -1;
                var s = t.getVertexElementByUsage(ce.MESH_TANGENT0);
                return this._sTangentOffset = s ? s._offset / 4 : -1, !0;
            }
        }, {
            key: "_render",
            value: function _render(e) {
                this._bufferState.bind();
                for (var r = e.renderElement, i = r.vertexBatchVertexDeclaration, a = r.vertexBatchElementList, n = 0, s = 0, o = (i.vertexStride,
                        0), l = a.length, _ = a.elements, h = 0; h < l; h++) {
                    var c = _[h],
                        d = c._geometry,
                        u = d._indexCount;
                    s + u > Tt.maxIndicesCount && (this._flush(n, s), o++, t.Stat.trianglesFaces += s / 3,
                        n = s = 0);
                    var m = c._transform;
                    this._getBatchVertices(i, this._vertices, n, m, c, d), this._getBatchIndices(this._indices, s, n, m, d, c._dynamicMultiSubMesh),
                        n += c._dynamicVertexCount, s += u;
                }
                this._flush(n, s), o++, t.Stat.renderBatches += o, t.Stat.savedRenderBatches += l - o,
                    t.Stat.trianglesFaces += s / 3;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                Tt.instance = new Tt();
            }
        }]);
        return Tt;
    }(Pe);
    Tt.maxAllowVertexCount = 10, Tt.maxAllowAttribueCount = 900, Tt.maxIndicesCount = 32e3;
    var pt = /* */ function(_Me) {
        _inherits(pt, _Me);

        function pt() {
            var _this40;
            _classCallCheck(this, pt);
            _this40 = _possibleConstructorReturn(this, _getPrototypeOf(pt).call(this)), _this40._instanceBatchOpaqueMarks = [],
                _this40._vertexBatchOpaqueMarks = [], _this40._cacheBufferStates = [], _this40._updateCountMark = 0;
            return _this40;
        }
        _createClass(pt, [{
            key: "getInstanceBatchOpaquaMark",
            value: function getInstanceBatchOpaquaMark(e, t, r, i) {
                var a = this._instanceBatchOpaqueMarks[e ? 0 : 1] || (this._instanceBatchOpaqueMarks[e ? 0 : 1] = []),
                    n = a[t] || (a[t] = []),
                    s = n[r] || (n[r] = []);
                return s[i ? 1 : 0] || (s[i ? 1 : 0] = new Ne());
            }
        }, {
            key: "getVertexBatchOpaquaMark",
            value: function getVertexBatchOpaquaMark(e, t, r, i) {
                var a = this._vertexBatchOpaqueMarks[e] || (this._vertexBatchOpaqueMarks[e] = []),
                    n = a[t ? 0 : 1] || (a[t ? 0 : 1] = []),
                    s = n[r] || (n[r] = []);
                return s[i] || (s[i] = new Ne());
            }
        }, {
            key: "_getBufferState",
            value: function _getBufferState(e) {
                var t = this._cacheBufferStates[e.id];
                if (!t) {
                    var r = Tt.instance;
                    (t = new Xe()).bind();
                    var i = r._vertexBuffer;
                    i.vertexDeclaration = e, t.applyVertexBuffer(i), t.applyIndexBuffer(r._indexBuffer),
                        t.unBind(), this._cacheBufferStates[e.id] = t;
                }
                return t;
            }
        }, {
            key: "_getBatchRenderElementFromPool",
            value: function _getBatchRenderElementFromPool() {
                var e = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
                return e || (e = new ot(), this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = e,
                    e.vertexBatchElementList = new _t(), e.instanceBatchElementList = new _t()), e;
            }
        }, {
            key: "_clear",
            value: function _clear() {
                _get(_getPrototypeOf(pt.prototype), "_clear", this).call(this), this._updateCountMark++;
            }
        }]);
        return pt;
    }(Me);
    pt.instance = new pt();
    var gt = /* */ function(_ye) {
        _inherits(gt, _ye);
        _createClass(gt, [{
            key: "meshFilter",
            get: function get() {
                return this._meshFilter;
            }
        }, {
            key: "meshRenderer",
            get: function get() {
                return this._render;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                ct.SHADERDEFINE_UV0 = H.getDefineByName("UV"), ct.SHADERDEFINE_COLOR = H.getDefineByName("COLOR"),
                    ct.SHADERDEFINE_UV1 = H.getDefineByName("UV1"), ct.SHADERDEFINE_GPU_INSTANCE = H.getDefineByName("GPU_INSTANCE"),
                    Ce._registerManager(ht.instance), Me._registerManager(pt.instance);
            }
        }]);

        function gt() {
            var _this41;
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            _classCallCheck(this, gt);
            _this41 = _possibleConstructorReturn(this, _getPrototypeOf(gt).call(this, t)), _this41._meshFilter = new Et(_assertThisInitialized(_this41)),
                _this41._render = new ft(_assertThisInitialized(_this41)), e && (_this41._meshFilter.sharedMesh = e);
            return _this41;
        }
        _createClass(gt, [{
            key: "_parse",
            value: function _parse(e, r) {
                _get(_getPrototypeOf(gt.prototype), "_parse", this).call(this, e, r);
                var i = this.meshRenderer,
                    n = e.lightmapIndex;
                null != n && (i.lightmapIndex = n);
                var s = e.lightmapScaleOffset;
                s && (i.lightmapScaleOffset = new a(s[0], s[1], s[2], s[3])), null != e.meshPath && (this.meshFilter.sharedMesh = t.Loader.getRes(e.meshPath)),
                    null != e.enableRender && (this.meshRenderer.enable = e.enableRender);
                var o = e.materials;
                if (o) {
                    var l = i.sharedMaterials,
                        _ = o.length;
                    l.length = _;
                    for (var h = 0; h < _; h++) {
                        l[h] = t.Loader.getRes(o[h].path);
                    }
                    i.sharedMaterials = l;
                }
            }
        }, {
            key: "_addToInitStaticBatchManager",
            value: function _addToInitStaticBatchManager() {
                this.meshFilter.sharedMesh && ht.instance._addBatchSprite(this);
            }
        }, {
            key: "_cloneTo",
            value: function _cloneTo(e, t, r) {
                var i = e;
                i._meshFilter.sharedMesh = this._meshFilter.sharedMesh;
                var a = this._render,
                    n = i._render;
                n.enable = a.enable, n.sharedMaterials = a.sharedMaterials, n.castShadow = a.castShadow;
                var s = a.lightmapScaleOffset;
                s && (n.lightmapScaleOffset = s.clone()), n.lightmapIndex = a.lightmapIndex, n.receiveShadow = a.receiveShadow,
                    n.sortingFudge = a.sortingFudge, _get(_getPrototypeOf(gt.prototype), "_cloneTo", this).call(this, e, t, r);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
                this.destroyed || (_get(_getPrototypeOf(gt.prototype), "destroy", this).call(this, e),
                    this._meshFilter.destroy());
            }
        }, {
            key: "_create",
            value: function _create() {
                return new gt();
            }
        }]);
        return gt;
    }(ye);
    var St = function St() {
        _classCallCheck(this, St);
    };
    St.Blend = 0, St.Fixed = 1;
    var Rt = /* */ function() {
        function Rt(e, t) {
            _classCallCheck(this, Rt);
            this._mode = 0, this._maxColorRGBKeysCount = 0, this._maxColorAlphaKeysCount = 0,
                this._colorRGBKeysCount = 0, this._colorAlphaKeysCount = 0, this._alphaElements = null,
                this._rgbElements = null, this._maxColorRGBKeysCount = e, this._maxColorAlphaKeysCount = t,
                this._rgbElements = new Float32Array(4 * e), this._alphaElements = new Float32Array(2 * t);
        }
        _createClass(Rt, [{
            key: "addColorRGB",
            value: function addColorRGB(e, t) {
                if (this._colorRGBKeysCount < this._maxColorRGBKeysCount) {
                    var r = 4 * this._colorRGBKeysCount;
                    this._rgbElements[r] = e, this._rgbElements[r + 1] = t.r, this._rgbElements[r + 2] = t.g,
                        this._rgbElements[r + 3] = t.b, this._colorRGBKeysCount++;
                } else console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorRGBKeysCount);
            }
        }, {
            key: "addColorAlpha",
            value: function addColorAlpha(e, t) {
                if (this._colorAlphaKeysCount < this._maxColorAlphaKeysCount) {
                    var r = 2 * this._colorAlphaKeysCount;
                    this._alphaElements[r] = e, this._alphaElements[r + 1] = t, this._colorAlphaKeysCount++;
                } else console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorAlphaKeysCount);
            }
        }, {
            key: "updateColorRGB",
            value: function updateColorRGB(e, t, r) {
                if (e < this._colorRGBKeysCount) {
                    var i = 4 * e;
                    this._rgbElements[i] = t, this._rgbElements[i + 1] = r.r, this._rgbElements[i + 2] = r.g,
                        this._rgbElements[i + 3] = r.b;
                } else console.warn("Gradient:warning:index must lessEqual than colorRGBKeysCount:" + this._colorRGBKeysCount);
            }
        }, {
            key: "updateColorAlpha",
            value: function updateColorAlpha(e, t, r) {
                if (e < this._colorAlphaKeysCount) {
                    var i = 2 * e;
                    this._alphaElements[i] = t, this._alphaElements[i + 1] = r;
                } else console.warn("Gradient:warning:index must lessEqual than colorAlphaKeysCount:" + this._colorAlphaKeysCount);
            }
        }, {
            key: "evaluateColorRGB",
            value: function evaluateColorRGB(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
                e = Math.min(Math.max(e, 0), 1);
                var a = this._rgbElements,
                    n = r;
                if (i)
                    for (var s = n; s >= 0; s--) {
                        var o = 4 * s;
                        if (e === (u = a[o])) return t.r = a[o + 1], t.g = a[o + 2], t.b = a[o + 3], n;
                        switch (this._mode) {
                            case St.Blend:
                                if (e > u) {
                                    if (e > (d = a[o + 4])) throw "Gradient:wrong startSearchIndex.";
                                    var l = d - u,
                                        _ = d - e,
                                        h = e - u;
                                    return t.r = (_ * a[o + 1] + h * a[o + 5]) / l, t.g = (_ * a[o + 2] + h * a[o + 6]) / l,
                                        t.b = (_ * a[o + 3] + h * a[o + 7]) / l, n;
                                }
                                n--;
                                continue;

                            case St.Fixed:
                                if (e > u) {
                                    if (e > a[o + 4]) throw "Gradient:wrong startSearchIndex.";
                                    return t.r = a[o + 5], t.g = a[o + 6], t.b = a[o + 7], n;
                                }
                                n--;
                                continue;

                            default:
                                throw "Gradient:unknown mode.";
                        }
                    } else {
                        s = 0;
                        for (var c = this._rgbElements.length; s < c; s++) {
                            var d;
                            if (e === (d = a[o = 4 * s])) return t.r = a[o + 1], t.g = a[o + 2], t.b = a[o + 3],
                                n;
                            switch (this._mode) {
                                case St.Blend:
                                    if (e < d) {
                                        var u;
                                        if (e < (u = a[o - 4])) throw "Gradient:wrong startSearchIndex.";
                                        l = d - u, _ = d - e, h = e - u;
                                        return t.r = (_ * a[o - 3] + h * a[o + 1]) / l, t.g = (_ * a[o - 2] + h * a[o + 2]) / l,
                                            t.b = (_ * a[o - 1] + h * a[o + 3]) / l, n;
                                    }
                                    n++;
                                    continue;

                                case St.Fixed:
                                    if (e < d) {
                                        if (e < a[o - 4]) throw "Gradient:wrong startSearchIndex.";
                                        return t.r = a[o + 1], t.g = a[o + 2], t.b = a[o + 3], n;
                                    }
                                    n++;
                                    continue;

                                default:
                                    throw "Gradient:unknown mode.";
                            }
                        }
                    }
                return n;
            }
        }, {
            key: "evaluateColorAlpha",
            value: function evaluateColorAlpha(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
                e = Math.min(Math.max(e, 0), 1);
                var a = this._alphaElements,
                    n = r;
                if (i)
                    for (var s = n; s >= 0; s--) {
                        if (e === (u = a[c = 2 * s])) return t.a = a[c + 1], n;
                        switch (this._mode) {
                            case St.Blend:
                                if (e > u) {
                                    if (e > (d = a[c + 2])) throw "Gradient:wrong startSearchIndex.";
                                    var o = d - u,
                                        l = d - e,
                                        _ = e - u;
                                    return t.a = (l * a[c + 1] + _ * a[c + 3]) / o, n;
                                }
                                n--;
                                continue;

                            case St.Fixed:
                                if (e > u) {
                                    if (e > a[c + 2]) throw "Gradient:wrong startSearchIndex.";
                                    return t.a = a[c + 3], n;
                                }
                                n--;
                                continue;

                            default:
                                throw "Gradient:unknown mode.";
                        }
                    } else {
                        s = n;
                        for (var h = this._alphaElements.length; s < h; s++) {
                            var c, d;
                            if (e === (d = a[c = 2 * s])) return t.a = a[c + 1], n;
                            switch (this._mode) {
                                case St.Blend:
                                    if (e < d) {
                                        var u;
                                        if (e < (u = a[c - 2])) throw "Gradient:wrong startSearchIndex.";
                                        o = d - u, l = d - e, _ = e - u;
                                        return t.a = (l * a[c - 1] + _ * a[c + 1]) / o, n;
                                    }
                                    n++;
                                    continue;

                                case St.Fixed:
                                    if (e < d) {
                                        if (e < a[c - 2]) throw "Gradient:wrong startSearchIndex.";
                                        return t.a = a[c + 1], n;
                                    }
                                    n++;
                                    continue;

                                default:
                                    throw "Gradient:unknown mode.";
                            }
                        }
                    }
                return n;
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t, r, i = e;
                i._colorAlphaKeysCount = this._colorAlphaKeysCount;
                var a = i._alphaElements;
                for (t = 0, r = this._alphaElements.length; t < r; t++) {
                    a[t] = this._alphaElements[t];
                }
                i._colorRGBKeysCount = this._colorRGBKeysCount;
                var n = i._rgbElements;
                for (t = 0, r = this._rgbElements.length; t < r; t++) {
                    n[t] = this._rgbElements[t];
                }
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Rt(this._maxColorRGBKeysCount, this._maxColorAlphaKeysCount);
                return this.cloneTo(e), e;
            }
        }, {
            key: "mode",
            get: function get() {
                return this._mode;
            },
            set: function set(e) {
                this._mode = e;
            }
        }, {
            key: "colorRGBKeysCount",
            get: function get() {
                return this._colorRGBKeysCount;
            }
        }, {
            key: "colorAlphaKeysCount",
            get: function get() {
                return this._colorAlphaKeysCount;
            }
        }, {
            key: "maxColorRGBKeysCount",
            get: function get() {
                return this._maxColorRGBKeysCount;
            }
        }, {
            key: "maxColorAlphaKeysCount",
            get: function get() {
                return this._maxColorAlphaKeysCount;
            }
        }]);
        return Rt;
    }();
    var vt = /* */ function() {
        _createClass(vt, [{
            key: "time",
            get: function get() {
                return this._time;
            }
        }, {
            key: "minCount",
            get: function get() {
                return this._minCount;
            }
        }, {
            key: "maxCount",
            get: function get() {
                return this._maxCount;
            }
        }]);

        function vt(e, t, r) {
            _classCallCheck(this, vt);
            this._time = e, this._minCount = t, this._maxCount = r;
        }
        _createClass(vt, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t._time = this._time, t._minCount = this._minCount, t._maxCount = this._maxCount;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new vt(this._time, this._minCount, this._maxCount);
                return this.cloneTo(e), e;
            }
        }]);
        return vt;
    }();
    var xt = /* */ function() {
        function xt() {
            _classCallCheck(this, xt);
            this._type = 0, this._constant = null, this._constantMin = null, this._constantMax = null,
                this._gradient = null, this._gradientMin = null, this._gradientMax = null;
        }
        _createClass(xt, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t._type = this._type, this._constant.cloneTo(t._constant), this._constantMin.cloneTo(t._constantMin),
                    this._constantMax.cloneTo(t._constantMax), this._gradient.cloneTo(t._gradient),
                    this._gradientMin.cloneTo(t._gradientMin), this._gradientMax.cloneTo(t._gradientMax);
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new xt();
                return this.cloneTo(e), e;
            }
        }, {
            key: "type",
            get: function get() {
                return this._type;
            }
        }, {
            key: "constant",
            get: function get() {
                return this._constant;
            }
        }, {
            key: "constantMin",
            get: function get() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function get() {
                return this._constantMax;
            }
        }, {
            key: "gradient",
            get: function get() {
                return this._gradient;
            }
        }, {
            key: "gradientMin",
            get: function get() {
                return this._gradientMin;
            }
        }, {
            key: "gradientMax",
            get: function get() {
                return this._gradientMax;
            }
        }], [{
            key: "createByConstant",
            value: function createByConstant(e) {
                var t = new xt();
                return t._type = 0, t._constant = e, t;
            }
        }, {
            key: "createByGradient",
            value: function createByGradient(e) {
                var t = new xt();
                return t._type = 1, t._gradient = e, t;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function createByRandomTwoConstant(e, t) {
                var r = new xt();
                return r._type = 2, r._constantMin = e, r._constantMax = t, r;
            }
        }, {
            key: "createByRandomTwoGradient",
            value: function createByRandomTwoGradient(e, t) {
                var r = new xt();
                return r._type = 3, r._gradientMin = e, r._gradientMax = t, r;
            }
        }]);
        return xt;
    }();
    var It = /* */ function() {
        _createClass(It, [{
            key: "color",
            get: function get() {
                return this._color;
            }
        }]);

        function It(e) {
            _classCallCheck(this, It);
            this._color = e;
        }
        _createClass(It, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                this._color.cloneTo(t._color), t.enable = this.enable;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e;
                switch (this._color.type) {
                    case 0:
                        e = xt.createByConstant(this._color.constant.clone());
                        break;

                    case 1:
                        e = xt.createByGradient(this._color.gradient.clone());
                        break;

                    case 2:
                        e = xt.createByRandomTwoConstant(this._color.constantMin.clone(), this._color.constantMax.clone());
                        break;

                    case 3:
                        e = xt.createByRandomTwoGradient(this._color.gradientMin.clone(), this._color.gradientMax.clone());
                }
                var t = new It(e);
                return t.enable = this.enable, t;
            }
        }]);
        return It;
    }();
    var At = /* */ function() {
        function At() {
            _classCallCheck(this, At);
            this._type = 0, this._constant = 0, this._overTime = null, this._constantMin = 0,
                this._constantMax = 0, this._overTimeMin = null, this._overTimeMax = null;
        }
        _createClass(At, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t._type = this._type, t._constant = this._constant, this._overTime && this._overTime.cloneTo(t._overTime),
                    t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._overTimeMin && this._overTimeMin.cloneTo(t._overTimeMin),
                    this._overTimeMax && this._overTimeMax.cloneTo(t._overTimeMax);
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new At();
                return this.cloneTo(e), e;
            }
        }, {
            key: "type",
            get: function get() {
                return this._type;
            }
        }, {
            key: "constant",
            get: function get() {
                return this._constant;
            }
        }, {
            key: "frameOverTimeData",
            get: function get() {
                return this._overTime;
            }
        }, {
            key: "constantMin",
            get: function get() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function get() {
                return this._constantMax;
            }
        }, {
            key: "frameOverTimeDataMin",
            get: function get() {
                return this._overTimeMin;
            }
        }, {
            key: "frameOverTimeDataMax",
            get: function get() {
                return this._overTimeMax;
            }
        }], [{
            key: "createByConstant",
            value: function createByConstant() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var t = new At();
                return t._type = 0, t._constant = e, t;
            }
        }, {
            key: "createByOverTime",
            value: function createByOverTime(e) {
                var t = new At();
                return t._type = 1, t._overTime = e, t;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function createByRandomTwoConstant() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var r = new At();
                return r._type = 2, r._constantMin = e, r._constantMax = t, r;
            }
        }, {
            key: "createByRandomTwoOverTime",
            value: function createByRandomTwoOverTime(e, t) {
                var r = new At();
                return r._type = 3, r._overTimeMin = e, r._overTimeMax = t, r;
            }
        }]);
        return At;
    }();
    var Mt = /* */ function() {
        function Mt() {
            _classCallCheck(this, Mt);
            this._type = 0, this._separateAxes = !1, this._constant = 0, this._constantSeparate = null,
                this._gradient = null, this._gradientX = null, this._gradientY = null, this._gradientZ = null,
                this._gradientW = null, this._constantMin = 0, this._constantMax = 0, this._constantMinSeparate = null,
                this._constantMaxSeparate = null, this._gradientMin = null, this._gradientMax = null,
                this._gradientXMin = null, this._gradientXMax = null, this._gradientYMin = null,
                this._gradientYMax = null, this._gradientZMin = null, this._gradientZMax = null,
                this._gradientWMin = null, this._gradientWMax = null;
        }
        _createClass(Mt, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t._type = this._type, t._separateAxes = this._separateAxes, t._constant = this._constant,
                    this._constantSeparate.cloneTo(t._constantSeparate), this._gradient.cloneTo(t._gradient),
                    this._gradientX.cloneTo(t._gradientX), this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ),
                    t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._constantMinSeparate.cloneTo(t._constantMinSeparate),
                    this._constantMaxSeparate.cloneTo(t._constantMaxSeparate), this._gradientMin.cloneTo(t._gradientMin),
                    this._gradientMax.cloneTo(t._gradientMax), this._gradientXMin.cloneTo(t._gradientXMin),
                    this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin),
                    this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin),
                    this._gradientZMax.cloneTo(t._gradientZMax);
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Mt();
                return this.cloneTo(e), e;
            }
        }, {
            key: "type",
            get: function get() {
                return this._type;
            }
        }, {
            key: "separateAxes",
            get: function get() {
                return this._separateAxes;
            }
        }, {
            key: "constant",
            get: function get() {
                return this._constant;
            }
        }, {
            key: "constantSeparate",
            get: function get() {
                return this._constantSeparate;
            }
        }, {
            key: "gradient",
            get: function get() {
                return this._gradient;
            }
        }, {
            key: "gradientX",
            get: function get() {
                return this._gradientX;
            }
        }, {
            key: "gradientY",
            get: function get() {
                return this._gradientY;
            }
        }, {
            key: "gradientZ",
            get: function get() {
                return this._gradientZ;
            }
        }, {
            key: "gradientW",
            get: function get() {
                return this._gradientW;
            }
        }, {
            key: "constantMin",
            get: function get() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function get() {
                return this._constantMax;
            }
        }, {
            key: "constantMinSeparate",
            get: function get() {
                return this._constantMinSeparate;
            }
        }, {
            key: "constantMaxSeparate",
            get: function get() {
                return this._constantMaxSeparate;
            }
        }, {
            key: "gradientMin",
            get: function get() {
                return this._gradientMin;
            }
        }, {
            key: "gradientMax",
            get: function get() {
                return this._gradientMax;
            }
        }, {
            key: "gradientXMin",
            get: function get() {
                return this._gradientXMin;
            }
        }, {
            key: "gradientXMax",
            get: function get() {
                return this._gradientXMax;
            }
        }, {
            key: "gradientYMin",
            get: function get() {
                return this._gradientYMin;
            }
        }, {
            key: "gradientYMax",
            get: function get() {
                return this._gradientYMax;
            }
        }, {
            key: "gradientZMin",
            get: function get() {
                return this._gradientZMin;
            }
        }, {
            key: "gradientZMax",
            get: function get() {
                return this._gradientZMax;
            }
        }, {
            key: "gradientWMin",
            get: function get() {
                return this._gradientWMin;
            }
        }, {
            key: "gradientWMax",
            get: function get() {
                return this._gradientWMax;
            }
        }], [{
            key: "createByConstant",
            value: function createByConstant(e) {
                var t = new Mt();
                return t._type = 0, t._separateAxes = !1, t._constant = e, t;
            }
        }, {
            key: "createByConstantSeparate",
            value: function createByConstantSeparate(e) {
                var t = new Mt();
                return t._type = 0, t._separateAxes = !0, t._constantSeparate = e, t;
            }
        }, {
            key: "createByGradient",
            value: function createByGradient(e) {
                var t = new Mt();
                return t._type = 1, t._separateAxes = !1, t._gradient = e, t;
            }
        }, {
            key: "createByGradientSeparate",
            value: function createByGradientSeparate(e, t, r) {
                var i = new Mt();
                return i._type = 1, i._separateAxes = !0, i._gradientX = e, i._gradientY = t, i._gradientZ = r,
                    i;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function createByRandomTwoConstant(e, t) {
                var r = new Mt();
                return r._type = 2, r._separateAxes = !1, r._constantMin = e, r._constantMax = t,
                    r;
            }
        }, {
            key: "createByRandomTwoConstantSeparate",
            value: function createByRandomTwoConstantSeparate(e, t) {
                var r = new Mt();
                return r._type = 2, r._separateAxes = !0, r._constantMinSeparate = e, r._constantMaxSeparate = t,
                    r;
            }
        }, {
            key: "createByRandomTwoGradient",
            value: function createByRandomTwoGradient(e, t) {
                var r = new Mt();
                return r._type = 3, r._separateAxes = !1, r._gradientMin = e, r._gradientMax = t,
                    r;
            }
        }, {
            key: "createByRandomTwoGradientSeparate",
            value: function createByRandomTwoGradientSeparate(e, t, r, i, a, n, s, o) {
                var l = new Mt();
                return l._type = 3, l._separateAxes = !0, l._gradientXMin = e, l._gradientXMax = t,
                    l._gradientYMin = r, l._gradientYMax = i, l._gradientZMin = a, l._gradientZMax = n,
                    l._gradientWMin = s, l._gradientWMax = o, l;
            }
        }]);
        return Mt;
    }();
    var Dt = /* */ function() {
        function Dt() {
            _classCallCheck(this, Dt);
            this._currentLength = 0, this._elements = new Float32Array(8);
        }
        _createClass(Dt, [{
            key: "add",
            value: function add(e, t) {
                this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("Warning:the forth key is  be force set to 1.")),
                    this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t) : console.log("Warning:data count must lessEqual than 4");
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t._currentLength = this._currentLength;
                for (var r = t._elements, i = 0, a = this._elements.length; i < a; i++) {
                    r[i] = this._elements[i];
                }
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Dt();
                return this.cloneTo(e), e;
            }
        }, {
            key: "gradientCount",
            get: function get() {
                return this._currentLength / 2;
            }
        }]);
        return Dt;
    }();
    var Lt = /* */ function() {
        function Lt() {
            _classCallCheck(this, Lt);
            this._currentLength = 0, this._elements = new Float32Array(8);
        }
        _createClass(Lt, [{
            key: "add",
            value: function add(e, t) {
                this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("GradientDataNumber warning:the forth key is  be force set to 1.")),
                    this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t) : console.log("GradientDataNumber warning:data count must lessEqual than 4");
            }
        }, {
            key: "getKeyByIndex",
            value: function getKeyByIndex(e) {
                return this._elements[2 * e];
            }
        }, {
            key: "getValueByIndex",
            value: function getValueByIndex(e) {
                return this._elements[2 * e + 1];
            }
        }, {
            key: "getAverageValue",
            value: function getAverageValue() {
                for (var e = 0, t = this._currentLength - 2; e < t; e += 2) {
                    this._elements[e + 1];
                    this._elements[e + 3], this._elements[e + 2] - this._elements[e];
                }
                return 0;
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t._currentLength = this._currentLength;
                for (var r = t._elements, i = 0, a = this._elements.length; i < a; i++) {
                    r[i] = this._elements[i];
                }
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Lt();
                return this.cloneTo(e), e;
            }
        }, {
            key: "gradientCount",
            get: function get() {
                return this._currentLength / 2;
            }
        }]);
        return Lt;
    }();
    var yt = /* */ function() {
        function yt() {
            _classCallCheck(this, yt);
            this._type = 0, this._separateAxes = !1, this._gradient = null, this._gradientX = null,
                this._gradientY = null, this._gradientZ = null, this._constantMin = 0, this._constantMax = 0,
                this._constantMinSeparate = null, this._constantMaxSeparate = null, this._gradientMin = null,
                this._gradientMax = null, this._gradientXMin = null, this._gradientXMax = null,
                this._gradientYMin = null, this._gradientYMax = null, this._gradientZMin = null,
                this._gradientZMax = null;
        }
        _createClass(yt, [{
            key: "getMaxSizeInGradient",
            value: function getMaxSizeInGradient() {
                var e, t, r = -Number.MAX_VALUE;
                switch (this._type) {
                    case 0:
                        if (this._separateAxes) {
                            for (e = 0, t = this._gradientX.gradientCount; e < t; e++) {
                                r = Math.max(r, this._gradientX.getValueByIndex(e));
                            }
                            for (e = 0, t = this._gradientY.gradientCount; e < t; e++) {
                                r = Math.max(r, this._gradientY.getValueByIndex(e));
                            }
                        } else
                            for (e = 0, t = this._gradient.gradientCount; e < t; e++) {
                                r = Math.max(r, this._gradient.getValueByIndex(e));
                            }
                        break;

                    case 1:
                        this._separateAxes ? (r = Math.max(this._constantMinSeparate.x, this._constantMaxSeparate.x),
                            r = Math.max(r, this._constantMinSeparate.y), r = Math.max(r, this._constantMaxSeparate.y)) : r = Math.max(this._constantMin, this._constantMax);
                        break;

                    case 2:
                        if (this._separateAxes) {
                            for (e = 0, t = this._gradientXMin.gradientCount; e < t; e++) {
                                r = Math.max(r, this._gradientXMin.getValueByIndex(e));
                            }
                            for (e = 0, t = this._gradientXMax.gradientCount; e < t; e++) {
                                r = Math.max(r, this._gradientXMax.getValueByIndex(e));
                            }
                            for (e = 0, t = this._gradientYMin.gradientCount; e < t; e++) {
                                r = Math.max(r, this._gradientYMin.getValueByIndex(e));
                            }
                            for (e = 0, t = this._gradientZMax.gradientCount; e < t; e++) {
                                r = Math.max(r, this._gradientZMax.getValueByIndex(e));
                            }
                        } else {
                            for (e = 0, t = this._gradientMin.gradientCount; e < t; e++) {
                                r = Math.max(r, this._gradientMin.getValueByIndex(e));
                            }
                            for (e = 0, t = this._gradientMax.gradientCount; e < t; e++) {
                                r = Math.max(r, this._gradientMax.getValueByIndex(e));
                            }
                        }
                }
                return r;
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t._type = this._type, t._separateAxes = this._separateAxes, this._gradient.cloneTo(t._gradient),
                    this._gradientX.cloneTo(t._gradientX), this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ),
                    t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._constantMinSeparate.cloneTo(t._constantMinSeparate),
                    this._constantMaxSeparate.cloneTo(t._constantMaxSeparate), this._gradientMin.cloneTo(t._gradientMin),
                    this._gradientMax.cloneTo(t._gradientMax), this._gradientXMin.cloneTo(t._gradientXMin),
                    this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin),
                    this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin),
                    this._gradientZMax.cloneTo(t._gradientZMax);
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new yt();
                return this.cloneTo(e), e;
            }
        }, {
            key: "type",
            get: function get() {
                return this._type;
            }
        }, {
            key: "separateAxes",
            get: function get() {
                return this._separateAxes;
            }
        }, {
            key: "gradient",
            get: function get() {
                return this._gradient;
            }
        }, {
            key: "gradientX",
            get: function get() {
                return this._gradientX;
            }
        }, {
            key: "gradientY",
            get: function get() {
                return this._gradientY;
            }
        }, {
            key: "gradientZ",
            get: function get() {
                return this._gradientZ;
            }
        }, {
            key: "constantMin",
            get: function get() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function get() {
                return this._constantMax;
            }
        }, {
            key: "constantMinSeparate",
            get: function get() {
                return this._constantMinSeparate;
            }
        }, {
            key: "constantMaxSeparate",
            get: function get() {
                return this._constantMaxSeparate;
            }
        }, {
            key: "gradientMin",
            get: function get() {
                return this._gradientMin;
            }
        }, {
            key: "gradientMax",
            get: function get() {
                return this._gradientMax;
            }
        }, {
            key: "gradientXMin",
            get: function get() {
                return this._gradientXMin;
            }
        }, {
            key: "gradientXMax",
            get: function get() {
                return this._gradientXMax;
            }
        }, {
            key: "gradientYMin",
            get: function get() {
                return this._gradientYMin;
            }
        }, {
            key: "gradientYMax",
            get: function get() {
                return this._gradientYMax;
            }
        }, {
            key: "gradientZMin",
            get: function get() {
                return this._gradientZMin;
            }
        }, {
            key: "gradientZMax",
            get: function get() {
                return this._gradientZMax;
            }
        }], [{
            key: "createByGradient",
            value: function createByGradient(e) {
                var t = new yt();
                return t._type = 0, t._separateAxes = !1, t._gradient = e, t;
            }
        }, {
            key: "createByGradientSeparate",
            value: function createByGradientSeparate(e, t, r) {
                var i = new yt();
                return i._type = 0, i._separateAxes = !0, i._gradientX = e, i._gradientY = t, i._gradientZ = r,
                    i;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function createByRandomTwoConstant(e, t) {
                var r = new yt();
                return r._type = 1, r._separateAxes = !1, r._constantMin = e, r._constantMax = t,
                    r;
            }
        }, {
            key: "createByRandomTwoConstantSeparate",
            value: function createByRandomTwoConstantSeparate(e, t) {
                var r = new yt();
                return r._type = 1, r._separateAxes = !0, r._constantMinSeparate = e, r._constantMaxSeparate = t,
                    r;
            }
        }, {
            key: "createByRandomTwoGradient",
            value: function createByRandomTwoGradient(e, t) {
                var r = new yt();
                return r._type = 2, r._separateAxes = !1, r._gradientMin = e, r._gradientMax = t,
                    r;
            }
        }, {
            key: "createByRandomTwoGradientSeparate",
            value: function createByRandomTwoGradientSeparate(e, t, r, i, a, n) {
                var s = new yt();
                return s._type = 2, s._separateAxes = !0, s._gradientXMin = e, s._gradientXMax = t,
                    s._gradientYMin = r, s._gradientYMax = i, s._gradientZMin = a, s._gradientZMax = n,
                    s;
            }
        }]);
        return yt;
    }();
    var Ct = /* */ function() {
        function Ct() {
            _classCallCheck(this, Ct);
            this._type = 0, this._constant = null, this._gradientX = null, this._gradientY = null,
                this._gradientZ = null, this._constantMin = null, this._constantMax = null, this._gradientXMin = null,
                this._gradientXMax = null, this._gradientYMin = null, this._gradientYMax = null,
                this._gradientZMin = null, this._gradientZMax = null;
        }
        _createClass(Ct, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t._type = this._type, this._constant.cloneTo(t._constant), this._gradientX.cloneTo(t._gradientX),
                    this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ), this._constantMin.cloneTo(t._constantMin),
                    this._constantMax.cloneTo(t._constantMax), this._gradientXMin.cloneTo(t._gradientXMin),
                    this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin),
                    this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin),
                    this._gradientZMax.cloneTo(t._gradientZMax);
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Ct();
                return this.cloneTo(e), e;
            }
        }, {
            key: "type",
            get: function get() {
                return this._type;
            }
        }, {
            key: "constant",
            get: function get() {
                return this._constant;
            }
        }, {
            key: "gradientX",
            get: function get() {
                return this._gradientX;
            }
        }, {
            key: "gradientY",
            get: function get() {
                return this._gradientY;
            }
        }, {
            key: "gradientZ",
            get: function get() {
                return this._gradientZ;
            }
        }, {
            key: "constantMin",
            get: function get() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function get() {
                return this._constantMax;
            }
        }, {
            key: "gradientXMin",
            get: function get() {
                return this._gradientXMin;
            }
        }, {
            key: "gradientXMax",
            get: function get() {
                return this._gradientXMax;
            }
        }, {
            key: "gradientYMin",
            get: function get() {
                return this._gradientYMin;
            }
        }, {
            key: "gradientYMax",
            get: function get() {
                return this._gradientYMax;
            }
        }, {
            key: "gradientZMin",
            get: function get() {
                return this._gradientZMin;
            }
        }, {
            key: "gradientZMax",
            get: function get() {
                return this._gradientZMax;
            }
        }], [{
            key: "createByConstant",
            value: function createByConstant(e) {
                var t = new Ct();
                return t._type = 0, t._constant = e, t;
            }
        }, {
            key: "createByGradient",
            value: function createByGradient(e, t, r) {
                var i = new Ct();
                return i._type = 1, i._gradientX = e, i._gradientY = t, i._gradientZ = r, i;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function createByRandomTwoConstant(e, t) {
                var r = new Ct();
                return r._type = 2, r._constantMin = e, r._constantMax = t, r;
            }
        }, {
            key: "createByRandomTwoGradient",
            value: function createByRandomTwoGradient(e, t, r, i, a, n) {
                var s = new Ct();
                return s._type = 3, s._gradientXMin = e, s._gradientXMax = t, s._gradientYMin = r,
                    s._gradientYMax = i, s._gradientZMin = a, s._gradientZMax = n, s;
            }
        }]);
        return Ct;
    }();
    var Ot = /* */ function() {
        _createClass(Ot, [{
            key: "angularVelocity",
            get: function get() {
                return this._angularVelocity;
            }
        }]);

        function Ot(e) {
            _classCallCheck(this, Ot);
            this._angularVelocity = e;
        }
        _createClass(Ot, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                this._angularVelocity.cloneTo(t._angularVelocity), t.enable = this.enable;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e;
                switch (this._angularVelocity.type) {
                    case 0:
                        e = this._angularVelocity.separateAxes ? Mt.createByConstantSeparate(this._angularVelocity.constantSeparate.clone()) : Mt.createByConstant(this._angularVelocity.constant);
                        break;

                    case 1:
                        e = this._angularVelocity.separateAxes ? Mt.createByGradientSeparate(this._angularVelocity.gradientX.clone(), this._angularVelocity.gradientY.clone(), this._angularVelocity.gradientZ.clone()) : Mt.createByGradient(this._angularVelocity.gradient.clone());
                        break;

                    case 2:
                        e = this._angularVelocity.separateAxes ? Mt.createByRandomTwoConstantSeparate(this._angularVelocity.constantMinSeparate.clone(), this._angularVelocity.constantMaxSeparate.clone()) : Mt.createByRandomTwoConstant(this._angularVelocity.constantMin, this._angularVelocity.constantMax);
                        break;

                    case 3:
                        e = this._angularVelocity.separateAxes ? Mt.createByRandomTwoGradientSeparate(this._angularVelocity.gradientXMin.clone(), this._angularVelocity.gradientYMin.clone(), this._angularVelocity.gradientZMin.clone(), this._angularVelocity.gradientWMin.clone(), this._angularVelocity.gradientXMax.clone(), this._angularVelocity.gradientYMax.clone(), this._angularVelocity.gradientZMax.clone(), this._angularVelocity.gradientWMax.clone()) : Mt.createByRandomTwoGradient(this._angularVelocity.gradientMin.clone(), this._angularVelocity.gradientMax.clone());
                }
                var t = new Ot(e);
                return t.enable = this.enable, t;
            }
        }]);
        return Ot;
    }();
    var Nt = /* */ function() {
        function Nt() {
            _classCallCheck(this, Nt);
            this.enable = !0, this.randomDirection = 0;
        }
        _createClass(Nt, [{
            key: "_getShapeBoundBox",
            value: function _getShapeBoundBox(e) {
                throw new Error("BaseShape: must override it.");
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function _getSpeedBoundBox(e) {
                throw new Error("BaseShape: must override it.");
            }
        }, {
            key: "generatePositionAndDirection",
            value: function generatePositionAndDirection(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                throw new Error("BaseShape: must override it.");
            }
        }, {
            key: "_calculateProceduralBounds",
            value: function _calculateProceduralBounds(e, t, r) {
                this._getShapeBoundBox(e);
                var i = e.min,
                    a = e.max;
                n.multiply(i, t, i), n.multiply(a, t, a);
                var s = new dt(new n(), new n());
                this.randomDirection ? (s.min = new n(-1, -1, -1), s.max = new n(1, 1, 1)) : this._getSpeedBoundBox(s);
                var o = new dt(new n(), new n()),
                    l = o.min,
                    _ = o.max;
                n.scale(s.min, r.y, l), n.scale(s.max, r.y, _), n.add(e.min, l, l), n.add(e.max, _, _),
                    n.min(e.min, l, e.min), n.max(e.max, l, e.max);
                var h = new dt(new n(), new n()),
                    c = h.min,
                    d = h.max;
                n.scale(s.min, r.x, c), n.scale(s.max, r.x, d), n.min(h.min, d, l), n.max(h.min, d, _),
                    n.min(e.min, l, e.min), n.max(e.max, l, e.max);
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                e.enable = this.enable;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Nt();
                return this.cloneTo(e), e;
            }
        }]);
        return Nt;
    }();
    var Pt = /* */ function() {
        _createClass(Pt, null, [{
            key: "_randomPointUnitArcCircle",
            value: function _randomPointUnitArcCircle(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i;
                i = r ? r.getFloat() * e : Math.random() * e, t.x = Math.cos(i), t.y = Math.sin(i);
            }
        }, {
            key: "_randomPointInsideUnitArcCircle",
            value: function _randomPointInsideUnitArcCircle(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i;
                Pt._randomPointUnitArcCircle(e, t, r), i = r ? Math.pow(r.getFloat(), .5) : Math.pow(Math.random(), .5),
                    t.x = t.x * i, t.y = t.y * i;
            }
        }, {
            key: "_randomPointUnitCircle",
            value: function _randomPointUnitCircle(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var r;
                r = t ? t.getFloat() * Math.PI * 2 : Math.random() * Math.PI * 2, e.x = Math.cos(r),
                    e.y = Math.sin(r);
            }
        }, {
            key: "_randomPointInsideUnitCircle",
            value: function _randomPointInsideUnitCircle(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var r;
                Pt._randomPointUnitCircle(e), r = t ? Math.pow(t.getFloat(), .5) : Math.pow(Math.random(), .5),
                    e.x = e.x * r, e.y = e.y * r;
            }
        }, {
            key: "_randomPointUnitSphere",
            value: function _randomPointUnitSphere(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var r, i;
                t ? (r = e.z = 2 * t.getFloat() - 1, i = t.getFloat() * Math.PI * 2) : (r = e.z = 2 * Math.random() - 1,
                    i = Math.random() * Math.PI * 2);
                var a = Math.sqrt(1 - r * r);
                e.x = a * Math.cos(i), e.y = a * Math.sin(i);
            }
        }, {
            key: "_randomPointInsideUnitSphere",
            value: function _randomPointInsideUnitSphere(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var r;
                Pt._randomPointUnitSphere(e), r = t ? Math.pow(t.getFloat(), 1 / 3) : Math.pow(Math.random(), 1 / 3),
                    e.x = e.x * r, e.y = e.y * r, e.z = e.z * r;
            }
        }, {
            key: "_randomPointInsideHalfUnitBox",
            value: function _randomPointInsideHalfUnitBox(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                t ? (e.x = t.getFloat() - .5, e.y = t.getFloat() - .5, e.z = t.getFloat() - .5) : (e.x = Math.random() - .5,
                    e.y = Math.random() - .5, e.z = Math.random() - .5);
            }
        }]);

        function Pt() {
            _classCallCheck(this, Pt);
        }
        return Pt;
    }();
    var bt = /* */ function(_Nt) {
        _inherits(bt, _Nt);

        function bt() {
            var _this42;
            _classCallCheck(this, bt);
            _this42 = _possibleConstructorReturn(this, _getPrototypeOf(bt).call(this)), _this42.x = 1,
                _this42.y = 1, _this42.z = 1;
            return _this42;
        }
        _createClass(bt, [{
            key: "_getShapeBoundBox",
            value: function _getShapeBoundBox(e) {
                var t = e.min;
                t.x = .5 * -this.x, t.y = .5 * -this.y, t.z = .5 * -this.z;
                var r = e.max;
                r.x = .5 * this.x, r.y = .5 * this.y, r.z = .5 * this.z;
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function _getSpeedBoundBox(e) {
                var t = e.min;
                t.x = 0, t.y = 0, t.z = 0;
                var r = e.max;
                r.x = 0, r.y = 1, r.z = 0;
            }
        }, {
            key: "generatePositionAndDirection",
            value: function generatePositionAndDirection(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                r ? (r.seed = i[16], Pt._randomPointInsideHalfUnitBox(e, r), i[16] = r.seed) : Pt._randomPointInsideHalfUnitBox(e),
                    e.x = this.x * e.x, e.y = this.y * e.y, e.z = this.z * e.z, this.randomDirection ? r ? (r.seed = i[17],
                        Pt._randomPointUnitSphere(t, r), i[17] = r.seed) : Pt._randomPointUnitSphere(t) : (t.x = 0,
                        t.y = 0, t.z = 1);
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                _get(_getPrototypeOf(bt.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.x = this.x, t.y = this.y, t.z = this.z, t.randomDirection = this.randomDirection;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new bt();
                return this.cloneTo(e), e;
            }
        }]);
        return bt;
    }(Nt);
    var Vt = /* */ function(_Nt2) {
        _inherits(Vt, _Nt2);

        function Vt() {
            var _this43;
            _classCallCheck(this, Vt);
            _this43 = _possibleConstructorReturn(this, _getPrototypeOf(Vt).call(this)), _this43.radius = 1,
                _this43.arc = 2 * Math.PI, _this43.emitFromEdge = !1;
            return _this43;
        }
        _createClass(Vt, [{
            key: "_getShapeBoundBox",
            value: function _getShapeBoundBox(e) {
                var t = e.min;
                t.x = t.z = -this.radius, t.y = 0;
                var r = e.max;
                r.x = r.z = this.radius, r.y = 0;
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function _getSpeedBoundBox(e) {
                var t = e.min;
                t.x = t.y = -1, t.z = 0;
                var r = e.max;
                r.x = r.y = 1, r.z = 0;
            }
        }, {
            key: "generatePositionAndDirection",
            value: function generatePositionAndDirection(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                var a = Vt._tempPositionPoint;
                r ? (r.seed = i[16], this.emitFromEdge ? Pt._randomPointUnitArcCircle(this.arc, Vt._tempPositionPoint, r) : Pt._randomPointInsideUnitArcCircle(this.arc, Vt._tempPositionPoint, r),
                        i[16] = r.seed) : this.emitFromEdge ? Pt._randomPointUnitArcCircle(this.arc, Vt._tempPositionPoint) : Pt._randomPointInsideUnitArcCircle(this.arc, Vt._tempPositionPoint),
                    e.x = -a.x, e.y = a.y, e.z = 0, n.scale(e, this.radius, e), this.randomDirection ? r ? (r.seed = i[17],
                        Pt._randomPointUnitSphere(t, r), i[17] = r.seed) : Pt._randomPointUnitSphere(t) : e.cloneTo(t);
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                _get(_getPrototypeOf(Vt.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.radius = this.radius, t.arc = this.arc, t.emitFromEdge = this.emitFromEdge, t.randomDirection = this.randomDirection;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Vt();
                return this.cloneTo(e), e;
            }
        }]);
        return Vt;
    }(Nt);
    Vt._tempPositionPoint = new i();
    var wt = /* */ function(_Nt3) {
        _inherits(wt, _Nt3);

        function wt() {
            var _this44;
            _classCallCheck(this, wt);
            _this44 = _possibleConstructorReturn(this, _getPrototypeOf(wt).call(this)), _this44.angle = 25 / 180 * Math.PI,
                _this44.radius = 1, _this44.length = 5, _this44.emitType = 0;
            return _this44;
        }
        _createClass(wt, [{
            key: "_getShapeBoundBox",
            value: function _getShapeBoundBox(e) {
                var t = this.radius + this.length * Math.sin(this.angle),
                    r = this.length * Math.cos(this.angle);
                var i = e.min;
                i.x = i.y = -t, i.z = 0;
                var a = e.max;
                a.x = a.y = t, a.z = r;
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function _getSpeedBoundBox(e) {
                var t = Math.sin(this.angle);
                var r = e.min;
                r.x = r.y = -t, r.z = 0;
                var i = e.max;
                i.x = i.y = t, i.z = 1;
            }
        }, {
            key: "generatePositionAndDirection",
            value: function generatePositionAndDirection(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                var a, s, o, l = wt._tempPositionPoint,
                    _ = Math.cos(this.angle),
                    h = Math.sin(this.angle);
                switch (this.emitType) {
                    case 0:
                        r ? (r.seed = i[16], Pt._randomPointInsideUnitCircle(wt._tempPositionPoint, r),
                                i[16] = r.seed) : Pt._randomPointInsideUnitCircle(wt._tempPositionPoint), a = l.x,
                            s = l.y, e.x = a * this.radius, e.y = s * this.radius, e.z = 0, this.randomDirection ? (r ? (r.seed = i[17],
                                    Pt._randomPointInsideUnitCircle(wt._tempDirectionPoint, r), i[17] = r.seed) : Pt._randomPointInsideUnitCircle(wt._tempDirectionPoint),
                                o = wt._tempDirectionPoint, t.x = o.x * h, t.y = o.y * h) : (t.x = a * h, t.y = s * h),
                            t.z = _;
                        break;

                    case 1:
                        r ? (r.seed = i[16], Pt._randomPointUnitCircle(wt._tempPositionPoint, r), i[16] = r.seed) : Pt._randomPointUnitCircle(wt._tempPositionPoint),
                            a = l.x, s = l.y, e.x = a * this.radius, e.y = s * this.radius, e.z = 0, this.randomDirection ? (r ? (r.seed = i[17],
                                    Pt._randomPointInsideUnitCircle(wt._tempDirectionPoint, r), i[17] = r.seed) : Pt._randomPointInsideUnitCircle(wt._tempDirectionPoint),
                                o = wt._tempDirectionPoint, t.x = o.x * h, t.y = o.y * h) : (t.x = a * h, t.y = s * h),
                            t.z = _;
                        break;

                    case 2:
                        r ? (r.seed = i[16], Pt._randomPointInsideUnitCircle(wt._tempPositionPoint, r)) : Pt._randomPointInsideUnitCircle(wt._tempPositionPoint),
                            a = l.x, s = l.y, e.x = a * this.radius, e.y = s * this.radius, e.z = 0, t.x = a * h,
                            t.y = s * h, t.z = _, n.normalize(t, t), r ? (n.scale(t, this.length * r.getFloat(), t),
                                i[16] = r.seed) : n.scale(t, this.length * Math.random(), t), n.add(e, t, e), this.randomDirection && (r ? (r.seed = i[17],
                                Pt._randomPointUnitSphere(t, r), i[17] = r.seed) : Pt._randomPointUnitSphere(t));
                        break;

                    case 3:
                        r ? (r.seed = i[16], Pt._randomPointUnitCircle(wt._tempPositionPoint, r)) : Pt._randomPointUnitCircle(wt._tempPositionPoint),
                            a = l.x, s = l.y, e.x = a * this.radius, e.y = s * this.radius, e.z = 0, t.x = a * h,
                            t.y = s * h, t.z = _, n.normalize(t, t), r ? (n.scale(t, this.length * r.getFloat(), t),
                                i[16] = r.seed) : n.scale(t, this.length * Math.random(), t), n.add(e, t, e), this.randomDirection && (r ? (r.seed = i[17],
                                Pt._randomPointUnitSphere(t, r), i[17] = r.seed) : Pt._randomPointUnitSphere(t));
                        break;

                    default:
                        throw new Error("ConeShape:emitType is invalid.");
                }
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                _get(_getPrototypeOf(wt.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.angle = this.angle, t.radius = this.radius, t.length = this.length, t.emitType = this.emitType,
                    t.randomDirection = this.randomDirection;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new wt();
                return this.cloneTo(e), e;
            }
        }]);
        return wt;
    }(Nt);
    wt._tempPositionPoint = new i(), wt._tempDirectionPoint = new i();
    var Ft = /* */ function(_Nt4) {
        _inherits(Ft, _Nt4);

        function Ft() {
            var _this45;
            _classCallCheck(this, Ft);
            _this45 = _possibleConstructorReturn(this, _getPrototypeOf(Ft).call(this)), _this45.radius = 1,
                _this45.emitFromShell = !1;
            return _this45;
        }
        _createClass(Ft, [{
            key: "_getShapeBoundBox",
            value: function _getShapeBoundBox(e) {
                var t = e.min;
                t.x = t.y = t.z = -this.radius;
                var r = e.max;
                r.x = r.y = this.radius, r.z = 0;
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function _getSpeedBoundBox(e) {
                var t = e.min;
                t.x = t.y = -1, t.z = 0;
                var r = e.max;
                r.x = r.y = r.z = 1;
            }
        }, {
            key: "generatePositionAndDirection",
            value: function generatePositionAndDirection(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                r ? (r.seed = i[16], this.emitFromShell ? Pt._randomPointUnitSphere(e, r) : Pt._randomPointInsideUnitSphere(e, r),
                        i[16] = r.seed) : this.emitFromShell ? Pt._randomPointUnitSphere(e) : Pt._randomPointInsideUnitSphere(e),
                    n.scale(e, this.radius, e);
                var a = e.z;
                a < 0 && (e.z = -1 * a), this.randomDirection ? r ? (r.seed = i[17], Pt._randomPointUnitSphere(t, r),
                    i[17] = r.seed) : Pt._randomPointUnitSphere(t) : e.cloneTo(t);
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                _get(_getPrototypeOf(Ft.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.radius = this.radius, t.emitFromShell = this.emitFromShell, t.randomDirection = this.randomDirection;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Ft();
                return this.cloneTo(e), e;
            }
        }]);
        return Ft;
    }(Nt);
    var Bt = /* */ function(_Nt5) {
        _inherits(Bt, _Nt5);

        function Bt() {
            var _this46;
            _classCallCheck(this, Bt);
            _this46 = _possibleConstructorReturn(this, _getPrototypeOf(Bt).call(this)), _this46.radius = 1,
                _this46.emitFromShell = !1;
            return _this46;
        }
        _createClass(Bt, [{
            key: "_getShapeBoundBox",
            value: function _getShapeBoundBox(e) {
                var t = e.min;
                t.x = t.y = t.z = -this.radius;
                var r = e.max;
                r.x = r.y = r.z = this.radius;
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function _getSpeedBoundBox(e) {
                var t = e.min;
                t.x = t.y = t.z = -1;
                var r = e.max;
                r.x = r.y = r.z = 1;
            }
        }, {
            key: "generatePositionAndDirection",
            value: function generatePositionAndDirection(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                r ? (r.seed = i[16], this.emitFromShell ? Pt._randomPointUnitSphere(e, r) : Pt._randomPointInsideUnitSphere(e, r),
                        i[16] = r.seed) : this.emitFromShell ? Pt._randomPointUnitSphere(e) : Pt._randomPointInsideUnitSphere(e),
                    n.scale(e, this.radius, e), this.randomDirection ? r ? (r.seed = i[17], Pt._randomPointUnitSphere(t, r),
                        i[17] = r.seed) : Pt._randomPointUnitSphere(t) : e.cloneTo(t);
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                _get(_getPrototypeOf(Bt.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.radius = this.radius, t.emitFromShell = this.emitFromShell, t.randomDirection = this.randomDirection;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Bt();
                return this.cloneTo(e), e;
            }
        }]);
        return Bt;
    }(Nt);
    var Ut = /* */ function() {
        _createClass(Ut, [{
            key: "size",
            get: function get() {
                return this._size;
            }
        }]);

        function Ut(e) {
            _classCallCheck(this, Ut);
            this._size = e;
        }
        _createClass(Ut, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                this._size.cloneTo(t._size), t.enable = this.enable;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e;
                switch (this._size.type) {
                    case 0:
                        e = this._size.separateAxes ? yt.createByGradientSeparate(this._size.gradientX.clone(), this._size.gradientY.clone(), this._size.gradientZ.clone()) : yt.createByGradient(this._size.gradient.clone());
                        break;

                    case 1:
                        e = this._size.separateAxes ? yt.createByRandomTwoConstantSeparate(this._size.constantMinSeparate.clone(), this._size.constantMaxSeparate.clone()) : yt.createByRandomTwoConstant(this._size.constantMin, this._size.constantMax);
                        break;

                    case 2:
                        e = this._size.separateAxes ? yt.createByRandomTwoGradientSeparate(this._size.gradientXMin.clone(), this._size.gradientYMin.clone(), this._size.gradientZMin.clone(), this._size.gradientXMax.clone(), this._size.gradientYMax.clone(), this._size.gradientZMax.clone()) : yt.createByRandomTwoGradient(this._size.gradientMin.clone(), this._size.gradientMax.clone());
                }
                var t = new Ut(e);
                return t.enable = this.enable, t;
            }
        }]);
        return Ut;
    }();
    var Gt = /* */ function() {
        function Gt() {
            _classCallCheck(this, Gt);
            this._type = 0, this._constant = 0, this._constantMin = 0, this._constantMax = 0;
        }
        _createClass(Gt, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t._type = this._type, t._constant = this._constant, t._constantMin = this._constantMin,
                    t._constantMax = this._constantMax;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Gt();
                return this.cloneTo(e), e;
            }
        }, {
            key: "type",
            get: function get() {
                return this._type;
            }
        }, {
            key: "constant",
            get: function get() {
                return this._constant;
            }
        }, {
            key: "constantMin",
            get: function get() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function get() {
                return this._constantMax;
            }
        }], [{
            key: "createByConstant",
            value: function createByConstant() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var t = new Gt();
                return t._type = 0, t._constant = e, t;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function createByRandomTwoConstant() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var r = new Gt();
                return r._type = 1, r._constantMin = e, r._constantMax = t, r;
            }
        }]);
        return Gt;
    }();
    var zt = /* */ function() {
        function zt(e, t) {
            _classCallCheck(this, zt);
            this.type = 0, this.randomRow = !1, this.rowIndex = 0, this.cycles = 0, this.enableUVChannels = 0,
                this.enable = !1, this.tiles = new i(1, 1), this.type = 0, this.randomRow = !0,
                this.rowIndex = 0, this.cycles = 1, this.enableUVChannels = 1, this._frame = e,
                this._startFrame = t;
        }
        _createClass(zt, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                this.tiles.cloneTo(t.tiles), t.type = this.type, t.randomRow = this.randomRow, t.rowIndex = this.rowIndex,
                    t.cycles = this.cycles, t.enableUVChannels = this.enableUVChannels, t.enable = this.enable,
                    this._frame.cloneTo(t._frame), this._startFrame.cloneTo(t._startFrame);
            }
        }, {
            key: "clone",
            value: function clone() {
                var e, t;
                switch (this._frame.type) {
                    case 0:
                        e = At.createByConstant(this._frame.constant);
                        break;

                    case 1:
                        e = At.createByOverTime(this._frame.frameOverTimeData.clone());
                        break;

                    case 2:
                        e = At.createByRandomTwoConstant(this._frame.constantMin, this._frame.constantMax);
                        break;

                    case 3:
                        e = At.createByRandomTwoOverTime(this._frame.frameOverTimeDataMin.clone(), this._frame.frameOverTimeDataMax.clone());
                }
                switch (this._startFrame.type) {
                    case 0:
                        t = Gt.createByConstant(this._startFrame.constant);
                        break;

                    case 1:
                        t = Gt.createByRandomTwoConstant(this._startFrame.constantMin, this._startFrame.constantMax);
                }
                var r = new zt(e, t);
                return this.cloneTo(r), r;
            }
        }, {
            key: "frame",
            get: function get() {
                return this._frame;
            }
        }, {
            key: "startFrame",
            get: function get() {
                return this._startFrame;
            }
        }]);
        return zt;
    }();
    var Ht = /* */ function() {
        function Ht(e) {
            _classCallCheck(this, Ht);
            this.enable = !1, this.space = 0, this._velocity = e;
        }
        _createClass(Ht, [{
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                this._velocity.cloneTo(t._velocity), t.enable = this.enable, t.space = this.space;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e;
                switch (this._velocity.type) {
                    case 0:
                        e = Ct.createByConstant(this._velocity.constant.clone());
                        break;

                    case 1:
                        e = Ct.createByGradient(this._velocity.gradientX.clone(), this._velocity.gradientY.clone(), this._velocity.gradientZ.clone());
                        break;

                    case 2:
                        e = Ct.createByRandomTwoConstant(this._velocity.constantMin.clone(), this._velocity.constantMax.clone());
                        break;

                    case 3:
                        e = Ct.createByRandomTwoGradient(this._velocity.gradientXMin.clone(), this._velocity.gradientYMin.clone(), this._velocity.gradientZMin.clone(), this._velocity.gradientXMax.clone(), this._velocity.gradientYMax.clone(), this._velocity.gradientZMax.clone());
                }
                var t = new Ht(e);
                return t.enable = this.enable, t.space = this.space, t;
            }
        }, {
            key: "velocity",
            get: function get() {
                return this._velocity;
            }
        }]);
        return Ht;
    }();
    var kt = function kt() {
        _classCallCheck(this, kt);
    };
    kt.WORLDPOSITION = H.propertyNameToID("u_WorldPosition"), kt.WORLDROTATION = H.propertyNameToID("u_WorldRotation"),
        kt.POSITIONSCALE = H.propertyNameToID("u_PositionScale"), kt.SIZESCALE = H.propertyNameToID("u_SizeScale"),
        kt.SCALINGMODE = H.propertyNameToID("u_ScalingMode"), kt.GRAVITY = H.propertyNameToID("u_Gravity"),
        kt.THREEDSTARTROTATION = H.propertyNameToID("u_ThreeDStartRotation"), kt.STRETCHEDBILLBOARDLENGTHSCALE = H.propertyNameToID("u_StretchedBillboardLengthScale"),
        kt.STRETCHEDBILLBOARDSPEEDSCALE = H.propertyNameToID("u_StretchedBillboardSpeedScale"),
        kt.SIMULATIONSPACE = H.propertyNameToID("u_SimulationSpace"), kt.CURRENTTIME = H.propertyNameToID("u_CurrentTime"),
        kt.VOLVELOCITYCONST = H.propertyNameToID("u_VOLVelocityConst"), kt.VOLVELOCITYGRADIENTX = H.propertyNameToID("u_VOLVelocityGradientX"),
        kt.VOLVELOCITYGRADIENTY = H.propertyNameToID("u_VOLVelocityGradientY"), kt.VOLVELOCITYGRADIENTZ = H.propertyNameToID("u_VOLVelocityGradientZ"),
        kt.VOLVELOCITYCONSTMAX = H.propertyNameToID("u_VOLVelocityConstMax"), kt.VOLVELOCITYGRADIENTXMAX = H.propertyNameToID("u_VOLVelocityGradientMaxX"),
        kt.VOLVELOCITYGRADIENTYMAX = H.propertyNameToID("u_VOLVelocityGradientMaxY"), kt.VOLVELOCITYGRADIENTZMAX = H.propertyNameToID("u_VOLVelocityGradientMaxZ"),
        kt.VOLSPACETYPE = H.propertyNameToID("u_VOLSpaceType"), kt.COLOROVERLIFEGRADIENTALPHAS = H.propertyNameToID("u_ColorOverLifeGradientAlphas"),
        kt.COLOROVERLIFEGRADIENTCOLORS = H.propertyNameToID("u_ColorOverLifeGradientColors"),
        kt.MAXCOLOROVERLIFEGRADIENTALPHAS = H.propertyNameToID("u_MaxColorOverLifeGradientAlphas"),
        kt.MAXCOLOROVERLIFEGRADIENTCOLORS = H.propertyNameToID("u_MaxColorOverLifeGradientColors"),
        kt.SOLSIZEGRADIENT = H.propertyNameToID("u_SOLSizeGradient"), kt.SOLSIZEGRADIENTX = H.propertyNameToID("u_SOLSizeGradientX"),
        kt.SOLSIZEGRADIENTY = H.propertyNameToID("u_SOLSizeGradientY"), kt.SOLSizeGradientZ = H.propertyNameToID("u_SOLSizeGradientZ"),
        kt.SOLSizeGradientMax = H.propertyNameToID("u_SOLSizeGradientMax"), kt.SOLSIZEGRADIENTXMAX = H.propertyNameToID("u_SOLSizeGradientMaxX"),
        kt.SOLSIZEGRADIENTYMAX = H.propertyNameToID("u_SOLSizeGradientMaxY"), kt.SOLSizeGradientZMAX = H.propertyNameToID("u_SOLSizeGradientMaxZ"),
        kt.ROLANGULARVELOCITYCONST = H.propertyNameToID("u_ROLAngularVelocityConst"), kt.ROLANGULARVELOCITYCONSTSEPRARATE = H.propertyNameToID("u_ROLAngularVelocityConstSeprarate"),
        kt.ROLANGULARVELOCITYGRADIENT = H.propertyNameToID("u_ROLAngularVelocityGradient"),
        kt.ROLANGULARVELOCITYGRADIENTX = H.propertyNameToID("u_ROLAngularVelocityGradientX"),
        kt.ROLANGULARVELOCITYGRADIENTY = H.propertyNameToID("u_ROLAngularVelocityGradientY"),
        kt.ROLANGULARVELOCITYGRADIENTZ = H.propertyNameToID("u_ROLAngularVelocityGradientZ"),
        kt.ROLANGULARVELOCITYCONSTMAX = H.propertyNameToID("u_ROLAngularVelocityConstMax"),
        kt.ROLANGULARVELOCITYCONSTMAXSEPRARATE = H.propertyNameToID("u_ROLAngularVelocityConstMaxSeprarate"),
        kt.ROLANGULARVELOCITYGRADIENTMAX = H.propertyNameToID("u_ROLAngularVelocityGradientMax"),
        kt.ROLANGULARVELOCITYGRADIENTXMAX = H.propertyNameToID("u_ROLAngularVelocityGradientMaxX"),
        kt.ROLANGULARVELOCITYGRADIENTYMAX = H.propertyNameToID("u_ROLAngularVelocityGradientMaxY"),
        kt.ROLANGULARVELOCITYGRADIENTZMAX = H.propertyNameToID("u_ROLAngularVelocityGradientMaxZ"),
        kt.ROLANGULARVELOCITYGRADIENTWMAX = H.propertyNameToID("u_ROLAngularVelocityGradientMaxW"),
        kt.TEXTURESHEETANIMATIONCYCLES = H.propertyNameToID("u_TSACycles"), kt.TEXTURESHEETANIMATIONSUBUVLENGTH = H.propertyNameToID("u_TSASubUVLength"),
        kt.TEXTURESHEETANIMATIONGRADIENTUVS = H.propertyNameToID("u_TSAGradientUVs"), kt.TEXTURESHEETANIMATIONGRADIENTMAXUVS = H.propertyNameToID("u_TSAMaxGradientUVs");
    var Wt = /* */ function(_j9) {
        _inherits(Wt, _j9);

        function Wt() {
            var _this47;
            _classCallCheck(this, Wt);
            _this47 = _possibleConstructorReturn(this, _getPrototypeOf(Wt).call(this)), _this47.setShaderName("PARTICLESHURIKEN"),
                _this47._color = new a(1, 1, 1, 1), _this47.renderMode = Wt.RENDERMODE_ALPHABLENDED;
            return _this47;
        }
        _createClass(Wt, [{
            key: "clone",
            value: function clone() {
                var e = new Wt();
                return this.cloneTo(e), e;
            }
        }, {
            key: "_TintColorR",
            get: function get() {
                return this._color.x;
            },
            set: function set(e) {
                this._color.x = e, this.color = this._color;
            }
        }, {
            key: "_TintColorG",
            get: function get() {
                return this._color.y;
            },
            set: function set(e) {
                this._color.y = e, this.color = this._color;
            }
        }, {
            key: "_TintColorB",
            get: function get() {
                return this._color.z;
            },
            set: function set(e) {
                this._color.z = e, this.color = this._color;
            }
        }, {
            key: "_TintColorA",
            get: function get() {
                return this._color.w;
            },
            set: function set(e) {
                this._color.w = e, this.color = this._color;
            }
        }, {
            key: "_MainTex_STX",
            get: function get() {
                return this._shaderValues.getVector(Wt.TILINGOFFSET).x;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(Wt.TILINGOFFSET);
                t.x = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function get() {
                return this._shaderValues.getVector(Wt.TILINGOFFSET).y;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(Wt.TILINGOFFSET);
                t.y = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function get() {
                return this._shaderValues.getVector(Wt.TILINGOFFSET).z;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(Wt.TILINGOFFSET);
                t.z = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function get() {
                return this._shaderValues.getVector(Wt.TILINGOFFSET).w;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(Wt.TILINGOFFSET);
                t.w = e, this.tilingOffset = t;
            }
        }, {
            key: "renderMode",
            set: function set(e) {
                switch (e) {
                    case Wt.RENDERMODE_ADDTIVE:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.depthWrite = !1, this.cull = Q.CULL_NONE,
                            this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA, this.blendDst = Q.BLENDPARAM_ONE,
                            this.alphaTest = !1, this._shaderValues.addDefine(Wt.SHADERDEFINE_ADDTIVEFOG);
                        break;

                    case Wt.RENDERMODE_ALPHABLENDED:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.depthWrite = !1, this.cull = Q.CULL_NONE,
                            this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA, this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA,
                            this.alphaTest = !1, this._shaderValues.removeDefine(Wt.SHADERDEFINE_ADDTIVEFOG);
                        break;

                    default:
                        throw new Error("ShurikenParticleMaterial : renderMode value error.");
                }
            }
        }, {
            key: "colorR",
            get: function get() {
                return this._TintColorR;
            },
            set: function set(e) {
                this._TintColorR = e;
            }
        }, {
            key: "colorG",
            get: function get() {
                return this._TintColorG;
            },
            set: function set(e) {
                this._TintColorG = e;
            }
        }, {
            key: "colorB",
            get: function get() {
                return this._TintColorB;
            },
            set: function set(e) {
                this._TintColorB = e;
            }
        }, {
            key: "colorA",
            get: function get() {
                return this._TintColorA;
            },
            set: function set(e) {
                this._TintColorA = e;
            }
        }, {
            key: "color",
            get: function get() {
                return this._shaderValues.getVector(Wt.TINTCOLOR);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(Wt.SHADERDEFINE_TINTCOLOR) : this._shaderValues.removeDefine(Wt.SHADERDEFINE_TINTCOLOR),
                    this._shaderValues.setVector(Wt.TINTCOLOR, e);
            }
        }, {
            key: "tilingOffsetX",
            get: function get() {
                return this._MainTex_STX;
            },
            set: function set(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function get() {
                return this._MainTex_STY;
            },
            set: function set(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function get() {
                return this._MainTex_STZ;
            },
            set: function set(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function get() {
                return this._MainTex_STW;
            },
            set: function set(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function get() {
                return this._shaderValues.getVector(Wt.TILINGOFFSET);
            },
            set: function set(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(Wt.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(Wt.SHADERDEFINE_TILINGOFFSET),
                    this._shaderValues.setVector(Wt.TILINGOFFSET, e);
            }
        }, {
            key: "texture",
            get: function get() {
                return this._shaderValues.getTexture(Wt.DIFFUSETEXTURE);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(Wt.SHADERDEFINE_DIFFUSEMAP) : this._shaderValues.removeDefine(Wt.SHADERDEFINE_DIFFUSEMAP),
                    this._shaderValues.setTexture(Wt.DIFFUSETEXTURE, e);
            }
        }, {
            key: "depthWrite",
            get: function get() {
                return this._shaderValues.getBool(Wt.DEPTH_WRITE);
            },
            set: function set(e) {
                this._shaderValues.setBool(Wt.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function get() {
                return this._shaderValues.getInt(Wt.CULL);
            },
            set: function set(e) {
                this._shaderValues.setInt(Wt.CULL, e);
            }
        }, {
            key: "blend",
            get: function get() {
                return this._shaderValues.getInt(Wt.BLEND);
            },
            set: function set(e) {
                this._shaderValues.setInt(Wt.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function get() {
                return this._shaderValues.getInt(Wt.BLEND_SRC);
            },
            set: function set(e) {
                this._shaderValues.setInt(Wt.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function get() {
                return this._shaderValues.getInt(Wt.BLEND_DST);
            },
            set: function set(e) {
                this._shaderValues.setInt(Wt.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function get() {
                return this._shaderValues.getInt(Wt.DEPTH_TEST);
            },
            set: function set(e) {
                this._shaderValues.setInt(Wt.DEPTH_TEST, e);
            }
        }], [{
            key: "__initDefine__",
            value: function __initDefine__() {
                Wt.SHADERDEFINE_DIFFUSEMAP = H.getDefineByName("DIFFUSEMAP"), Wt.SHADERDEFINE_TINTCOLOR = H.getDefineByName("TINTCOLOR"),
                    Wt.SHADERDEFINE_ADDTIVEFOG = H.getDefineByName("ADDTIVEFOG"), Wt.SHADERDEFINE_TILINGOFFSET = H.getDefineByName("TILINGOFFSET");
            }
        }]);
        return Wt;
    }(j);
    Wt.RENDERMODE_ALPHABLENDED = 0, Wt.RENDERMODE_ADDTIVE = 1, Wt.DIFFUSETEXTURE = H.propertyNameToID("u_texture"),
        Wt.TINTCOLOR = H.propertyNameToID("u_Tintcolor"), Wt.TILINGOFFSET = H.propertyNameToID("u_TilingOffset"),
        Wt.CULL = H.propertyNameToID("s_Cull"), Wt.BLEND = H.propertyNameToID("s_Blend"),
        Wt.BLEND_SRC = H.propertyNameToID("s_BlendSrc"), Wt.BLEND_DST = H.propertyNameToID("s_BlendDst"),
        Wt.DEPTH_TEST = H.propertyNameToID("s_DepthTest"), Wt.DEPTH_WRITE = H.propertyNameToID("s_DepthWrite");
    var Xt = /* */ function() {
        function Xt() {
            _classCallCheck(this, Xt);
        }
        _createClass(Xt, null, [{
            key: "setColliderCollision",
            value: function setColliderCollision(e, t, r) {}
        }, {
            key: "getIColliderCollision",
            value: function getIColliderCollision(e, t) {
                return !1;
            }
        }]);
        return Xt;
    }();
    Xt.COLLISIONFILTERGROUP_DEFAULTFILTER = 1, Xt.COLLISIONFILTERGROUP_STATICFILTER = 2,
        Xt.COLLISIONFILTERGROUP_KINEMATICFILTER = 4, Xt.COLLISIONFILTERGROUP_DEBRISFILTER = 8,
        Xt.COLLISIONFILTERGROUP_SENSORTRIGGER = 16, Xt.COLLISIONFILTERGROUP_CHARACTERFILTER = 32,
        Xt.COLLISIONFILTERGROUP_CUSTOMFILTER1 = 64, Xt.COLLISIONFILTERGROUP_CUSTOMFILTER2 = 128,
        Xt.COLLISIONFILTERGROUP_CUSTOMFILTER3 = 256, Xt.COLLISIONFILTERGROUP_CUSTOMFILTER4 = 512,
        Xt.COLLISIONFILTERGROUP_CUSTOMFILTER5 = 1024, Xt.COLLISIONFILTERGROUP_CUSTOMFILTER6 = 2048,
        Xt.COLLISIONFILTERGROUP_CUSTOMFILTER7 = 4096, Xt.COLLISIONFILTERGROUP_CUSTOMFILTER8 = 8192,
        Xt.COLLISIONFILTERGROUP_CUSTOMFILTER9 = 16384, Xt.COLLISIONFILTERGROUP_CUSTOMFILTER10 = 32768,
        Xt.COLLISIONFILTERGROUP_ALLFILTER = -1, Xt.gravity = new n(0, -9.81, 0);
    var Yt = /* */ function(_mt2) {
        _inherits(Yt, _mt2);

        function Yt(e) {
            var _this48;
            _classCallCheck(this, Yt);
            _this48 = _possibleConstructorReturn(this, _getPrototypeOf(Yt).call(this, e)), _this48._finalGravity = new n(),
                _this48._tempRotationMatrix = new C(), _this48._mesh = null, _this48.stretchedBillboardCameraSpeedScale = 0,
                _this48.stretchedBillboardSpeedScale = 0, _this48.stretchedBillboardLengthScale = 2,
                _this48._defaultBoundBox = new dt(new n(), new n()), _this48.renderMode = 0, _this48._supportOctree = !1;
            return _this48;
        }
        _createClass(Yt, [{
            key: "_calculateBoundingBox",
            value: function _calculateBoundingBox() {
                if ((e = this._bounds.getMin()).x = -Number.MAX_VALUE, e.y = -Number.MAX_VALUE,
                    e.z = -Number.MAX_VALUE, this._bounds.setMin(e), (r = this._bounds.getMax()).x = Number.MAX_VALUE,
                    r.y = Number.MAX_VALUE, r.z = Number.MAX_VALUE, this._bounds.setMax(r), t.Render.supportWebGLPlusCulling) {
                    var e = this._bounds.getMin(),
                        r = this._bounds.getMax(),
                        i = Oe._cullingBuffer;
                    i[this._cullingBufferIndex + 1] = e.x, i[this._cullingBufferIndex + 2] = e.y, i[this._cullingBufferIndex + 3] = e.z,
                        i[this._cullingBufferIndex + 4] = r.x, i[this._cullingBufferIndex + 5] = r.y, i[this._cullingBufferIndex + 6] = r.z;
                }
            }
        }, {
            key: "_needRender",
            value: function _needRender(e, t) {
                return !e || !!e.intersects(this.bounds._getBoundBox()) && !!this._owner.particleSystem.isAlive;
            }
        }, {
            key: "_renderUpdate",
            value: function _renderUpdate(e, t) {
                var r = this._owner.particleSystem,
                    i = this._shaderValues,
                    a = this._owner.transform;
                switch (r.simulationSpace) {
                    case 0:
                        break;

                    case 1:
                        i.setVector3(kt.WORLDPOSITION, a.position), i.setQuaternion(kt.WORLDROTATION, a.rotation);
                        break;

                    default:
                        throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                }
                switch (r.scaleMode) {
                    case 0:
                        var s = a.getWorldLossyScale();
                        i.setVector3(kt.POSITIONSCALE, s), i.setVector3(kt.SIZESCALE, s);
                        break;

                    case 1:
                        var o = a.localScale;
                        i.setVector3(kt.POSITIONSCALE, o), i.setVector3(kt.SIZESCALE, o);
                        break;

                    case 2:
                        i.setVector3(kt.POSITIONSCALE, a.getWorldLossyScale()), i.setVector3(kt.SIZESCALE, n._ONE);
                }
                n.scale(Xt.gravity, r.gravityModifier, this._finalGravity), i.setVector3(kt.GRAVITY, this._finalGravity),
                    i.setInt(kt.SIMULATIONSPACE, r.simulationSpace), i.setBool(kt.THREEDSTARTROTATION, r.threeDStartRotation),
                    i.setInt(kt.SCALINGMODE, r.scaleMode), i.setNumber(kt.STRETCHEDBILLBOARDLENGTHSCALE, this.stretchedBillboardLengthScale),
                    i.setNumber(kt.STRETCHEDBILLBOARDSPEEDSCALE, this.stretchedBillboardSpeedScale),
                    i.setNumber(kt.CURRENTTIME, r._currentTime);
            }
        }, {
            key: "_destroy",
            value: function _destroy() {
                _get(_getPrototypeOf(Yt.prototype), "_destroy", this).call(this), this._mesh && (this._mesh._removeReference(),
                    this._mesh = null);
            }
        }, {
            key: "renderMode",
            get: function get() {
                return this._renderMode;
            },
            set: function set(e) {
                if (this._renderMode !== e) {
                    var t = this._shaderValues;
                    switch (this._renderMode) {
                        case 0:
                            t.removeDefine(kt.SHADERDEFINE_RENDERMODE_BILLBOARD);
                            break;

                        case 1:
                            t.removeDefine(kt.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                            break;

                        case 2:
                            t.removeDefine(kt.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                            break;

                        case 3:
                            t.removeDefine(kt.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                            break;

                        case 4:
                            t.removeDefine(kt.SHADERDEFINE_RENDERMODE_MESH);
                    }
                    switch (this._renderMode = e, e) {
                        case 0:
                            t.addDefine(kt.SHADERDEFINE_RENDERMODE_BILLBOARD);
                            break;

                        case 1:
                            t.addDefine(kt.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                            break;

                        case 2:
                            t.addDefine(kt.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                            break;

                        case 3:
                            t.addDefine(kt.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                            break;

                        case 4:
                            t.addDefine(kt.SHADERDEFINE_RENDERMODE_MESH);
                            break;

                        default:
                            throw new Error("ShurikenParticleRender: unknown renderMode Value.");
                    }
                    var r = this._owner.particleSystem;
                    r && r._initBufferDatas();
                }
            }
        }, {
            key: "mesh",
            get: function get() {
                return this._mesh;
            },
            set: function set(e) {
                this._mesh !== e && (this._mesh && this._mesh._removeReference(), this._mesh = e,
                    e && e._addReference(), this._owner.particleSystem._initBufferDatas());
            }
        }, {
            key: "bounds",
            get: function get() {
                return this._boundsChange && (this._calculateBoundingBox(), this._boundsChange = !1),
                    this._bounds;
            }
        }]);
        return Yt;
    }(mt);
    var Zt = function Zt() {
        _classCallCheck(this, Zt);
    };
    Zt.PARTICLE_CORNERTEXTURECOORDINATE0 = 0, Zt.PARTICLE_POSITION0 = 1, Zt.PARTICLE_COLOR0 = 2,
        Zt.PARTICLE_TEXTURECOORDINATE0 = 3, Zt.PARTICLE_SHAPEPOSITIONSTARTLIFETIME = 4,
        Zt.PARTICLE_DIRECTIONTIME = 5, Zt.PARTICLE_STARTCOLOR0 = 6, Zt.PARTICLE_ENDCOLOR0 = 7,
        Zt.PARTICLE_STARTSIZE = 8, Zt.PARTICLE_STARTROTATION = 9, Zt.PARTICLE_STARTSPEED = 10,
        Zt.PARTICLE_RANDOM0 = 11, Zt.PARTICLE_RANDOM1 = 12, Zt.PARTICLE_SIMULATIONWORLDPOSTION = 13,
        Zt.PARTICLE_SIMULATIONWORLDROTATION = 14;
    var jt = /* */ function(_Zt) {
        _inherits(jt, _Zt);
        _createClass(jt, [{
            key: "cornerTextureCoordinate",
            get: function get() {
                return this._cornerTextureCoordinate;
            }
        }, {
            key: "positionStartLifeTime",
            get: function get() {
                return this._positionStartLifeTime;
            }
        }, {
            key: "velocity",
            get: function get() {
                return this._velocity;
            }
        }, {
            key: "startColor",
            get: function get() {
                return this._startColor;
            }
        }, {
            key: "startSize",
            get: function get() {
                return this._startSize;
            }
        }, {
            key: "startRotation0",
            get: function get() {
                return this._startRotation0;
            }
        }, {
            key: "startRotation1",
            get: function get() {
                return this._startRotation1;
            }
        }, {
            key: "startRotation2",
            get: function get() {
                return this._startRotation2;
            }
        }, {
            key: "startLifeTime",
            get: function get() {
                return this._startLifeTime;
            }
        }, {
            key: "time",
            get: function get() {
                return this._time;
            }
        }, {
            key: "startSpeed",
            get: function get() {
                return this._startSpeed;
            }
        }, {
            key: "random0",
            get: function get() {
                return this._randoms0;
            }
        }, {
            key: "random1",
            get: function get() {
                return this._randoms1;
            }
        }, {
            key: "simulationWorldPostion",
            get: function get() {
                return this._simulationWorldPostion;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                jt._vertexDeclaration = new _e(152, [new he(0, le.Vector4, Zt.PARTICLE_CORNERTEXTURECOORDINATE0), new he(16, le.Vector4, Zt.PARTICLE_SHAPEPOSITIONSTARTLIFETIME), new he(32, le.Vector4, Zt.PARTICLE_DIRECTIONTIME), new he(48, le.Vector4, Zt.PARTICLE_STARTCOLOR0), new he(64, le.Vector3, Zt.PARTICLE_STARTSIZE), new he(76, le.Vector3, Zt.PARTICLE_STARTROTATION), new he(88, le.Single, Zt.PARTICLE_STARTSPEED), new he(92, le.Vector4, Zt.PARTICLE_RANDOM0), new he(108, le.Vector4, Zt.PARTICLE_RANDOM1), new he(124, le.Vector3, Zt.PARTICLE_SIMULATIONWORLDPOSTION), new he(136, le.Vector4, Zt.PARTICLE_SIMULATIONWORLDROTATION)]);
            }
        }, {
            key: "vertexDeclaration",
            get: function get() {
                return jt._vertexDeclaration;
            }
        }]);

        function jt(e, t, r, i, a, n, s, o, l, _, h, c, d, u) {
            var _this49;
            _classCallCheck(this, jt);
            _this49 = _possibleConstructorReturn(this, _getPrototypeOf(jt).call(this)), _this49._cornerTextureCoordinate = e,
                _this49._positionStartLifeTime = t, _this49._velocity = r, _this49._startColor = i,
                _this49._startSize = a, _this49._startRotation0 = n, _this49._startRotation1 = s,
                _this49._startRotation2 = o, _this49._startLifeTime = l, _this49._time = _, _this49._startSpeed = h,
                _this49._randoms0 = _this49.random0, _this49._randoms1 = _this49.random1, _this49._simulationWorldPostion = u;
            return _this49;
        }
        return jt;
    }(Zt);
    var qt = /* */ function(_Zt2) {
        _inherits(qt, _Zt2);
        _createClass(qt, [{
            key: "cornerTextureCoordinate",
            get: function get() {
                return this._cornerTextureCoordinate;
            }
        }, {
            key: "position",
            get: function get() {
                return this._positionStartLifeTime;
            }
        }, {
            key: "velocity",
            get: function get() {
                return this._velocity;
            }
        }, {
            key: "startColor",
            get: function get() {
                return this._startColor;
            }
        }, {
            key: "startSize",
            get: function get() {
                return this._startSize;
            }
        }, {
            key: "startRotation0",
            get: function get() {
                return this._startRotation0;
            }
        }, {
            key: "startRotation1",
            get: function get() {
                return this._startRotation1;
            }
        }, {
            key: "startRotation2",
            get: function get() {
                return this._startRotation2;
            }
        }, {
            key: "startLifeTime",
            get: function get() {
                return this._startLifeTime;
            }
        }, {
            key: "time",
            get: function get() {
                return this._time;
            }
        }, {
            key: "startSpeed",
            get: function get() {
                return this._startSpeed;
            }
        }, {
            key: "random0",
            get: function get() {
                return this._randoms0;
            }
        }, {
            key: "random1",
            get: function get() {
                return this._randoms1;
            }
        }, {
            key: "simulationWorldPostion",
            get: function get() {
                return this._simulationWorldPostion;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                qt._vertexDeclaration = new _e(172, [new he(0, le.Vector3, Zt.PARTICLE_POSITION0), new he(12, le.Vector4, Zt.PARTICLE_COLOR0), new he(28, le.Vector2, Zt.PARTICLE_TEXTURECOORDINATE0), new he(36, le.Vector4, Zt.PARTICLE_SHAPEPOSITIONSTARTLIFETIME), new he(52, le.Vector4, Zt.PARTICLE_DIRECTIONTIME), new he(68, le.Vector4, Zt.PARTICLE_STARTCOLOR0), new he(84, le.Vector3, Zt.PARTICLE_STARTSIZE), new he(96, le.Vector3, Zt.PARTICLE_STARTROTATION), new he(108, le.Single, Zt.PARTICLE_STARTSPEED), new he(112, le.Vector4, Zt.PARTICLE_RANDOM0), new he(128, le.Vector4, Zt.PARTICLE_RANDOM1), new he(144, le.Vector3, Zt.PARTICLE_SIMULATIONWORLDPOSTION), new he(156, le.Vector4, Zt.PARTICLE_SIMULATIONWORLDROTATION)]);
            }
        }, {
            key: "vertexDeclaration",
            get: function get() {
                return qt._vertexDeclaration;
            }
        }]);

        function qt(e, t, r, i, a, n, s, o, l, _, h, c, d, u) {
            var _this50;
            _classCallCheck(this, qt);
            _this50 = _possibleConstructorReturn(this, _getPrototypeOf(qt).call(this)), _this50._cornerTextureCoordinate = e,
                _this50._positionStartLifeTime = t, _this50._velocity = r, _this50._startColor = i,
                _this50._startSize = a, _this50._startRotation0 = n, _this50._startRotation1 = s,
                _this50._startRotation2 = o, _this50._startLifeTime = l, _this50._time = _, _this50._startSpeed = h,
                _this50._randoms0 = _this50.random0, _this50._randoms1 = _this50.random1, _this50._simulationWorldPostion = u;
            return _this50;
        }
        return qt;
    }(Zt);
    var Qt = /* */ function() {
        function Qt(e, t) {
            _classCallCheck(this, Qt);
            this.center = e, this.radius = t;
        }
        _createClass(Qt, [{
            key: "toDefault",
            value: function toDefault() {
                this.center.toDefault(), this.radius = 0;
            }
        }, {
            key: "intersectsRayDistance",
            value: function intersectsRayDistance(e) {
                return ze.intersectsRayAndSphereRD(e, this);
            }
        }, {
            key: "intersectsRayPoint",
            value: function intersectsRayPoint(e, t) {
                return ze.intersectsRayAndSphereRP(e, this, t);
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                this.center.cloneTo(t.center), t.radius = this.radius;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Qt(new n(), 0);
                return this.cloneTo(e), e;
            }
        }], [{
            key: "createFromSubPoints",
            value: function createFromSubPoints(e, t, r, i) {
                if (null == e) throw new Error("points");
                if (t < 0 || t >= e.length) throw new Error("start" + t + "Must be in the range [0, " + (e.length - 1) + "]");
                if (r < 0 || t + r > e.length) throw new Error("count" + r + "Must be in the range <= " + e.length + "}");
                var a = t + r,
                    s = Qt._tempVector3;
                s.x = 0, s.y = 0, s.z = 0;
                for (var o = t; o < a; ++o) {
                    n.add(e[o], s, s);
                }
                var l = i.center;
                n.scale(s, 1 / r, l);
                var _ = 0;
                for (o = t; o < a; ++o) {
                    var h = n.distanceSquared(l, e[o]);
                    h > _ && (_ = h);
                }
                i.radius = Math.sqrt(_);
            }
        }, {
            key: "createfromPoints",
            value: function createfromPoints(e, t) {
                if (null == e) throw new Error("points");
                Qt.createFromSubPoints(e, 0, e.length, t);
            }
        }]);
        return Qt;
    }();
    Qt._tempVector3 = new n();
    var Kt = /* */ function() {
        function Kt(e) {
            _classCallCheck(this, Kt);
            this._temp = new Uint32Array(1), this.seeds = new Uint32Array(4), this.seeds[0] = e,
                this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this.seeds[1] + 1,
                this.seeds[3] = 1812433253 * this.seeds[2] + 1;
        }
        _createClass(Kt, [{
            key: "getUint",
            value: function getUint() {
                return this._temp[0] = this.seeds[0] ^ this.seeds[0] << 11, this.seeds[0] = this.seeds[1],
                    this.seeds[1] = this.seeds[2], this.seeds[2] = this.seeds[3], this.seeds[3] = this.seeds[3] ^ this.seeds[3] >>> 19 ^ this._temp[0] ^ this._temp[0] >>> 8,
                    this.seeds[3];
            }
        }, {
            key: "getFloat",
            value: function getFloat() {
                return this.getUint(), (8388607 & this.seeds[3]) * (1 / 8388607);
            }
        }, {
            key: "getSignedFloat",
            value: function getSignedFloat() {
                return 2 * this.getFloat() - 1;
            }
        }, {
            key: "seed",
            get: function get() {
                return this.seeds[0];
            },
            set: function set(e) {
                this.seeds[0] = e, this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this.seeds[1] + 1,
                    this.seeds[3] = 1812433253 * this.seeds[2] + 1;
            }
        }], [{
            key: "getFloatFromInt",
            value: function getFloatFromInt(e) {
                return 1 / 8388607 * (8388607 & e);
            }
        }, {
            key: "getByteFromInt",
            value: function getByteFromInt(e) {
                return (8388607 & e) >>> 15;
            }
        }]);
        return Kt;
    }();
    var Jt = /* */ function() {
        function Jt() {
            _classCallCheck(this, Jt);
            this._emissionRate = 10, this._destroyed = !1, this._bursts = [];
        }
        _createClass(Jt, [{
            key: "destroy",
            value: function destroy() {
                this._bursts = null, this._destroyed = !0;
            }
        }, {
            key: "getBurstsCount",
            value: function getBurstsCount() {
                return this._bursts.length;
            }
        }, {
            key: "getBurstByIndex",
            value: function getBurstByIndex(e) {
                return this._bursts[e];
            }
        }, {
            key: "addBurst",
            value: function addBurst(e) {
                var t = this._bursts.length;
                if (t > 0)
                    for (var r = 0; r < t; r++) {
                        this._bursts[r].time > e.time && this._bursts.splice(r, 0, e);
                    }
                this._bursts.push(e);
            }
        }, {
            key: "removeBurst",
            value: function removeBurst(e) {
                var t = this._bursts.indexOf(e); -
                1 !== t && this._bursts.splice(t, 1);
            }
        }, {
            key: "removeBurstByIndex",
            value: function removeBurstByIndex(e) {
                this._bursts.splice(e, 1);
            }
        }, {
            key: "clearBurst",
            value: function clearBurst() {
                this._bursts.length = 0;
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e,
                    r = t._bursts;
                r.length = this._bursts.length;
                for (var i = 0, a = this._bursts.length; i < a; i++) {
                    var n = r[i];
                    n ? this._bursts[i].cloneTo(n) : r[i] = this._bursts[i].clone();
                }
                t._emissionRate = this._emissionRate, t.enable = this.enable;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Jt();
                return this.cloneTo(e), e;
            }
        }, {
            key: "emissionRate",
            set: function set(e) {
                if (e < 0) throw new Error("ParticleBaseShape:emissionRate value must large or equal than 0.");
                this._emissionRate = e;
            },
            get: function get() {
                return this._emissionRate;
            }
        }, {
            key: "destroyed",
            get: function get() {
                return this._destroyed;
            }
        }]);
        return Jt;
    }();
    var $t = /* */ function() {
        function $t() {
            _classCallCheck(this, $t);
        }
        _createClass($t, null, [{
            key: "_getStartLifetimeFromGradient",
            value: function _getStartLifetimeFromGradient(e, r) {
                for (var i = 1, a = e.gradientCount; i < a; i++) {
                    var n = e.getKeyByIndex(i);
                    if (n >= r) {
                        var s = e.getKeyByIndex(i - 1),
                            o = (r - s) / (n - s);
                        return t.MathUtil.lerp(e.getValueByIndex(i - 1), e.getValueByIndex(i), o);
                    }
                }
                throw new Error("ShurikenParticleData: can't get value foam startLifeTimeGradient.");
            }
        }, {
            key: "_randomInvertRoationArray",
            value: function _randomInvertRoationArray(e, t, r, i, a) {
                var n;
                i ? (i.seed = a[6], n = i.getFloat(), a[6] = i.seed) : n = Math.random(), n < r ? (t.x = -e.x,
                    t.y = -e.y, t.z = -e.z) : (t.x = e.x, t.y = e.y, t.z = e.z);
            }
        }, {
            key: "_randomInvertRoation",
            value: function _randomInvertRoation(e, t, r, i) {
                var a;
                return r ? (r.seed = i[6], a = r.getFloat(), i[6] = r.seed) : a = Math.random(),
                    a < t && (e = -e), e;
            }
        }, {
            key: "create",
            value: function create(e, r, i) {
                var n = e.autoRandomSeed,
                    s = e._rand,
                    o = e._randomSeeds;
                switch (e.startColorType) {
                    case 0:
                        var l = e.startColorConstant;
                        $t.startColor.x = l.x, $t.startColor.y = l.y, $t.startColor.z = l.z, $t.startColor.w = l.w;
                        break;

                    case 2:
                        n ? a.lerp(e.startColorConstantMin, e.startColorConstantMax, Math.random(), $t.startColor) : (s.seed = o[3],
                            a.lerp(e.startColorConstantMin, e.startColorConstantMax, s.getFloat(), $t.startColor),
                            o[3] = s.seed);
                }
                var _ = e.colorOverLifetime;
                if (_ && _.enable) {
                    var h = _.color;
                    switch (h.type) {
                        case 0:
                            $t.startColor.x = $t.startColor.x * h.constant.x, $t.startColor.y = $t.startColor.y * h.constant.y,
                                $t.startColor.z = $t.startColor.z * h.constant.z, $t.startColor.w = $t.startColor.w * h.constant.w;
                            break;

                        case 2:
                            var c;
                            n ? c = Math.random() : (s.seed = o[10], c = s.getFloat(), o[10] = s.seed);
                            var d = h.constantMin,
                                u = h.constantMax;
                            $t.startColor.x = $t.startColor.x * t.MathUtil.lerp(d.x, u.x, c), $t.startColor.y = $t.startColor.y * t.MathUtil.lerp(d.y, u.y, c),
                                $t.startColor.z = $t.startColor.z * t.MathUtil.lerp(d.z, u.z, c), $t.startColor.w = $t.startColor.w * t.MathUtil.lerp(d.w, u.w, c);
                    }
                }
                var m = $t.startSize;
                switch (e.startSizeType) {
                    case 0:
                        if (e.threeDStartSize) {
                            var f = e.startSizeConstantSeparate;
                            m[0] = f.x, m[1] = f.y, m[2] = f.z;
                        } else m[0] = m[1] = m[2] = e.startSizeConstant;
                        break;

                    case 2:
                        if (e.threeDStartSize) {
                            var E = e.startSizeConstantMinSeparate,
                                T = e.startSizeConstantMaxSeparate;
                            n ? (m[0] = t.MathUtil.lerp(E.x, T.x, Math.random()), m[1] = t.MathUtil.lerp(E.y, T.y, Math.random()),
                                m[2] = t.MathUtil.lerp(E.z, T.z, Math.random())) : (s.seed = o[4], m[0] = t.MathUtil.lerp(E.x, T.x, s.getFloat()),
                                m[1] = t.MathUtil.lerp(E.y, T.y, s.getFloat()), m[2] = t.MathUtil.lerp(E.z, T.z, s.getFloat()),
                                o[4] = s.seed);
                        } else n ? m[0] = m[1] = m[2] = t.MathUtil.lerp(e.startSizeConstantMin, e.startSizeConstantMax, Math.random()) : (s.seed = o[4],
                            m[0] = m[1] = m[2] = t.MathUtil.lerp(e.startSizeConstantMin, e.startSizeConstantMax, s.getFloat()),
                            o[4] = s.seed);
                }
                var p = e.sizeOverLifetime;
                if (p && p.enable && 1 === p.size.type) {
                    var g, S = p.size;
                    if (S.separateAxes) n ? (m[0] = m[0] * t.MathUtil.lerp(S.constantMinSeparate.x, S.constantMaxSeparate.x, Math.random()),
                        m[1] = m[1] * t.MathUtil.lerp(S.constantMinSeparate.y, S.constantMaxSeparate.y, Math.random()),
                        m[2] = m[2] * t.MathUtil.lerp(S.constantMinSeparate.z, S.constantMaxSeparate.z, Math.random())) : (s.seed = o[11],
                        m[0] = m[0] * t.MathUtil.lerp(S.constantMinSeparate.x, S.constantMaxSeparate.x, s.getFloat()),
                        m[1] = m[1] * t.MathUtil.lerp(S.constantMinSeparate.y, S.constantMaxSeparate.y, s.getFloat()),
                        m[2] = m[2] * t.MathUtil.lerp(S.constantMinSeparate.z, S.constantMaxSeparate.z, s.getFloat()),
                        o[11] = s.seed);
                    else n ? g = t.MathUtil.lerp(S.constantMin, S.constantMax, Math.random()) : (s.seed = o[11],
                            g = t.MathUtil.lerp(S.constantMin, S.constantMax, s.getFloat()), o[11] = s.seed),
                        m[0] = m[0] * g, m[1] = m[1] * g, m[2] = m[2] * g;
                }
                var R = r.renderMode;
                if (1 !== R) switch (e.startRotationType) {
                    case 0:
                        if (e.threeDStartRotation) {
                            var v = e.startRotationConstantSeparate,
                                x = $t._tempVector30;
                            $t._randomInvertRoationArray(v, x, e.randomizeRotationDirection, n ? null : s, o),
                                $t.startRotation[0] = x.x, $t.startRotation[1] = x.y, $t.startRotation[2] = 4 !== R ? -x.z : x.z;
                        } else $t.startRotation[0] = $t._randomInvertRoation(e.startRotationConstant, e.randomizeRotationDirection, n ? null : s, o),
                            $t.startRotation[1] = 0, $t.startRotation[2] = 0;
                        break;

                    case 2:
                        if (e.threeDStartRotation) {
                            var I = e.startRotationConstantMinSeparate,
                                A = e.startRotationConstantMaxSeparate,
                                M = $t._tempVector30;
                            n ? (M.x = t.MathUtil.lerp(I.x, A.x, Math.random()), M.y = t.MathUtil.lerp(I.y, A.y, Math.random()),
                                    M.z = t.MathUtil.lerp(I.z, A.z, Math.random())) : (s.seed = o[5], M.x = t.MathUtil.lerp(I.x, A.x, s.getFloat()),
                                    M.y = t.MathUtil.lerp(I.y, A.y, s.getFloat()), M.z = t.MathUtil.lerp(I.z, A.z, s.getFloat()),
                                    o[5] = s.seed), $t._randomInvertRoationArray(M, M, e.randomizeRotationDirection, n ? null : s, o),
                                $t.startRotation[0] = M.x, $t.startRotation[1] = M.y, $t.startRotation[2] = 4 !== R ? -M.z : M.z;
                        } else n ? $t.startRotation[0] = $t._randomInvertRoation(t.MathUtil.lerp(e.startRotationConstantMin, e.startRotationConstantMax, Math.random()), e.randomizeRotationDirection, n ? null : s, o) : (s.seed = o[5],
                            $t.startRotation[0] = $t._randomInvertRoation(t.MathUtil.lerp(e.startRotationConstantMin, e.startRotationConstantMax, s.getFloat()), e.randomizeRotationDirection, n ? null : s, o),
                            o[5] = s.seed);
                }
                switch (e.startLifetimeType) {
                    case 0:
                        $t.startLifeTime = e.startLifetimeConstant;
                        break;

                    case 1:
                        $t.startLifeTime = $t._getStartLifetimeFromGradient(e.startLifeTimeGradient, e.emissionTime);
                        break;

                    case 2:
                        n ? $t.startLifeTime = t.MathUtil.lerp(e.startLifetimeConstantMin, e.startLifetimeConstantMax, Math.random()) : (s.seed = o[7],
                            $t.startLifeTime = t.MathUtil.lerp(e.startLifetimeConstantMin, e.startLifetimeConstantMax, s.getFloat()),
                            o[7] = s.seed);
                        break;

                    case 3:
                        var D = e.emissionTime;
                        n ? $t.startLifeTime = t.MathUtil.lerp($t._getStartLifetimeFromGradient(e.startLifeTimeGradientMin, D), $t._getStartLifetimeFromGradient(e.startLifeTimeGradientMax, D), Math.random()) : (s.seed = o[7],
                            $t.startLifeTime = t.MathUtil.lerp($t._getStartLifetimeFromGradient(e.startLifeTimeGradientMin, D), $t._getStartLifetimeFromGradient(e.startLifeTimeGradientMax, D), s.getFloat()),
                            o[7] = s.seed);
                }
                var L = e.textureSheetAnimation;
                if (L && L.enable) {
                    var y, C = L.tiles,
                        O = C.x,
                        N = C.y,
                        P = 1 / O,
                        b = 1 / N,
                        V = L.startFrame;
                    switch (V.type) {
                        case 0:
                            y = V.constant;
                            break;

                        case 1:
                            n ? y = t.MathUtil.lerp(V.constantMin, V.constantMax, Math.random()) : (s.seed = o[14],
                                y = t.MathUtil.lerp(V.constantMin, V.constantMax, s.getFloat()), o[14] = s.seed);
                    }
                    var w = L.frame,
                        F = L.cycles;
                    switch (w.type) {
                        case 0:
                            y += w.constant * F;
                            break;

                        case 2:
                            n ? y += t.MathUtil.lerp(w.constantMin, w.constantMax, Math.random()) * F : (s.seed = o[15],
                                y += t.MathUtil.lerp(w.constantMin, w.constantMax, s.getFloat()) * F, o[15] = s.seed);
                    }
                    var B = 0;
                    switch (L.type) {
                        case 0:
                            B = Math.floor(y / O);
                            break;

                        case 1:
                            L.randomRow ? n ? B = Math.floor(Math.random() * N) : (s.seed = o[13], B = Math.floor(s.getFloat() * N),
                                o[13] = s.seed) : B = L.rowIndex;
                    }
                    var U = Math.floor(y % O);
                    $t.startUVInfo = $t.startUVInfo, $t.startUVInfo[0] = P, $t.startUVInfo[1] = b, $t.startUVInfo[2] = U * P,
                        $t.startUVInfo[3] = B * b;
                } else $t.startUVInfo = $t.startUVInfo, $t.startUVInfo[0] = 1, $t.startUVInfo[1] = 1,
                    $t.startUVInfo[2] = 0, $t.startUVInfo[3] = 0;
            }
        }]);
        return $t;
    }();
    $t._tempVector30 = new n(), $t.startColor = new a(), $t.startSize = new Float32Array(3),
        $t.startRotation = new Float32Array(3), $t.startUVInfo = new Float32Array(4);
    var er = /* */ function(_Pe4) {
        _inherits(er, _Pe4);

        function er(e) {
            var _this51;
            _classCallCheck(this, er);
            _this51 = _possibleConstructorReturn(this, _getPrototypeOf(er).call(this)), _this51._boundingSphere = null,
                _this51._boundingBox = null, _this51._boundingBoxCorners = null, _this51._owner = null,
                _this51._ownerRender = null, _this51._vertices = null, _this51._floatCountPerVertex = 0,
                _this51._startLifeTimeIndex = 0, _this51._timeIndex = 0, _this51._simulateUpdate = !1,
                _this51._firstActiveElement = 0, _this51._firstNewElement = 0, _this51._firstFreeElement = 0,
                _this51._firstRetiredElement = 0, _this51._drawCounter = 0, _this51._bufferMaxParticles = 0,
                _this51._emission = null, _this51._shape = null, _this51._isEmitting = !1, _this51._isPlaying = !1,
                _this51._isPaused = !1, _this51._playStartDelay = 0, _this51._frameRateTime = 0,
                _this51._emissionTime = 0, _this51._totalDelayTime = 0, _this51._burstsIndex = 0,
                _this51._velocityOverLifetime = null, _this51._colorOverLifetime = null, _this51._sizeOverLifetime = null,
                _this51._rotationOverLifetime = null, _this51._textureSheetAnimation = null, _this51._startLifetimeType = 0,
                _this51._startLifetimeConstant = 0, _this51._startLifeTimeGradient = null, _this51._startLifetimeConstantMin = 0,
                _this51._startLifetimeConstantMax = 0, _this51._startLifeTimeGradientMin = null,
                _this51._startLifeTimeGradientMax = null, _this51._maxStartLifetime = 0, _this51._uvLength = new i(),
                _this51._vertexStride = 0, _this51._indexStride = 0, _this51._vertexBuffer = null,
                _this51._indexBuffer = null, _this51._bufferState = new Xe(), _this51._currentTime = 0,
                _this51._startUpdateLoopCount = 0, _this51._rand = null, _this51._randomSeeds = null,
                _this51.duration = 0, _this51.looping = !1, _this51.prewarm = !1, _this51.startDelayType = 0,
                _this51.startDelay = 0, _this51.startDelayMin = 0, _this51.startDelayMax = 0, _this51.startSpeedType = 0,
                _this51.startSpeedConstant = 0, _this51.startSpeedConstantMin = 0, _this51.startSpeedConstantMax = 0,
                _this51.threeDStartSize = !1, _this51.startSizeType = 0, _this51.startSizeConstant = 0,
                _this51.startSizeConstantSeparate = null, _this51.startSizeConstantMin = 0, _this51.startSizeConstantMax = 0,
                _this51.startSizeConstantMinSeparate = null, _this51.startSizeConstantMaxSeparate = null,
                _this51.threeDStartRotation = !1, _this51.startRotationType = 0, _this51.startRotationConstant = 0,
                _this51.startRotationConstantSeparate = null, _this51.startRotationConstantMin = 0,
                _this51.startRotationConstantMax = 0, _this51.startRotationConstantMinSeparate = null,
                _this51.startRotationConstantMaxSeparate = null, _this51.randomizeRotationDirection = 0,
                _this51.startColorType = 0, _this51.startColorConstant = new a(1, 1, 1, 1), _this51.startColorConstantMin = new a(0, 0, 0, 0),
                _this51.startColorConstantMax = new a(1, 1, 1, 1), _this51.gravityModifier = 0,
                _this51.simulationSpace = 0, _this51.simulationSpeed = 1, _this51.scaleMode = 0,
                _this51.playOnAwake = !1, _this51.randomSeed = null, _this51.autoRandomSeed = !1,
                _this51.isPerformanceMode = !1, _this51._firstActiveElement = 0, _this51._firstNewElement = 0,
                _this51._firstFreeElement = 0, _this51._firstRetiredElement = 0, _this51._owner = e,
                _this51._ownerRender = e.particleRenderer, _this51._boundingBoxCorners = [], _this51._boundingSphere = new Qt(new n(), Number.MAX_VALUE),
                _this51._boundingBox = new dt(new n(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), new n(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)),
                _this51._currentTime = 0, _this51._isEmitting = !1, _this51._isPlaying = !1, _this51._isPaused = !1,
                _this51._burstsIndex = 0, _this51._frameRateTime = 0, _this51._emissionTime = 0,
                _this51._totalDelayTime = 0, _this51._simulateUpdate = !1, _this51._bufferMaxParticles = 1,
                _this51.duration = 5, _this51.looping = !0, _this51.prewarm = !1, _this51.startDelayType = 0,
                _this51.startDelay = 0, _this51.startDelayMin = 0, _this51.startDelayMax = 0, _this51._startLifetimeType = 0,
                _this51._startLifetimeConstant = 5, _this51._startLifeTimeGradient = new Lt(), _this51._startLifetimeConstantMin = 0,
                _this51._startLifetimeConstantMax = 5, _this51._startLifeTimeGradientMin = new Lt(),
                _this51._startLifeTimeGradientMax = new Lt(), _this51._maxStartLifetime = 5, _this51.startSpeedType = 0,
                _this51.startSpeedConstant = 5, _this51.startSpeedConstantMin = 0, _this51.startSpeedConstantMax = 5,
                _this51.threeDStartSize = !1, _this51.startSizeType = 0, _this51.startSizeConstant = 1,
                _this51.startSizeConstantSeparate = new n(1, 1, 1), _this51.startSizeConstantMin = 0,
                _this51.startSizeConstantMax = 1, _this51.startSizeConstantMinSeparate = new n(0, 0, 0),
                _this51.startSizeConstantMaxSeparate = new n(1, 1, 1), _this51.threeDStartRotation = !1,
                _this51.startRotationType = 0, _this51.startRotationConstant = 0, _this51.startRotationConstantSeparate = new n(0, 0, 0),
                _this51.startRotationConstantMin = 0, _this51.startRotationConstantMax = 0, _this51.startRotationConstantMinSeparate = new n(0, 0, 0),
                _this51.startRotationConstantMaxSeparate = new n(0, 0, 0), _this51.gravityModifier = 0,
                _this51.simulationSpace = 1, _this51.scaleMode = 0, _this51.playOnAwake = !0, _this51._rand = new Kt(0),
                _this51.autoRandomSeed = !0, _this51.randomSeed = new Uint32Array(1), _this51._randomSeeds = new Uint32Array(er._RANDOMOFFSET.length),
                _this51.isPerformanceMode = !0, _this51._emission = new Jt(), _this51._emission.enable = !0;
            return _this51;
        }
        _createClass(er, [{
            key: "_getVertexBuffer",
            value: function _getVertexBuffer() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                return 0 === e ? this._vertexBuffer : null;
            }
        }, {
            key: "_getIndexBuffer",
            value: function _getIndexBuffer() {
                return this._indexBuffer;
            }
        }, {
            key: "_generateBoundingSphere",
            value: function _generateBoundingSphere() {
                var e = this._boundingSphere.center;
                e.x = 0, e.y = 0, e.z = 0, this._boundingSphere.radius = Number.MAX_VALUE;
            }
        }, {
            key: "_generateBoundingBox",
            value: function _generateBoundingBox() {
                var e, t, r, i, a, s, o, l, _, h = this._owner.particleRenderer,
                    c = this._boundingBox.min,
                    d = this._boundingBox.max;
                switch (this.startLifetimeType) {
                    case 0:
                        r = this.startLifetimeConstant;
                        break;

                    case 1:
                        r = -Number.MAX_VALUE;
                        var u = u;
                        for (e = 0, t = u.gradientCount; e < t; e++) {
                            r = Math.max(r, u.getValueByIndex(e));
                        }
                        break;

                    case 2:
                        r = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                        break;

                    case 3:
                        r = -Number.MAX_VALUE;
                        var m = m;
                        for (e = 0, t = m.gradientCount; e < t; e++) {
                            r = Math.max(r, m.getValueByIndex(e));
                        }
                        var f = f;
                        for (e = 0, t = f.gradientCount; e < t; e++) {
                            r = Math.max(r, f.getValueByIndex(e));
                        }
                }
                switch (this.startSpeedType) {
                    case 0:
                        i = a = this.startSpeedConstant;
                        break;

                    case 1:
                        break;

                    case 2:
                        i = this.startLifetimeConstantMin, a = this.startLifetimeConstantMax;
                }
                this._shape && this._shape.enable || (s = o = n._ZERO, l = n._ZERO, _ = n._UnitZ);
                var E, T, p = new n(l.x * i, l.y * i, l.z * i),
                    g = new n(_.x * a, _.y * a, _.z * a);
                if (this._velocityOverLifetime && this._velocityOverLifetime.enable) {
                    var S = this._velocityOverLifetime.velocity;
                    switch (S.type) {
                        case 0:
                            S.constant;
                            break;

                        case 1:
                            new n(S.gradientX.getAverageValue(), S.gradientY.getAverageValue(), S.gradientZ.getAverageValue());
                            break;

                        case 2:
                            S.constantMin, S.constantMax;
                            break;

                        case 3:
                            new n(S.gradientXMin.getAverageValue(), S.gradientYMin.getAverageValue(), S.gradientZMin.getAverageValue()),
                                new n(S.gradientXMax.getAverageValue(), S.gradientYMax.getAverageValue(), S.gradientZMax.getAverageValue());
                    }
                }
                var R, v, x, I, A = this._owner.transform,
                    M = A.position,
                    D = er._tempVector39,
                    L = h.renderMode;
                switch (this.scaleMode) {
                    case 0:
                        var y = A.getWorldLossyScale();
                        E = y, D.x = y.x, D.y = y.z, D.z = y.y, 1 === L && (T = y);
                        break;

                    case 1:
                        var C = A.localScale;
                        E = C, D.x = C.x, D.y = C.z, D.z = C.y, 1 === L && (T = C);
                        break;

                    case 2:
                        E = A.getWorldLossyScale(), D.x = D.y = D.z = 1, 1 === L && (T = n._ONE);
                }
                switch (this._velocityOverLifetime && this._velocityOverLifetime.enable || (R = new n(p.x * r, p.y * r, p.z * r),
                    v = new n(g.x * r, g.y * r, g.z * r), 2 != this.scaleMode ? (n.add(s, R, c), n.multiply(E, c, c),
                        n.add(o, v, d), n.multiply(E, d, d)) : (n.multiply(E, s, c), n.add(c, R, c), n.multiply(E, o, d),
                        n.add(d, v, d))), this.simulationSpace) {
                    case 0:
                        break;

                    case 1:
                        n.add(c, M, c), n.add(d, M, d);
                }
                switch (this.startSizeType) {
                    case 0:
                        if (this.threeDStartSize) {
                            var O = O;
                            x = Math.max(O.x, O.y), 1 === L && (I = O.y);
                        } else x = this.startSizeConstant, 1 === L && (I = this.startSizeConstant);
                        break;

                    case 1:
                        break;

                    case 2:
                        if (this.threeDStartSize) {
                            var N = N;
                            x = Math.max(N.x, N.y), 1 === L && (I = N.y);
                        } else x = this.startSizeConstantMax, 1 === L && (I = this.startSizeConstantMax);
                }
                if (this._sizeOverLifetime && this._sizeOverLifetime.enable) {
                    this._sizeOverLifetime.size;
                    x *= this._sizeOverLifetime.size.getMaxSizeInGradient();
                }
                var P, b, V = er._tempVector30;
                switch (L) {
                    case 0:
                        P = x * er.halfKSqrtOf2, n.scale(D, x, V), n.subtract(c, V, c), n.add(d, V, d);
                        break;

                    case 1:
                        var w = er._tempVector31,
                            F = er._tempVector32,
                            B = er._tempVector33,
                            U = er._tempVector34;
                        this._velocityOverLifetime && this._velocityOverLifetime.enable || (n.multiply(T, g, F),
                            n.multiply(T, p, B));
                        var G = I * h.stretchedBillboardLengthScale,
                            z = n.scalarLength(F) * h.stretchedBillboardSpeedScale + G,
                            H = n.scalarLength(B) * h.stretchedBillboardSpeedScale + G,
                            k = er._tempVector35,
                            W = er._tempVector36;
                        n.normalize(F, k), n.scale(k, z, U), n.subtract(v, U, U), n.normalize(B, W), n.scale(W, H, w),
                            n.add(R, w, w), P = x * er.halfKSqrtOf2, n.scale(D, P, V);
                        var X = er._tempVector37,
                            Y = er._tempVector38;
                        n.scale(k, .5, X), n.scale(W, .5, Y), n.multiply(X, D, X), n.multiply(Y, D, Y),
                            n.add(c, Y, c), n.min(c, U, c), n.subtract(c, V, c), n.subtract(d, X, d), n.max(d, w, d),
                            n.add(d, V, d);
                        break;

                    case 2:
                        b = .5 * (x *= Math.cos(.7853981633974483)), V.x = D.x * b, V.y = D.z * b, n.subtract(c, V, c),
                            n.add(d, V, d);
                        break;

                    case 3:
                        b = .5 * (x *= Math.cos(.7853981633974483)), n.scale(D, b, V), n.subtract(c, V, c),
                            n.add(d, V, d);
                }
                this._boundingBox.getCorners(this._boundingBoxCorners);
            }
        }, {
            key: "_updateEmission",
            value: function _updateEmission() {
                if (this.isAlive)
                    if (this._simulateUpdate) this._simulateUpdate = !1;
                    else {
                        var e = this._startUpdateLoopCount === t.Stat.loopCount || this._isPaused ? 0 : this._owner._scene.timer._delta / 1e3;
                        e = Math.min(er._maxElapsedTime, e * this.simulationSpeed), this._updateParticles(e);
                    }
            }
        }, {
            key: "_updateParticles",
            value: function _updateParticles(e) {
                (4 !== this._ownerRender.renderMode || this._ownerRender.mesh) && (this._currentTime += e,
                    this._retireActiveParticles(), this._freeRetiredParticles(), this._totalDelayTime += e,
                    this._totalDelayTime < this._playStartDelay || this._emission.enable && this._isEmitting && !this._isPaused && this._advanceTime(e, this._currentTime));
            }
        }, {
            key: "_updateParticlesSimulationRestart",
            value: function _updateParticlesSimulationRestart(e) {
                this._firstActiveElement = 0, this._firstNewElement = 0, this._firstFreeElement = 0,
                    this._firstRetiredElement = 0, this._burstsIndex = 0, this._frameRateTime = e, this._emissionTime = 0,
                    this._totalDelayTime = 0, this._currentTime = e;
                var t = e;
                t < this._playStartDelay ? this._totalDelayTime = t : this._emission.enable && this._advanceTime(e, e);
            }
        }, {
            key: "_retireActiveParticles",
            value: function _retireActiveParticles() {
                for (; this._firstActiveElement != this._firstNewElement;) {
                    var e = this._firstActiveElement * this._floatCountPerVertex * this._vertexStride,
                        t = e + this._timeIndex;
                    if (this._currentTime - this._vertices[t] + 1e-4 < this._vertices[e + this._startLifeTimeIndex]) break;
                    this._vertices[t] = this._drawCounter, this._firstActiveElement++, this._firstActiveElement >= this._bufferMaxParticles && (this._firstActiveElement = 0);
                }
            }
        }, {
            key: "_freeRetiredParticles",
            value: function _freeRetiredParticles() {
                for (; this._firstRetiredElement != this._firstActiveElement;) {
                    var e = this._drawCounter - this._vertices[this._firstRetiredElement * this._floatCountPerVertex * this._vertexStride + this._timeIndex];
                    if (this.isPerformanceMode && e < 3) break;
                    this._firstRetiredElement++, this._firstRetiredElement >= this._bufferMaxParticles && (this._firstRetiredElement = 0);
                }
            }
        }, {
            key: "_burst",
            value: function _burst(e, r) {
                for (var i = 0, a = this._emission._bursts, n = a.length; this._burstsIndex < n; this._burstsIndex++) {
                    var s, o = a[this._burstsIndex],
                        l = o.time;
                    if (!(e <= l && l < r)) break;
                    this.autoRandomSeed ? s = t.MathUtil.lerp(o.minCount, o.maxCount, Math.random()) : (this._rand.seed = this._randomSeeds[0],
                            s = t.MathUtil.lerp(o.minCount, o.maxCount, this._rand.getFloat()), this._randomSeeds[0] = this._rand.seed),
                        i += s;
                }
                return i;
            }
        }, {
            key: "_advanceTime",
            value: function _advanceTime(e, t) {
                var r, i = this._emissionTime;
                this._emissionTime += e;
                var a = 0;
                if (this._emissionTime > this.duration) {
                    if (!this.looping) {
                        for (a = Math.min(this.maxParticles - this.aliveParticleCount, a), r = 0; r < a; r++) {
                            this.emit(t);
                        }
                        return this._isPlaying = !1, void this.stop();
                    }
                    a += this._burst(i, this._emissionTime), this._emissionTime -= this.duration, this._burstsIndex = 0,
                        a += this._burst(0, this._emissionTime);
                } else a += this._burst(i, this._emissionTime);
                for (a = Math.min(this.maxParticles - this.aliveParticleCount, a), r = 0; r < a; r++) {
                    this.emit(t);
                }
                var n = this.emission.emissionRate;
                if (n > 0) {
                    var s = 1 / n;
                    for (this._frameRateTime += s, this._frameRateTime = this._currentTime - (this._currentTime - this._frameRateTime) % this._maxStartLifetime; this._frameRateTime <= t && this.emit(this._frameRateTime);) {
                        this._frameRateTime += s;
                    }
                    this._frameRateTime = Math.floor(t / s) * s;
                }
            }
        }, {
            key: "_initBufferDatas",
            value: function _initBufferDatas() {
                if (this._vertexBuffer) {
                    this._vertexBuffer.destroy(), this._indexBuffer.destroy();
                    var r = this._vertexBuffer._byteLength + 2 * this._indexBuffer.indexCount;
                    t.Resource._addMemory(-r, -r);
                }
                var i = t.LayaGL.instance,
                    a = this._ownerRender,
                    n = a.renderMode;
                if (-1 !== n && this.maxParticles > 0) {
                    var s, o, l, _, h, c, d, u = 0,
                        m = (r = 0, a.mesh);
                    if (4 === n) {
                        if (m) {
                            d = qt.vertexDeclaration, this._floatCountPerVertex = d.vertexStride / 4, this._startLifeTimeIndex = 12,
                                this._timeIndex = 16, this._vertexStride = m._vertexCount;
                            var f = this._bufferMaxParticles * this._vertexStride,
                                E = f % 65535;
                            if (Math.floor(f / 65535) + 1 > 1) throw new Error("ShurikenParticleSystem:the maxParticleCount multiply mesh vertexCount is large than 65535.");
                            u = d.vertexStride * E, this._vertexBuffer = new be(u, i.DYNAMIC_DRAW), this._vertexBuffer.vertexDeclaration = d,
                                this._vertices = new Float32Array(this._floatCountPerVertex * E), this._indexStride = m._indexBuffer.indexCount;
                            var T = m._indexBuffer.getData(),
                                p = this._bufferMaxParticles * this._indexStride;
                            for (this._indexBuffer = new Ye(e.IndexFormat.UInt16, p, i.STATIC_DRAW), s = new Uint16Array(p),
                                r = u + 2 * p, h = 0, o = 0; o < this._bufferMaxParticles; o++) {
                                var g = o * this._vertexStride;
                                for (l = 0, _ = T.length; l < _; l++) {
                                    s[h++] = g + T[l];
                                }
                            }
                            this._indexBuffer.setData(s), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer),
                                this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind();
                        }
                    } else {
                        for (d = jt.vertexDeclaration, this._floatCountPerVertex = d.vertexStride / 4, this._startLifeTimeIndex = 7,
                            this._timeIndex = 11, this._vertexStride = 4, u = d.vertexStride * this._bufferMaxParticles * this._vertexStride,
                            this._vertexBuffer = new be(u, i.DYNAMIC_DRAW), this._vertexBuffer.vertexDeclaration = d,
                            this._vertices = new Float32Array(this._floatCountPerVertex * this._bufferMaxParticles * this._vertexStride),
                            o = 0; o < this._bufferMaxParticles; o++) {
                            c = o * this._floatCountPerVertex * this._vertexStride, this._vertices[c] = -.5,
                                this._vertices[c + 1] = -.5, this._vertices[c + 2] = 0, this._vertices[c + 3] = 1,
                                c += this._floatCountPerVertex, this._vertices[c] = .5, this._vertices[c + 1] = -.5,
                                this._vertices[c + 2] = 1, this._vertices[c + 3] = 1, c += this._floatCountPerVertex,
                                this._vertices[c] = .5, this._vertices[c + 1] = .5, this._vertices[c + 2] = 1, this._vertices[c + 3] = 0,
                                c += this._floatCountPerVertex, this._vertices[c] = -.5, this._vertices[c + 1] = .5,
                                this._vertices[c + 2] = 0, this._vertices[c + 3] = 0;
                        }
                        for (this._indexStride = 6, this._indexBuffer = new Ye(e.IndexFormat.UInt16, 6 * this._bufferMaxParticles, i.STATIC_DRAW),
                            s = new Uint16Array(6 * this._bufferMaxParticles), o = 0; o < this._bufferMaxParticles; o++) {
                            h = 6 * o;
                            var S = o * this._vertexStride,
                                R = S + 2;
                            s[h++] = S, s[h++] = R, s[h++] = S + 1, s[h++] = S, s[h++] = S + 3, s[h++] = R;
                        }
                        this._indexBuffer.setData(s), r = u + 6 * this._bufferMaxParticles * 2, this._bufferState.bind(),
                            this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.applyIndexBuffer(this._indexBuffer),
                            this._bufferState.unBind();
                    }
                    t.Resource._addMemory(r, r);
                }
            }
        }, {
            key: "destroy",
            value: function destroy() {
                _get(_getPrototypeOf(er.prototype), "destroy", this).call(this);
                var e = this._vertexBuffer._byteLength + 2 * this._indexBuffer.indexCount;
                t.Resource._addMemory(-e, -e), this._bufferState.destroy(), this._vertexBuffer.destroy(),
                    this._indexBuffer.destroy(), this._emission.destroy(), this._bufferState = null,
                    this._vertexBuffer = null, this._indexBuffer = null, this._owner = null, this._vertices = null,
                    this._indexBuffer = null, this._emission = null, this._shape = null, this.startLifeTimeGradient = null,
                    this.startLifeTimeGradientMin = null, this.startLifeTimeGradientMax = null, this.startSizeConstantSeparate = null,
                    this.startSizeConstantMinSeparate = null, this.startSizeConstantMaxSeparate = null,
                    this.startRotationConstantSeparate = null, this.startRotationConstantMinSeparate = null,
                    this.startRotationConstantMaxSeparate = null, this.startColorConstant = null, this.startColorConstantMin = null,
                    this.startColorConstantMax = null, this._velocityOverLifetime = null, this._colorOverLifetime = null,
                    this._sizeOverLifetime = null, this._rotationOverLifetime = null, this._textureSheetAnimation = null;
            }
        }, {
            key: "emit",
            value: function emit(e) {
                var t = er._tempPosition,
                    r = er._tempDirection;
                return this._shape && this._shape.enable ? this.autoRandomSeed ? this._shape.generatePositionAndDirection(t, r) : this._shape.generatePositionAndDirection(t, r, this._rand, this._randomSeeds) : (t.x = t.y = t.z = 0,
                    r.x = r.y = 0, r.z = 1), this.addParticle(t, r, e);
            }
        }, {
            key: "addParticle",
            value: function addParticle(e, r, i) {
                n.normalize(r, r);
                var a = this._firstFreeElement + 1;
                if (a >= this._bufferMaxParticles && (a = 0), a === this._firstRetiredElement) return !1;
                var s, o, l, _, h, c, d, u, m, f, E = this._owner.transform;
                if ($t.create(this, this._ownerRender, E), this._currentTime - i >= $t.startLifeTime) return !0;
                switch (0 == this.simulationSpace && (s = E.position, o = E.rotation), this.startSpeedType) {
                    case 0:
                        l = this.startSpeedConstant;
                        break;

                    case 2:
                        this.autoRandomSeed ? l = t.MathUtil.lerp(this.startSpeedConstantMin, this.startSpeedConstantMax, Math.random()) : (this._rand.seed = this._randomSeeds[8],
                            l = t.MathUtil.lerp(this.startSpeedConstantMin, this.startSpeedConstantMax, this._rand.getFloat()),
                            this._randomSeeds[8] = this._rand.seed);
                }
                var T = this._velocityOverLifetime && this._velocityOverLifetime.enable;
                if (T) {
                    var p = this._velocityOverLifetime.velocity.type;
                    2 === p || 3 === p ? this.autoRandomSeed ? (_ = Math.random(), h = Math.random(),
                        c = Math.random()) : (this._rand.seed = this._randomSeeds[9], _ = this._rand.getFloat(),
                        h = this._rand.getFloat(), c = this._rand.getFloat(), this._randomSeeds[9] = this._rand.seed) : T = !1;
                } else T = !1;
                var g = this._colorOverLifetime && this._colorOverLifetime.enable;
                g ? 3 === this._colorOverLifetime.color.type ? this.autoRandomSeed ? d = Math.random() : (this._rand.seed = this._randomSeeds[10],
                    d = this._rand.getFloat(), this._randomSeeds[10] = this._rand.seed) : g = !1 : g = !1;
                var S = this._sizeOverLifetime && this._sizeOverLifetime.enable;
                S ? 3 === this._sizeOverLifetime.size.type ? this.autoRandomSeed ? u = Math.random() : (this._rand.seed = this._randomSeeds[11],
                    u = this._rand.getFloat(), this._randomSeeds[11] = this._rand.seed) : S = !1 : S = !1;
                var R = this._rotationOverLifetime && this._rotationOverLifetime.enable;
                if (R) {
                    var v = this._rotationOverLifetime.angularVelocity.type;
                    2 === v || 3 === v ? this.autoRandomSeed ? m = Math.random() : (this._rand.seed = this._randomSeeds[12],
                        m = this._rand.getFloat(), this._randomSeeds[12] = this._rand.seed) : R = !1;
                } else R = !1;
                var x = this._textureSheetAnimation && this._textureSheetAnimation.enable;
                x ? 3 === this._textureSheetAnimation.frame.type ? this.autoRandomSeed ? f = Math.random() : (this._rand.seed = this._randomSeeds[15],
                    f = this._rand.getFloat(), this._randomSeeds[15] = this._rand.seed) : x = !1 : x = !1;
                var I, A, M, D, L, y, C = this._firstFreeElement * this._floatCountPerVertex * this._vertexStride,
                    O = $t.startUVInfo[0],
                    N = $t.startUVInfo[1],
                    P = $t.startUVInfo[2],
                    b = $t.startUVInfo[3],
                    V = this._ownerRender;
                if (4 === V.renderMode) {
                    var w = V.mesh._vertexBuffer;
                    I = w.getFloat32Data();
                    var F = w.vertexDeclaration;
                    M = F.getVertexElementByUsage(ce.MESH_POSITION0)._offset / 4;
                    var B = F.getVertexElementByUsage(ce.MESH_COLOR0);
                    D = B ? B._offset / 4 : -1;
                    var U = F.getVertexElementByUsage(ce.MESH_TEXTURECOORDINATE0);
                    L = U ? U._offset / 4 : -1, A = F.vertexStride / 4, y = 0;
                } else {
                    this._vertices[C + 2] = P, this._vertices[C + 3] = b + N;
                    var G = C + this._floatCountPerVertex;
                    this._vertices[G + 2] = P + O, this._vertices[G + 3] = b + N;
                    var z = G + this._floatCountPerVertex;
                    this._vertices[z + 2] = P + O, this._vertices[z + 3] = b;
                    var H = z + this._floatCountPerVertex;
                    this._vertices[H + 2] = P, this._vertices[H + 3] = b;
                }
                for (var k = C, W = C + this._floatCountPerVertex * this._vertexStride; k < W; k += this._floatCountPerVertex) {
                    var X;
                    if (4 === V.renderMode) {
                        X = k;
                        var Y = A * y++,
                            Z = Y + M;
                        this._vertices[X++] = I[Z++], this._vertices[X++] = I[Z++], this._vertices[X++] = I[Z], -1 === D ? (this._vertices[X++] = 1, this._vertices[X++] = 1, this._vertices[X++] = 1,
                            this._vertices[X++] = 1) : (Z = Y + D, this._vertices[X++] = I[Z++], this._vertices[X++] = I[Z++],
                            this._vertices[X++] = I[Z++], this._vertices[X++] = I[Z]), -1 === L ? (this._vertices[X++] = 0,
                            this._vertices[X++] = 0) : (Z = Y + L, this._vertices[X++] = P + I[Z++] * O, this._vertices[X++] = b + I[Z] * N);
                    } else X = k + 4;
                    switch (this._vertices[X++] = e.x, this._vertices[X++] = e.y, this._vertices[X++] = e.z,
                        this._vertices[X++] = $t.startLifeTime, this._vertices[X++] = r.x, this._vertices[X++] = r.y,
                        this._vertices[X++] = r.z, this._vertices[X++] = i, this._vertices[X++] = $t.startColor.x,
                        this._vertices[X++] = $t.startColor.y, this._vertices[X++] = $t.startColor.z, this._vertices[X++] = $t.startColor.w,
                        this._vertices[X++] = $t.startSize[0], this._vertices[X++] = $t.startSize[1], this._vertices[X++] = $t.startSize[2],
                        this._vertices[X++] = $t.startRotation[0], this._vertices[X++] = $t.startRotation[1],
                        this._vertices[X++] = $t.startRotation[2], this._vertices[X++] = l, g && (this._vertices[X + 1] = d),
                        S && (this._vertices[X + 2] = u), R && (this._vertices[X + 3] = m), x && (this._vertices[X + 4] = f),
                        T && (this._vertices[X + 5] = _, this._vertices[X + 6] = h, this._vertices[X + 7] = c),
                        this.simulationSpace) {
                        case 0:
                            X += 8, this._vertices[X++] = s.x, this._vertices[X++] = s.y, this._vertices[X++] = s.z,
                                this._vertices[X++] = o.x, this._vertices[X++] = o.y, this._vertices[X++] = o.z,
                                this._vertices[X++] = o.w;
                            break;

                        case 1:
                            break;

                        default:
                            throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                    }
                }
                return this._firstFreeElement = a, !0;
            }
        }, {
            key: "addNewParticlesToVertexBuffer",
            value: function addNewParticlesToVertexBuffer() {
                var e, t = this._vertexStride * this._floatCountPerVertex * 4;
                this._firstNewElement < this._firstFreeElement ? (e = this._firstNewElement * t,
                        this._vertexBuffer.setData(this._vertices.buffer, e, e, (this._firstFreeElement - this._firstNewElement) * t)) : (e = this._firstNewElement * t,
                        this._vertexBuffer.setData(this._vertices.buffer, e, e, (this._bufferMaxParticles - this._firstNewElement) * t),
                        this._firstFreeElement > 0 && this._vertexBuffer.setData(this._vertices.buffer, 0, 0, this._firstFreeElement * t)),
                    this._firstNewElement = this._firstFreeElement;
            }
        }, {
            key: "_getType",
            value: function _getType() {
                return er._type;
            }
        }, {
            key: "_prepareRender",
            value: function _prepareRender(e) {
                return this._updateEmission(), this._firstNewElement != this._firstFreeElement && this.addNewParticlesToVertexBuffer(),
                    this._drawCounter++, this._firstActiveElement != this._firstFreeElement;
            }
        }, {
            key: "_render",
            value: function _render(e) {
                var r;
                this._bufferState.bind();
                var i = t.LayaGL.instance;
                this._firstActiveElement < this._firstFreeElement ? (r = (this._firstFreeElement - this._firstActiveElement) * this._indexStride,
                    i.drawElements(i.TRIANGLES, r, i.UNSIGNED_SHORT, 2 * this._firstActiveElement * this._indexStride),
                    t.Stat.trianglesFaces += r / 3, t.Stat.renderBatches++) : (r = (this._bufferMaxParticles - this._firstActiveElement) * this._indexStride,
                    i.drawElements(i.TRIANGLES, r, i.UNSIGNED_SHORT, 2 * this._firstActiveElement * this._indexStride),
                    t.Stat.trianglesFaces += r / 3, t.Stat.renderBatches++, this._firstFreeElement > 0 && (r = this._firstFreeElement * this._indexStride,
                        i.drawElements(i.TRIANGLES, r, i.UNSIGNED_SHORT, 0), t.Stat.trianglesFaces += r / 3,
                        t.Stat.renderBatches++));
            }
        }, {
            key: "play",
            value: function play() {
                if (this._burstsIndex = 0, this._isEmitting = !0, this._isPlaying = !0, this._isPaused = !1,
                    this._emissionTime = 0, this._totalDelayTime = 0, !this.autoRandomSeed)
                    for (var e = 0, r = this._randomSeeds.length; e < r; e++) {
                        this._randomSeeds[e] = this.randomSeed[0] + er._RANDOMOFFSET[e];
                    }
                switch (this.startDelayType) {
                    case 0:
                        this._playStartDelay = this.startDelay;
                        break;

                    case 1:
                        this.autoRandomSeed ? this._playStartDelay = t.MathUtil.lerp(this.startDelayMin, this.startDelayMax, Math.random()) : (this._rand.seed = this._randomSeeds[2],
                            this._playStartDelay = t.MathUtil.lerp(this.startDelayMin, this.startDelayMax, this._rand.getFloat()),
                            this._randomSeeds[2] = this._rand.seed);
                        break;

                    default:
                        throw new Error("Utils3D: startDelayType is invalid.");
                }
                this._frameRateTime = this._currentTime + this._playStartDelay, this._startUpdateLoopCount = t.Stat.loopCount;
            }
        }, {
            key: "pause",
            value: function pause() {
                this._isPaused = !0;
            }
        }, {
            key: "simulate",
            value: function simulate(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
                this._simulateUpdate = !0, t ? this._updateParticlesSimulationRestart(e) : (this._isPaused = !1,
                    this._updateParticles(e)), this.pause();
            }
        }, {
            key: "stop",
            value: function stop() {
                this._burstsIndex = 0, this._isEmitting = !1, this._emissionTime = 0;
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t.duration = this.duration, t.looping = this.looping, t.prewarm = this.prewarm,
                    t.startDelayType = this.startDelayType, t.startDelay = this.startDelay, t.startDelayMin = this.startDelayMin,
                    t.startDelayMax = this.startDelayMax, t._maxStartLifetime = this._maxStartLifetime,
                    t.startLifetimeType = this.startLifetimeType, t.startLifetimeConstant = this.startLifetimeConstant,
                    this.startLifeTimeGradient.cloneTo(t.startLifeTimeGradient), t.startLifetimeConstantMin = this.startLifetimeConstantMin,
                    t.startLifetimeConstantMax = this.startLifetimeConstantMax, this.startLifeTimeGradientMin.cloneTo(t.startLifeTimeGradientMin),
                    this.startLifeTimeGradientMax.cloneTo(t.startLifeTimeGradientMax), t.startSpeedType = this.startSpeedType,
                    t.startSpeedConstant = this.startSpeedConstant, t.startSpeedConstantMin = this.startSpeedConstantMin,
                    t.startSpeedConstantMax = this.startSpeedConstantMax, t.threeDStartSize = this.threeDStartSize,
                    t.startSizeType = this.startSizeType, t.startSizeConstant = this.startSizeConstant,
                    this.startSizeConstantSeparate.cloneTo(t.startSizeConstantSeparate), t.startSizeConstantMin = this.startSizeConstantMin,
                    t.startSizeConstantMax = this.startSizeConstantMax, this.startSizeConstantMinSeparate.cloneTo(t.startSizeConstantMinSeparate),
                    this.startSizeConstantMaxSeparate.cloneTo(t.startSizeConstantMaxSeparate), t.threeDStartRotation = this.threeDStartRotation,
                    t.startRotationType = this.startRotationType, t.startRotationConstant = this.startRotationConstant,
                    this.startRotationConstantSeparate.cloneTo(t.startRotationConstantSeparate), t.startRotationConstantMin = this.startRotationConstantMin,
                    t.startRotationConstantMax = this.startRotationConstantMax, this.startRotationConstantMinSeparate.cloneTo(t.startRotationConstantMinSeparate),
                    this.startRotationConstantMaxSeparate.cloneTo(t.startRotationConstantMaxSeparate),
                    t.randomizeRotationDirection = this.randomizeRotationDirection, t.startColorType = this.startColorType,
                    this.startColorConstant.cloneTo(t.startColorConstant), this.startColorConstantMin.cloneTo(t.startColorConstantMin),
                    this.startColorConstantMax.cloneTo(t.startColorConstantMax), t.gravityModifier = this.gravityModifier,
                    t.simulationSpace = this.simulationSpace, t.scaleMode = this.scaleMode, t.playOnAwake = this.playOnAwake,
                    t.autoRandomSeed = this.autoRandomSeed, t.randomSeed[0] = this.randomSeed[0], t.maxParticles = this.maxParticles,
                    this._emission && (t._emission = this._emission.clone()), this.shape && (t.shape = this.shape.clone()),
                    this.velocityOverLifetime && (t.velocityOverLifetime = this.velocityOverLifetime.clone()),
                    this.colorOverLifetime && (t.colorOverLifetime = this.colorOverLifetime.clone()),
                    this.sizeOverLifetime && (t.sizeOverLifetime = this.sizeOverLifetime.clone()), this.rotationOverLifetime && (t.rotationOverLifetime = this.rotationOverLifetime.clone()),
                    this.textureSheetAnimation && (t.textureSheetAnimation = this.textureSheetAnimation.clone()),
                    t.isPerformanceMode = this.isPerformanceMode, t._isEmitting = this._isEmitting,
                    t._isPlaying = this._isPlaying, t._isPaused = this._isPaused, t._playStartDelay = this._playStartDelay,
                    t._frameRateTime = this._frameRateTime, t._emissionTime = this._emissionTime, t._totalDelayTime = this._totalDelayTime,
                    t._burstsIndex = this._burstsIndex;
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new er(null);
                return this.cloneTo(e), e;
            }
        }, {
            key: "maxParticles",
            get: function get() {
                return this._bufferMaxParticles - 1;
            },
            set: function set(e) {
                var t = e + 1;
                t !== this._bufferMaxParticles && (this._bufferMaxParticles = t, this._initBufferDatas());
            }
        }, {
            key: "emission",
            get: function get() {
                return this._emission;
            }
        }, {
            key: "aliveParticleCount",
            get: function get() {
                return this._firstNewElement >= this._firstRetiredElement ? this._firstNewElement - this._firstRetiredElement : this._bufferMaxParticles - this._firstRetiredElement + this._firstNewElement;
            }
        }, {
            key: "emissionTime",
            get: function get() {
                return this._emissionTime > this.duration ? this.duration : this._emissionTime;
            }
        }, {
            key: "shape",
            get: function get() {
                return this._shape;
            },
            set: function set(e) {
                this._shape !== e && (e && e.enable ? this._owner._render._shaderValues.addDefine(kt.SHADERDEFINE_SHAPE) : this._owner._render._shaderValues.removeDefine(kt.SHADERDEFINE_SHAPE),
                    this._shape = e);
            }
        }, {
            key: "isAlive",
            get: function get() {
                return !!(this._isPlaying || this.aliveParticleCount > 0);
            }
        }, {
            key: "isEmitting",
            get: function get() {
                return this._isEmitting;
            }
        }, {
            key: "isPlaying",
            get: function get() {
                return this._isPlaying;
            }
        }, {
            key: "isPaused",
            get: function get() {
                return this._isPaused;
            }
        }, {
            key: "startLifetimeType",
            get: function get() {
                return this._startLifetimeType;
            },
            set: function set(e) {
                var t, r;
                switch (this.startLifetimeType) {
                    case 0:
                        this._maxStartLifetime = this.startLifetimeConstant;
                        break;

                    case 1:
                        this._maxStartLifetime = -Number.MAX_VALUE;
                        var i = i;
                        for (t = 0, r = i.gradientCount; t < r; t++) {
                            this._maxStartLifetime = Math.max(this._maxStartLifetime, i.getValueByIndex(t));
                        }
                        break;

                    case 2:
                        this._maxStartLifetime = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                        break;

                    case 3:
                        this._maxStartLifetime = -Number.MAX_VALUE;
                        var a = a;
                        for (t = 0, r = a.gradientCount; t < r; t++) {
                            this._maxStartLifetime = Math.max(this._maxStartLifetime, a.getValueByIndex(t));
                        }
                        var n = n;
                        for (t = 0, r = n.gradientCount; t < r; t++) {
                            this._maxStartLifetime = Math.max(this._maxStartLifetime, n.getValueByIndex(t));
                        }
                }
                this._startLifetimeType = e;
            }
        }, {
            key: "startLifetimeConstant",
            get: function get() {
                return this._startLifetimeConstant;
            },
            set: function set(e) {
                0 === this._startLifetimeType && (this._maxStartLifetime = e), this._startLifetimeConstant = e;
            }
        }, {
            key: "startLifeTimeGradient",
            get: function get() {
                return this._startLifeTimeGradient;
            },
            set: function set(e) {
                if (1 === this._startLifetimeType) {
                    this._maxStartLifetime = -Number.MAX_VALUE;
                    for (var t = 0, r = e.gradientCount; t < r; t++) {
                        this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
                    }
                }
                this._startLifeTimeGradient = e;
            }
        }, {
            key: "startLifetimeConstantMin",
            get: function get() {
                return this._startLifetimeConstantMin;
            },
            set: function set(e) {
                2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(e, this._startLifetimeConstantMax)),
                    this._startLifetimeConstantMin = e;
            }
        }, {
            key: "startLifetimeConstantMax",
            get: function get() {
                return this._startLifetimeConstantMax;
            },
            set: function set(e) {
                2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(this._startLifetimeConstantMin, e)),
                    this._startLifetimeConstantMax = e;
            }
        }, {
            key: "startLifeTimeGradientMin",
            get: function get() {
                return this._startLifeTimeGradientMin;
            },
            set: function set(e) {
                if (3 === this._startLifetimeType) {
                    var t, r;
                    for (this._maxStartLifetime = -Number.MAX_VALUE, t = 0, r = e.gradientCount; t < r; t++) {
                        this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
                    }
                    for (t = 0, r = this._startLifeTimeGradientMax.gradientCount; t < r; t++) {
                        this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMax.getValueByIndex(t));
                    }
                }
                this._startLifeTimeGradientMin = e;
            }
        }, {
            key: "startLifeTimeGradientMax",
            get: function get() {
                return this._startLifeTimeGradientMax;
            },
            set: function set(e) {
                if (3 === this._startLifetimeType) {
                    var t, r;
                    for (this._maxStartLifetime = -Number.MAX_VALUE, t = 0, r = this._startLifeTimeGradientMin.gradientCount; t < r; t++) {
                        this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMin.getValueByIndex(t));
                    }
                    for (t = 0, r = e.gradientCount; t < r; t++) {
                        this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
                    }
                }
                this._startLifeTimeGradientMax = e;
            }
        }, {
            key: "velocityOverLifetime",
            get: function get() {
                return this._velocityOverLifetime;
            },
            set: function set(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var r = e.velocity,
                        i = r.type;
                    if (e.enable) switch (i) {
                        case 0:
                            t.addDefine(kt.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
                            break;

                        case 1:
                            t.addDefine(kt.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
                            break;

                        case 2:
                            t.addDefine(kt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
                            break;

                        case 3:
                            t.addDefine(kt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                    } else t.removeDefine(kt.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), t.removeDefine(kt.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE),
                        t.removeDefine(kt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), t.removeDefine(kt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                    switch (i) {
                        case 0:
                            t.setVector3(kt.VOLVELOCITYCONST, r.constant);
                            break;

                        case 1:
                            t.setBuffer(kt.VOLVELOCITYGRADIENTX, r.gradientX._elements), t.setBuffer(kt.VOLVELOCITYGRADIENTY, r.gradientY._elements),
                                t.setBuffer(kt.VOLVELOCITYGRADIENTZ, r.gradientZ._elements);
                            break;

                        case 2:
                            t.setVector3(kt.VOLVELOCITYCONST, r.constantMin), t.setVector3(kt.VOLVELOCITYCONSTMAX, r.constantMax);
                            break;

                        case 3:
                            t.setBuffer(kt.VOLVELOCITYGRADIENTX, r.gradientXMin._elements), t.setBuffer(kt.VOLVELOCITYGRADIENTXMAX, r.gradientXMax._elements),
                                t.setBuffer(kt.VOLVELOCITYGRADIENTY, r.gradientYMin._elements), t.setBuffer(kt.VOLVELOCITYGRADIENTYMAX, r.gradientYMax._elements),
                                t.setBuffer(kt.VOLVELOCITYGRADIENTZ, r.gradientZMin._elements), t.setBuffer(kt.VOLVELOCITYGRADIENTZMAX, r.gradientZMax._elements);
                    }
                    t.setInt(kt.VOLSPACETYPE, e.space);
                } else t.removeDefine(kt.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), t.removeDefine(kt.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE),
                    t.removeDefine(kt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), t.removeDefine(kt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                this._velocityOverLifetime = e;
            }
        }, {
            key: "colorOverLifetime",
            get: function get() {
                return this._colorOverLifetime;
            },
            set: function set(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var r = e.color;
                    if (e.enable) switch (r.type) {
                        case 1:
                            t.addDefine(kt.SHADERDEFINE_COLOROVERLIFETIME);
                            break;

                        case 3:
                            t.addDefine(kt.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                    } else t.removeDefine(kt.SHADERDEFINE_COLOROVERLIFETIME), t.removeDefine(kt.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                    switch (r.type) {
                        case 1:
                            var i = r.gradient;
                            t.setBuffer(kt.COLOROVERLIFEGRADIENTALPHAS, i._alphaElements), t.setBuffer(kt.COLOROVERLIFEGRADIENTCOLORS, i._rgbElements);
                            break;

                        case 3:
                            var a = r.gradientMin,
                                n = r.gradientMax;
                            t.setBuffer(kt.COLOROVERLIFEGRADIENTALPHAS, a._alphaElements), t.setBuffer(kt.COLOROVERLIFEGRADIENTCOLORS, a._rgbElements),
                                t.setBuffer(kt.MAXCOLOROVERLIFEGRADIENTALPHAS, n._alphaElements), t.setBuffer(kt.MAXCOLOROVERLIFEGRADIENTCOLORS, n._rgbElements);
                    }
                } else t.removeDefine(kt.SHADERDEFINE_COLOROVERLIFETIME), t.removeDefine(kt.SHADERDEFINE_RANDOMCOLOROVERLIFETIME),
                    t.setBuffer(kt.COLOROVERLIFEGRADIENTALPHAS, i._alphaElements), t.setBuffer(kt.COLOROVERLIFEGRADIENTCOLORS, i._rgbElements),
                    t.setBuffer(kt.COLOROVERLIFEGRADIENTALPHAS, a._alphaElements), t.setBuffer(kt.COLOROVERLIFEGRADIENTCOLORS, a._rgbElements),
                    t.setBuffer(kt.MAXCOLOROVERLIFEGRADIENTALPHAS, n._alphaElements), t.setBuffer(kt.MAXCOLOROVERLIFEGRADIENTCOLORS, n._rgbElements);
                this._colorOverLifetime = e;
            }
        }, {
            key: "sizeOverLifetime",
            get: function get() {
                return this._sizeOverLifetime;
            },
            set: function set(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var r = e.size,
                        i = r.separateAxes,
                        a = r.type;
                    if (e.enable) switch (a) {
                        case 0:
                            i ? t.addDefine(kt.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE) : t.addDefine(kt.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
                            break;

                        case 2:
                            i ? t.addDefine(kt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE) : t.addDefine(kt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
                    } else t.removeDefine(kt.SHADERDEFINE_SIZEOVERLIFETIMECURVE), t.removeDefine(kt.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE),
                        t.removeDefine(kt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), t.removeDefine(kt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                    switch (a) {
                        case 0:
                            i ? (t.setBuffer(kt.SOLSIZEGRADIENTX, r.gradientX._elements), t.setBuffer(kt.SOLSIZEGRADIENTY, r.gradientY._elements),
                                t.setBuffer(kt.SOLSizeGradientZ, r.gradientZ._elements)) : t.setBuffer(kt.SOLSIZEGRADIENT, r.gradient._elements);
                            break;

                        case 2:
                            i ? (t.setBuffer(kt.SOLSIZEGRADIENTX, r.gradientXMin._elements), t.setBuffer(kt.SOLSIZEGRADIENTXMAX, r.gradientXMax._elements),
                                t.setBuffer(kt.SOLSIZEGRADIENTY, r.gradientYMin._elements), t.setBuffer(kt.SOLSIZEGRADIENTYMAX, r.gradientYMax._elements),
                                t.setBuffer(kt.SOLSizeGradientZ, r.gradientZMin._elements), t.setBuffer(kt.SOLSizeGradientZMAX, r.gradientZMax._elements)) : (t.setBuffer(kt.SOLSIZEGRADIENT, r.gradientMin._elements),
                                t.setBuffer(kt.SOLSizeGradientMax, r.gradientMax._elements));
                    }
                } else t.removeDefine(kt.SHADERDEFINE_SIZEOVERLIFETIMECURVE), t.removeDefine(kt.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE),
                    t.removeDefine(kt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), t.removeDefine(kt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                this._sizeOverLifetime = e;
            }
        }, {
            key: "rotationOverLifetime",
            get: function get() {
                return this._rotationOverLifetime;
            },
            set: function set(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var r = e.angularVelocity;
                    if (!r) return;
                    var i = r.separateAxes,
                        a = r.type;
                    if (e.enable) switch (i ? t.addDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE) : t.addDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIME),
                        a) {
                        case 0:
                            t.addDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                            break;

                        case 1:
                            t.addDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                            break;

                        case 2:
                            t.addDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                            break;

                        case 3:
                            t.addDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                    } else t.removeDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIME), t.removeDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE),
                        t.removeDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), t.removeDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE),
                        t.removeDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), t.removeDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                    switch (a) {
                        case 0:
                            i ? t.setVector3(kt.ROLANGULARVELOCITYCONSTSEPRARATE, r.constantSeparate) : t.setNumber(kt.ROLANGULARVELOCITYCONST, r.constant);
                            break;

                        case 1:
                            i ? (t.setBuffer(kt.ROLANGULARVELOCITYGRADIENTX, r.gradientX._elements), t.setBuffer(kt.ROLANGULARVELOCITYGRADIENTY, r.gradientY._elements),
                                t.setBuffer(kt.ROLANGULARVELOCITYGRADIENTZ, r.gradientZ._elements)) : t.setBuffer(kt.ROLANGULARVELOCITYGRADIENT, r.gradient._elements);
                            break;

                        case 2:
                            i ? (t.setVector3(kt.ROLANGULARVELOCITYCONSTSEPRARATE, r.constantMinSeparate), t.setVector3(kt.ROLANGULARVELOCITYCONSTMAXSEPRARATE, r.constantMaxSeparate)) : (t.setNumber(kt.ROLANGULARVELOCITYCONST, r.constantMin),
                                t.setNumber(kt.ROLANGULARVELOCITYCONSTMAX, r.constantMax));
                            break;

                        case 3:
                            i ? (t.setBuffer(kt.ROLANGULARVELOCITYGRADIENTX, r.gradientXMin._elements), t.setBuffer(kt.ROLANGULARVELOCITYGRADIENTXMAX, r.gradientXMax._elements),
                                t.setBuffer(kt.ROLANGULARVELOCITYGRADIENTY, r.gradientYMin._elements), t.setBuffer(kt.ROLANGULARVELOCITYGRADIENTYMAX, r.gradientYMax._elements),
                                t.setBuffer(kt.ROLANGULARVELOCITYGRADIENTZ, r.gradientZMin._elements), t.setBuffer(kt.ROLANGULARVELOCITYGRADIENTZMAX, r.gradientZMax._elements)) : (t.setBuffer(kt.ROLANGULARVELOCITYGRADIENT, r.gradientMin._elements),
                                t.setBuffer(kt.ROLANGULARVELOCITYGRADIENTMAX, r.gradientMax._elements));
                    }
                } else t.removeDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIME), t.removeDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE),
                    t.removeDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), t.removeDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE),
                    t.removeDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), t.removeDefine(kt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                this._rotationOverLifetime = e;
            }
        }, {
            key: "textureSheetAnimation",
            get: function get() {
                return this._textureSheetAnimation;
            },
            set: function set(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var r = e.frame,
                        i = r.type;
                    if (e.enable) switch (i) {
                        case 1:
                            t.addDefine(kt.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
                            break;

                        case 3:
                            t.addDefine(kt.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                    } else t.removeDefine(kt.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), t.removeDefine(kt.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                    if (1 === i || 3 === i) {
                        t.setNumber(kt.TEXTURESHEETANIMATIONCYCLES, e.cycles);
                        var a = e.tiles,
                            n = this._uvLength;
                        n.x = 1 / a.x, n.y = 1 / a.y, t.setVector2(kt.TEXTURESHEETANIMATIONSUBUVLENGTH, this._uvLength);
                    }
                    switch (i) {
                        case 1:
                            t.setBuffer(kt.TEXTURESHEETANIMATIONGRADIENTUVS, r.frameOverTimeData._elements);
                            break;

                        case 3:
                            t.setBuffer(kt.TEXTURESHEETANIMATIONGRADIENTUVS, r.frameOverTimeDataMin._elements),
                                t.setBuffer(kt.TEXTURESHEETANIMATIONGRADIENTMAXUVS, r.frameOverTimeDataMax._elements);
                    }
                } else t.removeDefine(kt.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), t.removeDefine(kt.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                this._textureSheetAnimation = e;
            }
        }]);
        return er;
    }(Pe);
    er._RANDOMOFFSET = new Uint32Array([592910910, 3276756734, 322376503, 306581307, 1793934638, 3737431713, 2527743459, 2368504881, 4085612399, 3774601268, 326370691, 1494990940, 1089181156, 3159510623, 2941263940, 2786374529, 271901988, 4233252447]),
        er.halfKSqrtOf2 = .71, er._maxElapsedTime = 1 / 3, er._tempVector30 = new n(), er._tempVector31 = new n(),
        er._tempVector32 = new n(), er._tempVector33 = new n(), er._tempVector34 = new n(),
        er._tempVector35 = new n(), er._tempVector36 = new n(), er._tempVector37 = new n(),
        er._tempVector38 = new n(), er._tempVector39 = new n(), er._tempPosition = new n(),
        er._tempDirection = new n(), er._type = Pe._typeCounter++;
    var tr = /* */ function(_ye2) {
        _inherits(tr, _ye2);
        _createClass(tr, [{
            key: "particleSystem",
            get: function get() {
                return this._particleSystem;
            }
        }, {
            key: "particleRenderer",
            get: function get() {
                return this._render;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                kt.SHADERDEFINE_RENDERMODE_BILLBOARD = H.getDefineByName("SPHERHBILLBOARD"), kt.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD = H.getDefineByName("STRETCHEDBILLBOARD"),
                    kt.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD = H.getDefineByName("HORIZONTALBILLBOARD"),
                    kt.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD = H.getDefineByName("VERTICALBILLBOARD"),
                    kt.SHADERDEFINE_COLOROVERLIFETIME = H.getDefineByName("COLOROVERLIFETIME"), kt.SHADERDEFINE_RANDOMCOLOROVERLIFETIME = H.getDefineByName("RANDOMCOLOROVERLIFETIME"),
                    kt.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT = H.getDefineByName("VELOCITYOVERLIFETIMECONSTANT"),
                    kt.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE = H.getDefineByName("VELOCITYOVERLIFETIMECURVE"),
                    kt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT = H.getDefineByName("VELOCITYOVERLIFETIMERANDOMCONSTANT"),
                    kt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE = H.getDefineByName("VELOCITYOVERLIFETIMERANDOMCURVE"),
                    kt.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE = H.getDefineByName("TEXTURESHEETANIMATIONCURVE"),
                    kt.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE = H.getDefineByName("TEXTURESHEETANIMATIONRANDOMCURVE"),
                    kt.SHADERDEFINE_ROTATIONOVERLIFETIME = H.getDefineByName("ROTATIONOVERLIFETIME"),
                    kt.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE = H.getDefineByName("ROTATIONOVERLIFETIMESEPERATE"),
                    kt.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT = H.getDefineByName("ROTATIONOVERLIFETIMECONSTANT"),
                    kt.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE = H.getDefineByName("ROTATIONOVERLIFETIMECURVE"),
                    kt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS = H.getDefineByName("ROTATIONOVERLIFETIMERANDOMCONSTANTS"),
                    kt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES = H.getDefineByName("ROTATIONOVERLIFETIMERANDOMCURVES"),
                    kt.SHADERDEFINE_SIZEOVERLIFETIMECURVE = H.getDefineByName("SIZEOVERLIFETIMECURVE"),
                    kt.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE = H.getDefineByName("SIZEOVERLIFETIMECURVESEPERATE"),
                    kt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES = H.getDefineByName("SIZEOVERLIFETIMERANDOMCURVES"),
                    kt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE = H.getDefineByName("SIZEOVERLIFETIMERANDOMCURVESSEPERATE"),
                    kt.SHADERDEFINE_RENDERMODE_MESH = H.getDefineByName("RENDERMODE_MESH"), kt.SHADERDEFINE_SHAPE = H.getDefineByName("SHAPE");
            }
        }]);

        function tr() {
            var _this52;
            _classCallCheck(this, tr);
            _this52 = _possibleConstructorReturn(this, _getPrototypeOf(tr).call(this, null)),
                _this52._render = new Yt(_assertThisInitialized(_this52)), _this52._particleSystem = new er(_assertThisInitialized(_this52));
            var e = _this52._render._renderElements[0] = new st();
            e.setTransform(_this52._transform), e.render = _this52._render, e.setGeometry(_this52._particleSystem),
                e.material = Wt.defaultMaterial;
            return _this52;
        }
        _createClass(tr, [{
            key: "_parseModule",
            value: function _parseModule(e, r) {
                for (var i in r) {
                    switch (i) {
                        case "bases":
                            var a = r.bases;
                            for (var n in a) {
                                e[n] = a[n];
                            }
                            break;

                        case "vector2s":
                            var s = r.vector2s;
                            for (var n in s) {
                                var o = e[n],
                                    l = s[n];
                                o.setValue(l[0], l[1]), e[n] = o;
                            }
                            break;

                        case "vector3s":
                            var _ = r.vector3s;
                            for (var n in _) {
                                var h = e[n],
                                    c = _[n];
                                h.setValue(c[0], c[1], c[2]), e[n] = h;
                            }
                            break;

                        case "vector4s":
                            var d = r.vector4s;
                            for (var n in d) {
                                var u = e[n],
                                    m = d[n];
                                u.setValue(m[0], m[1], m[2], m[3]), e[n] = u;
                            }
                            break;

                        case "gradientDataNumbers":
                            var f = r.gradientDataNumbers;
                            for (var n in f) {
                                for (var E = e[n], T = r[n], p = 0, g = T.length; p < g; p++) {
                                    var S = T[p];
                                    E.add(S.key, S.value);
                                }
                                e[n] = E;
                            }
                            break;

                        case "resources":
                            var R = r.resources;
                            for (var n in R) {
                                e[n] = t.Loader.getRes(R[n]);
                            }
                            break;

                        case "bursts":
                            var v = r.bursts;
                            for (p = 0, g = v.length; p < g; p++) {
                                var x = v[p];
                                e.addBurst(new vt(x.time, x.min, x.max));
                            }
                            break;

                        case "randomSeed":
                            e.randomSeed[0] = r.randomSeed;
                            break;

                        case "shapeType":
                        case "type":
                        case "color":
                        case "size":
                        case "frame":
                        case "startFrame":
                        case "angularVelocity":
                        case "velocity":
                            break;

                        default:
                            throw "ShurikenParticle3D:unknown type.";
                    }
                }
            }
        }, {
            key: "_parse",
            value: function _parse(e, t) {
                if (_get(_getPrototypeOf(tr.prototype), "_parse", this).call(this, e, t), e.main) {
                    var r = this.particleSystem,
                        i = this.particleRenderer;
                    this._parseModule(i, e.renderer), this._parseModule(r, e.main), this._parseModule(r.emission, e.emission);
                    var s = e.shape;
                    if (s) {
                        var o;
                        switch (s.shapeType) {
                            case 0:
                                o = new Bt();
                                break;

                            case 1:
                                o = new Ft();
                                break;

                            case 2:
                                o = new wt();
                                break;

                            case 3:
                                o = new bt();
                                break;

                            case 7:
                                o = new Vt();
                                break;

                            default:
                                throw "ShuriKenParticle3D:unknown shape type.";
                        }
                        this._parseModule(o, s), r.shape = o;
                    }
                    var l = e.velocityOverLifetime;
                    if (l) {
                        var _, h = l.velocity;
                        switch (h.type) {
                            case 0:
                                var c = h.constant;
                                _ = Ct.createByConstant(c ? new n(c[0], c[1], c[2]) : new n(0, 0, 0));
                                break;

                            case 1:
                                _ = Ct.createByGradient(this._initParticleVelocity(h.gradientX), this._initParticleVelocity(h.gradientY), this._initParticleVelocity(h.gradientZ));
                                break;

                            case 2:
                                var d = h.constantMin,
                                    u = h.constantMax;
                                _ = Ct.createByRandomTwoConstant(d ? new n(d[0], d[1], d[2]) : new n(0, 0, 0), u ? new n(u[0], u[1], u[2]) : new n(0, 0, 0));
                                break;

                            case 3:
                                _ = Ct.createByRandomTwoGradient(this._initParticleVelocity(h.gradientXMin), this._initParticleVelocity(h.gradientXMax), this._initParticleVelocity(h.gradientYMin), this._initParticleVelocity(h.gradientYMax), this._initParticleVelocity(h.gradientZMin), this._initParticleVelocity(h.gradientZMax));
                        }
                        var m = new Ht(_);
                        this._parseModule(m, l), r.velocityOverLifetime = m;
                    }
                    var f = e.colorOverLifetime;
                    if (f) {
                        var E, T = f.color;
                        switch (T.type) {
                            case 0:
                                var p = T.constant;
                                E = xt.createByConstant(p ? new a(p[0], p[1], p[2], p[3]) : new a(0, 0, 0, 0));
                                break;

                            case 1:
                                E = xt.createByGradient(this._initParticleColor(T.gradient));
                                break;

                            case 2:
                                var g = T.constantMin,
                                    S = T.constantMax;
                                E = xt.createByRandomTwoConstant(g ? new a(g[0], g[1], g[2], g[3]) : new a(0, 0, 0, 0), g ? new a(S[0], S[1], S[2], S[3]) : new a(0, 0, 0, 0));
                                break;

                            case 3:
                                E = xt.createByRandomTwoGradient(this._initParticleColor(T.gradientMin), this._initParticleColor(T.gradientMax));
                        }
                        var R = new It(E);
                        this._parseModule(R, f), r.colorOverLifetime = R;
                    }
                    var v = e.sizeOverLifetime;
                    if (v) {
                        var x, I = v.size;
                        switch (I.type) {
                            case 0:
                                x = I.separateAxes ? yt.createByGradientSeparate(this._initParticleSize(I.gradientX), this._initParticleSize(I.gradientY), this._initParticleSize(I.gradientZ)) : yt.createByGradient(this._initParticleSize(I.gradient));
                                break;

                            case 1:
                                if (I.separateAxes) {
                                    var A = I.constantMinSeparate,
                                        M = I.constantMaxSeparate;
                                    x = yt.createByRandomTwoConstantSeparate(A ? new n(A[0], A[1], A[2]) : new n(0, 0, 0), M ? new n(M[0], M[1], M[2]) : new n(0, 0, 0));
                                } else x = yt.createByRandomTwoConstant(I.constantMin || 0, I.constantMax || 0);
                                break;

                            case 2:
                                x = I.separateAxes ? yt.createByRandomTwoGradientSeparate(this._initParticleSize(I.gradientXMin), this._initParticleSize(I.gradientYMin), this._initParticleSize(I.gradientZMin), this._initParticleSize(I.gradientXMax), this._initParticleSize(I.gradientYMax), this._initParticleSize(I.gradientZMax)) : yt.createByRandomTwoGradient(this._initParticleSize(I.gradientMin), this._initParticleSize(I.gradientMax));
                        }
                        var D = new Ut(x);
                        this._parseModule(D, v), r.sizeOverLifetime = D;
                    }
                    var L = e.rotationOverLifetime;
                    if (L) {
                        var y, C = L.angularVelocity;
                        switch (C.type) {
                            case 0:
                                if (C.separateAxes) {
                                    var O = C.constantSeparate;
                                    y = Mt.createByConstantSeparate(O ? new n(O[0], O[1], O[2]) : new n(0, 0, Math.PI / 4));
                                } else y = Mt.createByConstant(C.constant || Math.PI / 4);
                                break;

                            case 1:
                                y = C.separateAxes ? Mt.createByGradientSeparate(this._initParticleRotation(C.gradientX), this._initParticleRotation(C.gradientY), this._initParticleRotation(C.gradientZ)) : Mt.createByGradient(this._initParticleRotation(C.gradient));
                                break;

                            case 2:
                                if (C.separateAxes) {
                                    var N = C.constantMinSeparate,
                                        P = C.constantMaxSeparate;
                                    y = Mt.createByRandomTwoConstantSeparate(N ? new n(N[0], N[1], N[2]) : new n(0, 0, 0), P ? new n(P[0], P[1], P[2]) : new n(0, 0, Math.PI / 4));
                                } else y = Mt.createByRandomTwoConstant(C.constantMin || 0, C.constantMax || Math.PI / 4);
                                break;

                            case 3:
                                C.separateAxes || (y = Mt.createByRandomTwoGradient(this._initParticleRotation(C.gradientMin), this._initParticleRotation(C.gradientMax)));
                        }
                        var b = new Ot(y);
                        this._parseModule(b, L), r.rotationOverLifetime = b;
                    }
                    var V = e.textureSheetAnimation;
                    if (V) {
                        var w, F = V.frame;
                        switch (F.type) {
                            case 0:
                                w = At.createByConstant(F.constant);
                                break;

                            case 1:
                                w = At.createByOverTime(this._initParticleFrame(F.overTime));
                                break;

                            case 2:
                                w = At.createByRandomTwoConstant(F.constantMin, F.constantMax);
                                break;

                            case 3:
                                w = At.createByRandomTwoOverTime(this._initParticleFrame(F.overTimeMin), this._initParticleFrame(F.overTimeMax));
                        }
                        var B, U = V.startFrame;
                        switch (U.type) {
                            case 0:
                                B = Gt.createByConstant(U.constant);
                                break;

                            case 1:
                                B = Gt.createByRandomTwoConstant(U.constantMin, U.constantMax);
                        }
                        var G = new zt(w, B);
                        this._parseModule(G, V), r.textureSheetAnimation = G;
                    }
                } else this._parseOld(e);
            }
        }, {
            key: "_activeHierarchy",
            value: function _activeHierarchy(e) {
                _get(_getPrototypeOf(tr.prototype), "_activeHierarchy", this).call(this, e), this.particleSystem.playOnAwake && this.particleSystem.play();
            }
        }, {
            key: "_inActiveHierarchy",
            value: function _inActiveHierarchy(e) {
                _get(_getPrototypeOf(tr.prototype), "_inActiveHierarchy", this).call(this, e), this.particleSystem.isAlive && this.particleSystem.simulate(0, !0);
            }
        }, {
            key: "_cloneTo",
            value: function _cloneTo(e, t, r) {
                var i = e,
                    a = i._particleSystem;
                this._particleSystem.cloneTo(a);
                var n = i._render,
                    s = this._render;
                n.sharedMaterials = s.sharedMaterials, n.enable = s.enable, n.renderMode = s.renderMode,
                    n.mesh = s.mesh, n.stretchedBillboardCameraSpeedScale = s.stretchedBillboardCameraSpeedScale,
                    n.stretchedBillboardSpeedScale = s.stretchedBillboardSpeedScale, n.stretchedBillboardLengthScale = s.stretchedBillboardLengthScale,
                    n.sortingFudge = s.sortingFudge, _get(_getPrototypeOf(tr.prototype), "_cloneTo", this).call(this, e, t, r);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
                this.destroyed || (_get(_getPrototypeOf(tr.prototype), "destroy", this).call(this, e),
                    this._particleSystem.destroy(), this._particleSystem = null);
            }
        }, {
            key: "_create",
            value: function _create() {
                return new tr();
            }
        }, {
            key: "_parseOld",
            value: function _parseOld(e) {
                var r = Math.PI / 180;
                var s, o, l, _ = this.particleRenderer,
                    h = e.material;
                h && (l = t.Loader.getRes(h.path)), _.sharedMaterial = l;
                var c = e.meshPath;
                c && (_.mesh = t.Loader.getRes(c)), _.renderMode = e.renderMode, _.stretchedBillboardCameraSpeedScale = e.stretchedBillboardCameraSpeedScale,
                    _.stretchedBillboardSpeedScale = e.stretchedBillboardSpeedScale, _.stretchedBillboardLengthScale = e.stretchedBillboardLengthScale,
                    _.sortingFudge = e.sortingFudge ? e.sortingFudge : 0;
                var d = this.particleSystem;
                d.isPerformanceMode = e.isPerformanceMode, d.duration = e.duration, d.looping = e.looping,
                    d.prewarm = e.prewarm, d.startDelayType = e.startDelayType, d.startDelay = e.startDelay,
                    d.startDelayMin = e.startDelayMin, d.startDelayMax = e.startDelayMax, d.startLifetimeType = e.startLifetimeType,
                    d.startLifetimeConstant = e.startLifetimeConstant, d.startLifeTimeGradient = tr._initStartLife(e.startLifetimeGradient),
                    d.startLifetimeConstantMin = e.startLifetimeConstantMin, d.startLifetimeConstantMax = e.startLifetimeConstantMax,
                    d.startLifeTimeGradientMin = tr._initStartLife(e.startLifetimeGradientMin), d.startLifeTimeGradientMax = tr._initStartLife(e.startLifetimeGradientMax),
                    d.startSpeedType = e.startSpeedType, d.startSpeedConstant = e.startSpeedConstant,
                    d.startSpeedConstantMin = e.startSpeedConstantMin, d.startSpeedConstantMax = e.startSpeedConstantMax,
                    d.threeDStartSize = e.threeDStartSize, d.startSizeType = e.startSizeType, d.startSizeConstant = e.startSizeConstant;
                var u = e.startSizeConstantSeparate,
                    m = d.startSizeConstantSeparate;
                m.x = u[0], m.y = u[1], m.z = u[2], d.startSizeConstantMin = e.startSizeConstantMin,
                    d.startSizeConstantMax = e.startSizeConstantMax;
                var f = e.startSizeConstantMinSeparate,
                    E = d.startSizeConstantMinSeparate;
                E.x = f[0], E.y = f[1], E.z = f[2];
                var T = e.startSizeConstantMaxSeparate,
                    p = d.startSizeConstantMaxSeparate;
                p.x = T[0], p.y = T[1], p.z = T[2], d.threeDStartRotation = e.threeDStartRotation,
                    d.startRotationType = e.startRotationType, d.startRotationConstant = e.startRotationConstant * r;
                var g = e.startRotationConstantSeparate,
                    S = d.startRotationConstantSeparate;
                S.x = g[0] * r, S.y = g[1] * r, S.z = g[2] * r, d.startRotationConstantMin = e.startRotationConstantMin * r,
                    d.startRotationConstantMax = e.startRotationConstantMax * r;
                var R = e.startRotationConstantMinSeparate,
                    v = d.startRotationConstantMinSeparate;
                v.x = R[0] * r, v.y = R[1] * r, v.z = R[2] * r;
                var x = e.startRotationConstantMaxSeparate,
                    I = d.startRotationConstantMaxSeparate;
                I.x = x[0] * r, I.y = x[1] * r, I.z = x[2] * r, d.randomizeRotationDirection = e.randomizeRotationDirection,
                    d.startColorType = e.startColorType;
                var A = e.startColorConstant,
                    M = d.startColorConstant;
                M.x = A[0], M.y = A[1], M.z = A[2], M.w = A[3];
                var D = e.startColorConstantMin,
                    L = d.startColorConstantMin;
                L.x = D[0], L.y = D[1], L.z = D[2], L.w = D[3];
                var y = e.startColorConstantMax,
                    C = d.startColorConstantMax;
                C.x = y[0], C.y = y[1], C.z = y[2], C.w = y[3], d.gravityModifier = e.gravityModifier,
                    d.simulationSpace = e.simulationSpace, void 0 !== e.simulationSpeed && (d.simulationSpeed = e.simulationSpeed),
                    d.scaleMode = e.scaleMode, d.playOnAwake = e.playOnAwake, d.maxParticles = e.maxParticles;
                var O = e.autoRandomSeed;
                null != O && (d.autoRandomSeed = O);
                var N = e.randomSeed;
                null != N && (d.randomSeed[0] = N);
                var P = e.emission,
                    b = d.emission;
                if (P) {
                    b.emissionRate = P.emissionRate;
                    var V = P.bursts;
                    if (V)
                        for (s = 0, o = V.length; s < o; s++) {
                            var w = V[s];
                            b.addBurst(new vt(w.time, w.min, w.max));
                        }
                    b.enable = P.enable;
                } else b.enable = !1;
                var F = e.shape;
                if (F) {
                    var B;
                    switch (F.shapeType) {
                        case 0:
                            var U;
                            B = U = new Bt(), U.radius = F.sphereRadius, U.emitFromShell = F.sphereEmitFromShell,
                                U.randomDirection = F.sphereRandomDirection;
                            break;

                        case 1:
                            var G;
                            B = G = new Ft(), G.radius = F.hemiSphereRadius, G.emitFromShell = F.hemiSphereEmitFromShell,
                                G.randomDirection = F.hemiSphereRandomDirection;
                            break;

                        case 2:
                            var z;
                            B = z = new wt(), z.angle = F.coneAngle * r, z.radius = F.coneRadius, z.length = F.coneLength,
                                z.emitType = F.coneEmitType, z.randomDirection = F.coneRandomDirection;
                            break;

                        case 3:
                            var H;
                            B = H = new bt(), H.x = F.boxX, H.y = F.boxY, H.z = F.boxZ, H.randomDirection = F.boxRandomDirection;
                            break;

                        case 7:
                            var k;
                            B = k = new Vt(), k.radius = F.circleRadius, k.arc = F.circleArc * r, k.emitFromEdge = F.circleEmitFromEdge,
                                k.randomDirection = F.circleRandomDirection;
                            break;

                        default:
                            var W;
                            B = W = new Vt(), W.radius = F.circleRadius, W.arc = F.circleArc * r, W.emitFromEdge = F.circleEmitFromEdge,
                                W.randomDirection = F.circleRandomDirection;
                    }
                    B.enable = F.enable, d.shape = B;
                }
                var X = e.velocityOverLifetime;
                if (X) {
                    var Y, Z = X.velocity;
                    switch (Z.type) {
                        case 0:
                            var j = Z.constant;
                            Y = Ct.createByConstant(new n(j[0], j[1], j[2]));
                            break;

                        case 1:
                            Y = Ct.createByGradient(this._initParticleVelocity(Z.gradientX), this._initParticleVelocity(Z.gradientY), this._initParticleVelocity(Z.gradientZ));
                            break;

                        case 2:
                            var q = Z.constantMin,
                                Q = Z.constantMax;
                            Y = Ct.createByRandomTwoConstant(new n(q[0], q[1], q[2]), new n(Q[0], Q[1], Q[2]));
                            break;

                        case 3:
                            Y = Ct.createByRandomTwoGradient(this._initParticleVelocity(Z.gradientXMin), this._initParticleVelocity(Z.gradientXMax), this._initParticleVelocity(Z.gradientYMin), this._initParticleVelocity(Z.gradientYMax), this._initParticleVelocity(Z.gradientZMin), this._initParticleVelocity(Z.gradientZMax));
                    }
                    var K = new Ht(Y);
                    K.space = X.space, K.enable = X.enable, d.velocityOverLifetime = K;
                }
                var J = e.colorOverLifetime;
                if (J) {
                    var $, ee = J.color;
                    switch (ee.type) {
                        case 0:
                            var te = ee.constant;
                            $ = xt.createByConstant(new a(te[0], te[1], te[2], te[3]));
                            break;

                        case 1:
                            $ = xt.createByGradient(this._initParticleColor(ee.gradient));
                            break;

                        case 2:
                            var re = ee.constantMin,
                                ie = ee.constantMax;
                            $ = xt.createByRandomTwoConstant(new a(re[0], re[1], re[2], re[3]), new a(ie[0], ie[1], ie[2], ie[3]));
                            break;

                        case 3:
                            $ = xt.createByRandomTwoGradient(this._initParticleColor(ee.gradientMin), this._initParticleColor(ee.gradientMax));
                    }
                    var ae = new It($);
                    ae.enable = J.enable, d.colorOverLifetime = ae;
                }
                var ne = e.sizeOverLifetime;
                if (ne) {
                    var se, oe = ne.size;
                    switch (oe.type) {
                        case 0:
                            se = oe.separateAxes ? yt.createByGradientSeparate(this._initParticleSize(oe.gradientX), this._initParticleSize(oe.gradientY), this._initParticleSize(oe.gradientZ)) : yt.createByGradient(this._initParticleSize(oe.gradient));
                            break;

                        case 1:
                            if (oe.separateAxes) {
                                var le = oe.constantMinSeparate,
                                    _e = oe.constantMaxSeparate;
                                se = yt.createByRandomTwoConstantSeparate(new n(le[0], le[1], le[2]), new n(_e[0], _e[1], _e[2]));
                            } else se = yt.createByRandomTwoConstant(oe.constantMin, oe.constantMax);
                            break;

                        case 2:
                            se = oe.separateAxes ? yt.createByRandomTwoGradientSeparate(this._initParticleSize(oe.gradientXMin), this._initParticleSize(oe.gradientYMin), this._initParticleSize(oe.gradientZMin), this._initParticleSize(oe.gradientXMax), this._initParticleSize(oe.gradientYMax), this._initParticleSize(oe.gradientZMax)) : yt.createByRandomTwoGradient(this._initParticleSize(oe.gradientMin), this._initParticleSize(oe.gradientMax));
                    }
                    var he = new Ut(se);
                    he.enable = ne.enable, d.sizeOverLifetime = he;
                }
                var ce = e.rotationOverLifetime;
                if (ce) {
                    var de, ue = ce.angularVelocity;
                    switch (ue.type) {
                        case 0:
                            if (ue.separateAxes) {
                                var me = ue.constantSeparate;
                                de = Mt.createByConstantSeparate(new n(me[0] * r, me[1] * r, me[2] * r));
                            } else de = Mt.createByConstant(ue.constant * r);
                            break;

                        case 1:
                            de = ue.separateAxes ? Mt.createByGradientSeparate(this._initParticleRotation(ue.gradientX), this._initParticleRotation(ue.gradientY), this._initParticleRotation(ue.gradientZ)) : Mt.createByGradient(this._initParticleRotation(ue.gradient));
                            break;

                        case 2:
                            if (ue.separateAxes) {
                                var fe = ue.constantMinSeparate,
                                    Ee = ue.constantMaxSeparate;
                                de = Mt.createByRandomTwoConstantSeparate(new n(fe[0] * r, fe[1] * r, fe[2] * r), new n(Ee[0] * r, Ee[1] * r, Ee[2] * r));
                            } else de = Mt.createByRandomTwoConstant(ue.constantMin * r, ue.constantMax * r);
                            break;

                        case 3:
                            ue.separateAxes || (de = Mt.createByRandomTwoGradient(this._initParticleRotation(ue.gradientMin), this._initParticleRotation(ue.gradientMax)));
                    }
                    var Te = new Ot(de);
                    Te.enable = ce.enable, d.rotationOverLifetime = Te;
                }
                var pe = e.textureSheetAnimation;
                if (pe) {
                    var ge, Se = pe.frame;
                    switch (Se.type) {
                        case 0:
                            ge = At.createByConstant(Se.constant);
                            break;

                        case 1:
                            ge = At.createByOverTime(this._initParticleFrame(Se.overTime));
                            break;

                        case 2:
                            ge = At.createByRandomTwoConstant(Se.constantMin, Se.constantMax);
                            break;

                        case 3:
                            ge = At.createByRandomTwoOverTime(this._initParticleFrame(Se.overTimeMin), this._initParticleFrame(Se.overTimeMax));
                    }
                    var Re, ve = pe.startFrame;
                    switch (ve.type) {
                        case 0:
                            Re = Gt.createByConstant(ve.constant);
                            break;

                        case 1:
                            Re = Gt.createByRandomTwoConstant(ve.constantMin, ve.constantMax);
                    }
                    var xe = new zt(ge, Re);
                    xe.enable = pe.enable;
                    var Ie = pe.tiles;
                    xe.tiles = new i(Ie[0], Ie[1]), xe.type = pe.type, xe.randomRow = pe.randomRow;
                    var Ae = pe.rowIndex;
                    void 0 !== Ae && (xe.rowIndex = Ae), xe.cycles = pe.cycles, d.textureSheetAnimation = xe;
                }
            }
        }, {
            key: "_initParticleColor",
            value: function _initParticleColor(e) {
                var t = new Rt(4, 4);
                if (e) {
                    var r, i, a = e.alphas;
                    if (a)
                        for (r = 0, i = a.length; r < i; r++) {
                            3 == r && i > 4 && (r = i - 1, console.warn("GradientDataColor warning:alpha data length is large than 4, will ignore the middle data."));
                            var n = a[r];
                            t.addColorAlpha(n.key, n.value);
                        } else t.addColorAlpha(0, 1), t.addColorAlpha(1, 1);
                    var s = e.rgbs;
                    if (s)
                        for (r = 0, i = s.length; r < i; r++) {
                            3 == r && i > 4 && (r = i - 1, console.warn("GradientDataColor warning:rgb data length is large than 4, will ignore the middle data."));
                            var o = s[r],
                                l = o.value;
                            t.addColorRGB(o.key, new Ae(l[0], l[1], l[2], 1));
                        } else t.addColorRGB(0, new Ae(1, 1, 1, 1)), t.addColorRGB(1, new Ae(1, 1, 1, 1));
                } else t.addColorAlpha(0, 1), t.addColorAlpha(1, 1), t.addColorRGB(0, new Ae(1, 1, 1, 1)),
                    t.addColorRGB(1, new Ae(1, 1, 1, 1));
                return t;
            }
        }, {
            key: "_initParticleFrame",
            value: function _initParticleFrame(e) {
                var t = new Dt();
                if (e)
                    for (var r = e.frames, i = 0, a = r.length; i < a; i++) {
                        var n = r[i];
                        t.add(n.key, n.value);
                    } else t.add(0, 0), t.add(1, 1);
                return t;
            }
        }, {
            key: "_initParticleVelocity",
            value: function _initParticleVelocity(e) {
                for (var t = new Lt(), r = e.velocitys, i = 0, a = r.length; i < a; i++) {
                    var n = r[i];
                    t.add(n.key, n.value);
                }
                return t;
            }
        }, {
            key: "_initParticleSize",
            value: function _initParticleSize(e) {
                var t = new Lt();
                if (e)
                    for (var r = e.sizes, i = 0, a = r.length; i < a; i++) {
                        var n = r[i];
                        t.add(n.key, n.value);
                    } else t.add(0, 0), t.add(1, 1);
                return t;
            }
        }, {
            key: "_initParticleRotation",
            value: function _initParticleRotation(e) {
                for (var t = new Lt(), r = e.angularVelocitys, i = 0, a = r.length; i < a; i++) {
                    var n = r[i];
                    t.add(n.key, n.value / 180 * Math.PI);
                }
                return t;
            }
        }], [{
            key: "_initStartLife",
            value: function _initStartLife(e) {
                for (var t = new Lt(), r = e.startLifetimes, i = 0, a = r.length; i < a; i++) {
                    var n = r[i];
                    t.add(n.key, n.value);
                }
                return t;
            }
        }]);
        return tr;
    }(ye);
    var rr = /* */ function(_j10) {
        _inherits(rr, _j10);

        function rr() {
            var _this53;
            _classCallCheck(this, rr);
            _this53 = _possibleConstructorReturn(this, _getPrototypeOf(rr).call(this)), _this53.setShaderName("LineShader"),
                _this53._shaderValues.setVector(rr.COLOR, new a(1, 1, 1, 1));
            return _this53;
        }
        _createClass(rr, [{
            key: "clone",
            value: function clone() {
                var e = new rr();
                return this.cloneTo(e), e;
            }
        }, {
            key: "color",
            get: function get() {
                return this._shaderValues.getVector(rr.COLOR);
            },
            set: function set(e) {
                this._shaderValues.setVector(rr.COLOR, e);
            }
        }, {
            key: "depthWrite",
            set: function set(e) {
                this._shaderValues.setBool(rr.DEPTH_WRITE, e);
            },
            get: function get() {
                return this._shaderValues.getBool(rr.DEPTH_WRITE);
            }
        }, {
            key: "cull",
            set: function set(e) {
                this._shaderValues.setInt(rr.CULL, e);
            },
            get: function get() {
                return this._shaderValues.getInt(rr.CULL);
            }
        }, {
            key: "blend",
            set: function set(e) {
                this._shaderValues.setInt(rr.BLEND, e);
            },
            get: function get() {
                return this._shaderValues.getInt(rr.BLEND);
            }
        }, {
            key: "blendSrc",
            set: function set(e) {
                this._shaderValues.setInt(rr.BLEND_SRC, e);
            },
            get: function get() {
                return this._shaderValues.getInt(rr.BLEND_SRC);
            }
        }, {
            key: "blendDst",
            set: function set(e) {
                this._shaderValues.setInt(rr.BLEND_DST, e);
            },
            get: function get() {
                return this._shaderValues.getInt(rr.BLEND_DST);
            }
        }, {
            key: "depthTest",
            set: function set(e) {
                this._shaderValues.setInt(rr.DEPTH_TEST, e);
            },
            get: function get() {
                return this._shaderValues.getInt(rr.DEPTH_TEST);
            }
        }], [{
            key: "__initDefine__",
            value: function __initDefine__() {}
        }]);
        return rr;
    }(j);
    rr.COLOR = H.propertyNameToID("u_Color"), rr.CULL = H.propertyNameToID("s_Cull"),
        rr.BLEND = H.propertyNameToID("s_Blend"), rr.BLEND_SRC = H.propertyNameToID("s_BlendSrc"),
        rr.BLEND_DST = H.propertyNameToID("s_BlendDst"), rr.DEPTH_TEST = H.propertyNameToID("s_DepthTest"),
        rr.DEPTH_WRITE = H.propertyNameToID("s_DepthWrite");
    var ir = /* */ function() {
        _createClass(ir, [{
            key: "vertexDeclaration",
            get: function get() {
                return ir._vertexDeclaration;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                ir._vertexDeclaration = new _e(28, [new he(0, le.Vector3, ce.MESH_POSITION0), new he(12, le.Vector4, ce.MESH_COLOR0)]);
            }
        }, {
            key: "vertexDeclaration",
            get: function get() {
                return ir._vertexDeclaration;
            }
        }]);

        function ir() {
            _classCallCheck(this, ir);
        }
        return ir;
    }();
    var ar = /* */ function(_t2) {
        _inherits(ar, _t2);

        function ar() {
            _classCallCheck(this, ar);
            return _possibleConstructorReturn(this, _getPrototypeOf(ar).call(this));
        }
        _createClass(ar, [{
            key: "add",
            value: function add(e) {
                e._getIndexInList();
                this._add(e), e._setIndexInList(this.length++);
            }
        }, {
            key: "remove",
            value: function remove(e) {
                var t = e._getIndexInList();
                if (this.length--, t !== this.length) {
                    var r = this.elements[this.length];
                    r && (this.elements[t] = r, r._setIndexInList(t));
                }
                e._setIndexInList(-1);
            }
        }, {
            key: "clear",
            value: function clear() {
                for (var e, t = this.elements, r = this.length; e < r; e++) {
                    t[e]._setIndexInList(-1);
                }
                this.length = 0;
            }
        }]);
        return ar;
    }(_t);
    var nr = /* */ function() {
        function nr() {
            _classCallCheck(this, nr);
            this._coefficients = new Float32Array(27);
        }
        _createClass(nr, [{
            key: "getCoefficient",
            value: function getCoefficient(e, t) {
                return this._coefficients[9 * e + t];
            }
        }, {
            key: "setCoefficient",
            value: function setCoefficient(e, t, r) {
                this._coefficients[9 * e + t] = r;
            }
        }, {
            key: "setCoefficients",
            value: function setCoefficients(e, t, r, i, a, n, s, o, l, _) {
                var h = 9 * e;
                this._coefficients[h] = t, this._coefficients[++h] = r, this._coefficients[++h] = i,
                    this._coefficients[++h] = a, this._coefficients[++h] = n, this._coefficients[++h] = s,
                    this._coefficients[++h] = o, this._coefficients[++h] = l, this._coefficients[++h] = _;
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                if (this !== e)
                    for (var t = this._coefficients, r = e._coefficients, i = 0; i < 27; i++) {
                        r[i] = t[i];
                    }
            }
        }]);
        return nr;
    }();
    nr._default = new nr();
    var sr = function sr() {
        _classCallCheck(this, sr);
        this._pressedSprite = null, this._pressedLoopCount = -1, this.sprite = null, this.mousePositionX = 0,
            this.mousePositionY = 0;
    };
    var or = /* */ function() {
        function or() {
            _classCallCheck(this, or);
            this._indexInList = -1, this._identifier = -1, this._position = new i();
        }
        _createClass(or, [{
            key: "_getIndexInList",
            value: function _getIndexInList() {
                return this._indexInList;
            }
        }, {
            key: "_setIndexInList",
            value: function _setIndexInList(e) {
                this._indexInList = e;
            }
        }, {
            key: "identifier",
            get: function get() {
                return this._identifier;
            }
        }, {
            key: "position",
            get: function get() {
                return this._position;
            }
        }]);
        return or;
    }();
    var lr = function lr() {
        _classCallCheck(this, lr);
        this.succeeded = !1, this.collider = null, this.point = new n(), this.normal = new n(),
            this.hitFraction = 0;
    };
    var _r = /* */ function(_t3) {
        _inherits(_r, _t3);

        function _r() {
            _classCallCheck(this, _r);
            return _possibleConstructorReturn(this, _getPrototypeOf(_r).call(this));
        }
        _createClass(_r, [{
            key: "add",
            value: function add(e) {
                if (-1 !== e._inPhysicUpdateListIndex) throw "PhysicsUpdateList:element has  in  PhysicsUpdateList.";
                this._add(e), e._inPhysicUpdateListIndex = this.length++;
            }
        }, {
            key: "remove",
            value: function remove(e) {
                var t = e._inPhysicUpdateListIndex;
                if (this.length--, t !== this.length) {
                    var r = this.elements[this.length];
                    this.elements[t] = r, r._inPhysicUpdateListIndex = t;
                }
                e._inPhysicUpdateListIndex = -1;
            }
        }]);
        return _r;
    }(_t);
    var hr = function hr() {
        _classCallCheck(this, hr);
        this._idCounter = 0, this.colliderA = null, this.colliderB = null, this.distance = 0,
            this.normal = new n(), this.positionOnA = new n(), this.positionOnB = new n(), this._id = ++this._idCounter;
    };
    var cr = /* */ function() {
        function cr() {
            _classCallCheck(this, cr);
            this._lastUpdateFrame = -2147483648, this._updateFrame = -2147483648, this._isTrigger = !1,
                this.contacts = [];
        }
        _createClass(cr, [{
            key: "_setUpdateFrame",
            value: function _setUpdateFrame(e) {
                this._lastUpdateFrame = this._updateFrame, this._updateFrame = e;
            }
        }]);
        return cr;
    }();
    var dr = /* */ function() {
        function dr() {
            _classCallCheck(this, dr);
            this._hitResultsPoolIndex = 0, this._hitResultsPool = [], this._contactPonintsPoolIndex = 0,
                this._contactPointsPool = [], this._collisionsPool = [], this._collisions = {};
        }
        _createClass(dr, [{
            key: "getHitResult",
            value: function getHitResult() {
                var e = this._hitResultsPool[this._hitResultsPoolIndex++];
                return e || (e = new lr(), this._hitResultsPool.push(e)), e;
            }
        }, {
            key: "recoverAllHitResultsPool",
            value: function recoverAllHitResultsPool() {
                this._hitResultsPoolIndex = 0;
            }
        }, {
            key: "getContactPoints",
            value: function getContactPoints() {
                var e = this._contactPointsPool[this._contactPonintsPoolIndex++];
                return e || (e = new hr(), this._contactPointsPool.push(e)), e;
            }
        }, {
            key: "recoverAllContactPointsPool",
            value: function recoverAllContactPointsPool() {
                this._contactPonintsPoolIndex = 0;
            }
        }, {
            key: "getCollision",
            value: function getCollision(e, t) {
                var r, i = e.id,
                    a = t.id,
                    n = this._collisions[i];
                return n && (r = n[a]), r || (n || (n = {}, this._collisions[i] = n), (r = 0 === this._collisionsPool.length ? new cr() : this._collisionsPool.pop())._colliderA = e,
                    r._colliderB = t, n[a] = r), r;
            }
        }, {
            key: "recoverCollision",
            value: function recoverCollision(e) {
                var t = e._colliderA.id,
                    r = e._colliderB.id;
                this._collisions[t][r] = null, this._collisionsPool.push(e);
            }
        }, {
            key: "garbageCollection",
            value: function garbageCollection() {
                for (var e in this._hitResultsPoolIndex = 0, this._hitResultsPool.length = 0, this._contactPonintsPoolIndex = 0,
                        this._contactPointsPool.length = 0, this._collisionsPool.length = 0, this._collisionsPool) {
                    var t = this._collisionsPool[e],
                        r = !0;
                    for (var i in t) {
                        t[i] ? r = !1 : delete t[i];
                    }
                    r && delete this._collisionsPool[e];
                }
            }
        }]);
        return dr;
    }();
    var ur = /* */ function() {
        function ur() {
            _classCallCheck(this, ur);
            this._scale = new n(1, 1, 1), this._centerMatrix = new C(), this._attatched = !1,
                this._indexInCompound = -1, this._compoundParent = null, this._attatchedCollisionObject = null,
                this._referenceCount = 0, this._localOffset = new n(0, 0, 0), this._localRotation = new f(0, 0, 0, 1),
                this.needsCustomCollisionCallback = !1;
        }
        _createClass(ur, [{
            key: "_setScale",
            value: function _setScale(e) {
                if (this._compoundParent) this.updateLocalTransformations();
                else {
                    var t = x._bullet;
                    t.btVector3_setValue(ur._btScale, e.x, e.y, e.z), t.btCollisionShape_setLocalScaling(this._btShape, ur._btScale);
                }
            }
        }, {
            key: "_addReference",
            value: function _addReference() {
                this._referenceCount++;
            }
        }, {
            key: "_removeReference",
            value: function _removeReference() {
                this._referenceCount--;
            }
        }, {
            key: "updateLocalTransformations",
            value: function updateLocalTransformations() {
                if (this._compoundParent) {
                    var e = ur._tempVector30;
                    n.multiply(this.localOffset, this._scale, e), ur._createAffineTransformation(e, this.localRotation, this._centerMatrix.elements);
                } else ur._createAffineTransformation(this.localOffset, this.localRotation, this._centerMatrix.elements);
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                this._localOffset.cloneTo(t.localOffset), this._localRotation.cloneTo(t.localRotation),
                    t.localOffset = t.localOffset, t.localRotation = t.localRotation;
            }
        }, {
            key: "clone",
            value: function clone() {
                return null;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._btShape && (x._bullet.btCollisionShape_destroy(this._btShape), this._btShape = null);
            }
        }, {
            key: "type",
            get: function get() {
                return this._type;
            }
        }, {
            key: "localOffset",
            get: function get() {
                return this._localOffset;
            },
            set: function set(e) {
                this._localOffset = e, this._compoundParent && this._compoundParent._updateChildTransform(this);
            }
        }, {
            key: "localRotation",
            get: function get() {
                return this._localRotation;
            },
            set: function set(e) {
                this._localRotation = e, this._compoundParent && this._compoundParent._updateChildTransform(this);
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                var e = x._bullet;
                ur._btScale = e.btVector3_create(1, 1, 1), ur._btVector30 = e.btVector3_create(0, 0, 0),
                    ur._btQuaternion0 = e.btQuaternion_create(0, 0, 0, 1), ur._btTransform0 = e.btTransform_create();
            }
        }, {
            key: "_createAffineTransformation",
            value: function _createAffineTransformation(e, t, r) {
                var i = t.x,
                    a = t.y,
                    n = t.z,
                    s = t.w,
                    o = i + i,
                    l = a + a,
                    _ = n + n,
                    h = i * o,
                    c = i * l,
                    d = i * _,
                    u = a * l,
                    m = a * _,
                    f = n * _,
                    E = s * o,
                    T = s * l,
                    p = s * _;
                r[0] = 1 - (u + f), r[1] = c + p, r[2] = d - T, r[3] = 0, r[4] = c - p, r[5] = 1 - (h + f),
                    r[6] = m + E, r[7] = 0, r[8] = d + T, r[9] = m - E, r[10] = 1 - (h + u), r[11] = 0,
                    r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1;
            }
        }]);
        return ur;
    }();
    ur.SHAPEORIENTATION_UPX = 0, ur.SHAPEORIENTATION_UPY = 1, ur.SHAPEORIENTATION_UPZ = 2,
        ur.SHAPETYPES_BOX = 0, ur.SHAPETYPES_SPHERE = 1, ur.SHAPETYPES_CYLINDER = 2, ur.SHAPETYPES_CAPSULE = 3,
        ur.SHAPETYPES_CONVEXHULL = 4, ur.SHAPETYPES_COMPOUND = 5, ur.SHAPETYPES_STATICPLANE = 6,
        ur.SHAPETYPES_CONE = 7, ur._tempVector30 = new n();
    var mr = /* */ function(_ur) {
        _inherits(mr, _ur);
        _createClass(mr, [{
            key: "sizeX",
            get: function get() {
                return this._sizeX;
            }
        }, {
            key: "sizeY",
            get: function get() {
                return this._sizeY;
            }
        }, {
            key: "sizeZ",
            get: function get() {
                return this._sizeZ;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                mr._btSize = x._bullet.btVector3_create(0, 0, 0);
            }
        }]);

        function mr() {
            var _this54;
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            _classCallCheck(this, mr);
            _this54 = _possibleConstructorReturn(this, _getPrototypeOf(mr).call(this)), _this54._sizeX = e,
                _this54._sizeY = t, _this54._sizeZ = r, _this54._type = ur.SHAPETYPES_BOX;
            var i = x._bullet;
            i.btVector3_setValue(mr._btSize, e / 2, t / 2, r / 2), _this54._btShape = i.btBoxShape_create(mr._btSize);
            return _this54;
        }
        _createClass(mr, [{
            key: "clone",
            value: function clone() {
                var e = new mr(this._sizeX, this._sizeY, this._sizeZ);
                return this.cloneTo(e), e;
            }
        }]);
        return mr;
    }(ur);
    var fr = /* */ function(_ur2) {
        _inherits(fr, _ur2);

        function fr() {
            var _this55;
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .5;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.25;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ur.SHAPEORIENTATION_UPY;
            _classCallCheck(this, fr);
            _this55 = _possibleConstructorReturn(this, _getPrototypeOf(fr).call(this)), _this55._radius = e,
                _this55._length = t, _this55._orientation = r, _this55._type = ur.SHAPETYPES_CAPSULE;
            var i = x._bullet;
            switch (r) {
                case ur.SHAPEORIENTATION_UPX:
                    _this55._btShape = i.btCapsuleShapeX_create(e, t - 2 * e);
                    break;

                case ur.SHAPEORIENTATION_UPY:
                    _this55._btShape = i.btCapsuleShape_create(e, t - 2 * e);
                    break;

                case ur.SHAPEORIENTATION_UPZ:
                    _this55._btShape = i.btCapsuleShapeZ_create(e, t - 2 * e);
                    break;

                default:
                    throw "CapsuleColliderShape:unknown orientation.";
            }
            return _this55;
        }
        _createClass(fr, [{
            key: "_setScale",
            value: function _setScale(e) {
                var t = fr._tempVector30;
                switch (this.orientation) {
                    case ur.SHAPEORIENTATION_UPX:
                        t.x = e.x, t.y = t.z = Math.max(e.y, e.z);
                        break;

                    case ur.SHAPEORIENTATION_UPY:
                        t.y = e.y, t.x = t.z = Math.max(e.x, e.z);
                        break;

                    case ur.SHAPEORIENTATION_UPZ:
                        t.z = e.z, t.x = t.y = Math.max(e.x, e.y);
                        break;

                    default:
                        throw "CapsuleColliderShape:unknown orientation.";
                }
                _get(_getPrototypeOf(fr.prototype), "_setScale", this).call(this, t);
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new fr(this._radius, this._length, this._orientation);
                return this.cloneTo(e), e;
            }
        }, {
            key: "radius",
            get: function get() {
                return this._radius;
            }
        }, {
            key: "length",
            get: function get() {
                return this._length;
            }
        }, {
            key: "orientation",
            get: function get() {
                return this._orientation;
            }
        }]);
        return fr;
    }(ur);
    fr._tempVector30 = new n();
    var Er = /* */ function(_ur3) {
        _inherits(Er, _ur3);

        function Er() {
            var _this56;
            _classCallCheck(this, Er);
            _this56 = _possibleConstructorReturn(this, _getPrototypeOf(Er).call(this)), _this56._childColliderShapes = [],
                _this56._type = ur.SHAPETYPES_COMPOUND, _this56._btShape = x._bullet.btCompoundShape_create();
            return _this56;
        }
        _createClass(Er, [{
            key: "_clearChildShape",
            value: function _clearChildShape(e) {
                e._attatched = !1, e._compoundParent = null, e._indexInCompound = -1;
            }
        }, {
            key: "_addReference",
            value: function _addReference() {}
        }, {
            key: "_removeReference",
            value: function _removeReference() {}
        }, {
            key: "_updateChildTransform",
            value: function _updateChildTransform(e) {
                var t = x._bullet,
                    r = e.localOffset,
                    i = e.localRotation,
                    a = ur._btVector30,
                    n = ur._btQuaternion0,
                    s = ur._btTransform0;
                t.btVector3_setValue(a, -r.x, r.y, r.z), t.btQuaternion_setValue(n, -i.x, i.y, i.z, -i.w),
                    t.btTransform_setOrigin(s, a), t.btTransform_setRotation(s, n), t.btCompoundShape_updateChildTransform(this._btShape, e._indexInCompound, s, !0);
            }
        }, {
            key: "addChildShape",
            value: function addChildShape(e) {
                if (e._attatched) throw "CompoundColliderShape: this shape has attatched to other entity.";
                e._attatched = !0, e._compoundParent = this, e._indexInCompound = this._childColliderShapes.length,
                    this._childColliderShapes.push(e);
                var t = e.localOffset,
                    r = e.localRotation,
                    i = x._bullet;
                i.btVector3_setValue(Er._btOffset, -t.x, t.y, t.z), i.btQuaternion_setValue(Er._btRotation, -r.x, r.y, r.z, -r.w),
                    i.btTransform_setOrigin(Er._btTransform, Er._btOffset), i.btTransform_setRotation(Er._btTransform, Er._btRotation);
                var a = i.btCollisionShape_getLocalScaling(this._btShape);
                i.btCollisionShape_setLocalScaling(this._btShape, Er._btVector3One), i.btCompoundShape_addChildShape(this._btShape, Er._btTransform, e._btShape),
                    i.btCollisionShape_setLocalScaling(this._btShape, a), this._attatchedCollisionObject && (this._attatchedCollisionObject.colliderShape = this);
            }
        }, {
            key: "removeChildShape",
            value: function removeChildShape(e) {
                if (e._compoundParent === this) {
                    var t = e._indexInCompound;
                    this._clearChildShape(e);
                    var r = this._childColliderShapes[this._childColliderShapes.length - 1];
                    r._indexInCompound = t, this._childColliderShapes[t] = r, this._childColliderShapes.pop(),
                        x._bullet.btCompoundShape_removeChildShapeByIndex(this._btShape, t);
                }
            }
        }, {
            key: "clearChildShape",
            value: function clearChildShape() {
                for (var e = 0, t = this._childColliderShapes.length; e < t; e++) {
                    this._clearChildShape(this._childColliderShapes[e]), x._bullet.btCompoundShape_removeChildShapeByIndex(this._btShape, 0);
                }
                this._childColliderShapes.length = 0;
            }
        }, {
            key: "getChildShapeCount",
            value: function getChildShapeCount() {
                return this._childColliderShapes.length;
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t.clearChildShape();
                for (var r = 0, i = this._childColliderShapes.length; r < i; r++) {
                    t.addChildShape(this._childColliderShapes[r].clone());
                }
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new Er();
                return this.cloneTo(e), e;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                _get(_getPrototypeOf(Er.prototype), "destroy", this).call(this);
                for (var e = 0, t = this._childColliderShapes.length; e < t; e++) {
                    var r = this._childColliderShapes[e];
                    0 === r._referenceCount && r.destroy();
                }
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                var e = x._bullet;
                Er._btVector3One = e.btVector3_create(1, 1, 1), Er._btTransform = e.btTransform_create(),
                    Er._btOffset = e.btVector3_create(0, 0, 0), Er._btRotation = e.btQuaternion_create(0, 0, 0, 1);
            }
        }]);
        return Er;
    }(ur);
    var Tr = /* */ function(_ur4) {
        _inherits(Tr, _ur4);

        function Tr() {
            var _this57;
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .5;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ur.SHAPEORIENTATION_UPY;
            _classCallCheck(this, Tr);
            _this57 = _possibleConstructorReturn(this, _getPrototypeOf(Tr).call(this)), _this57._radius = 1,
                _this57._height = .5, _this57._radius = e, _this57._height = t, _this57._orientation = r,
                _this57._type = ur.SHAPETYPES_CYLINDER;
            var i = x._bullet;
            switch (r) {
                case ur.SHAPEORIENTATION_UPX:
                    _this57._btShape = i.btConeShapeX_create(e, t);
                    break;

                case ur.SHAPEORIENTATION_UPY:
                    _this57._btShape = i.btConeShape_create(e, t);
                    break;

                case ur.SHAPEORIENTATION_UPZ:
                    _this57._btShape = i.btConeShapeZ_create(e, t);
                    break;

                default:
                    throw "ConeColliderShape:unknown orientation.";
            }
            return _this57;
        }
        _createClass(Tr, [{
            key: "clone",
            value: function clone() {
                var e = new Tr(this._radius, this._height, this._orientation);
                return this.cloneTo(e), e;
            }
        }, {
            key: "radius",
            get: function get() {
                return this._radius;
            }
        }, {
            key: "height",
            get: function get() {
                return this._height;
            }
        }, {
            key: "orientation",
            get: function get() {
                return this._orientation;
            }
        }]);
        return Tr;
    }(ur);
    var pr = /* */ function(_ur5) {
        _inherits(pr, _ur5);

        function pr() {
            var _this58;
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .5;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ur.SHAPEORIENTATION_UPY;
            _classCallCheck(this, pr);
            _this58 = _possibleConstructorReturn(this, _getPrototypeOf(pr).call(this)), _this58._radius = 1,
                _this58._height = .5, _this58._radius = e, _this58._height = t, _this58._orientation = r,
                _this58._type = ur.SHAPETYPES_CYLINDER;
            var i = x._bullet;
            switch (r) {
                case ur.SHAPEORIENTATION_UPX:
                    i.btVector3_setValue(pr._btSize, t / 2, e, e), _this58._btShape = i.btCylinderShapeX_create(pr._btSize);
                    break;

                case ur.SHAPEORIENTATION_UPY:
                    i.btVector3_setValue(pr._btSize, e, t / 2, e), _this58._btShape = i.btCylinderShape_create(pr._btSize);
                    break;

                case ur.SHAPEORIENTATION_UPZ:
                    i.btVector3_setValue(pr._btSize, e, e, t / 2), _this58._btShape = i.btCylinderShapeZ_create(pr._btSize);
                    break;

                default:
                    throw "CapsuleColliderShape:unknown orientation.";
            }
            return _this58;
        }
        _createClass(pr, [{
            key: "clone",
            value: function clone() {
                var e = new pr(this._radius, this._height, this._orientation);
                return this.cloneTo(e), e;
            }
        }, {
            key: "radius",
            get: function get() {
                return this._radius;
            }
        }, {
            key: "height",
            get: function get() {
                return this._height;
            }
        }, {
            key: "orientation",
            get: function get() {
                return this._orientation;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                pr._btSize = x._bullet.btVector3_create(0, 0, 0);
            }
        }]);
        return pr;
    }(ur);
    var gr = /* */ function(_ur6) {
        _inherits(gr, _ur6);

        function gr() {
            var _this59;
            _classCallCheck(this, gr);
            _this59 = _possibleConstructorReturn(this, _getPrototypeOf(gr).call(this)), _this59._mesh = null,
                _this59._convex = !1;
            return _this59;
        }
        _createClass(gr, [{
            key: "_setScale",
            value: function _setScale(e) {
                if (this._compoundParent) this.updateLocalTransformations();
                else {
                    var t = x._bullet;
                    t.btVector3_setValue(ur._btScale, e.x, e.y, e.z), t.btCollisionShape_setLocalScaling(this._btShape, ur._btScale),
                        t.btGImpactShapeInterface_updateBound(this._btShape);
                }
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t.convex = this._convex, t.mesh = this._mesh, _get(_getPrototypeOf(gr.prototype), "cloneTo", this).call(this, e);
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new gr();
                return this.cloneTo(e), e;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._btShape && (x._bullet.btCollisionShape_destroy(this._btShape), this._btShape = null);
            }
        }, {
            key: "mesh",
            get: function get() {
                return this._mesh;
            },
            set: function set(e) {
                if (this._mesh !== e) {
                    var t = x._bullet;
                    this._mesh && t.destroy(this._btShape), e && (this._btShape = t.btGImpactMeshShape_create(e._getPhysicMesh()),
                        t.btGImpactShapeInterface_updateBound(this._btShape)), this._mesh = e;
                }
            }
        }, {
            key: "convex",
            get: function get() {
                return this._convex;
            },
            set: function set(e) {
                this._convex = e;
            }
        }]);
        return gr;
    }(ur);
    var Sr = /* */ function(_ur7) {
        _inherits(Sr, _ur7);
        _createClass(Sr, [{
            key: "radius",
            get: function get() {
                return this._radius;
            }
        }]);

        function Sr() {
            var _this60;
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .5;
            _classCallCheck(this, Sr);
            _this60 = _possibleConstructorReturn(this, _getPrototypeOf(Sr).call(this)), _this60._radius = e,
                _this60._type = ur.SHAPETYPES_SPHERE, _this60._btShape = x._bullet.btSphereShape_create(e);
            return _this60;
        }
        _createClass(Sr, [{
            key: "clone",
            value: function clone() {
                var e = new Sr(this._radius);
                return this.cloneTo(e), e;
            }
        }]);
        return Sr;
    }(ur);
    var Rr = /* */ function(_t$Component2) {
        _inherits(Rr, _t$Component2);

        function Rr(e, t) {
            var _this61;
            _classCallCheck(this, Rr);
            _this61 = _possibleConstructorReturn(this, _getPrototypeOf(Rr).call(this)), _this61._restitution = 0,
                _this61._friction = .5, _this61._rollingFriction = 0, _this61._ccdMotionThreshold = 0,
                _this61._ccdSweptSphereRadius = 0, _this61._collisionGroup = Xt.COLLISIONFILTERGROUP_DEFAULTFILTER,
                _this61._canCollideWith = Xt.COLLISIONFILTERGROUP_ALLFILTER, _this61._colliderShape = null,
                _this61._transformFlag = 2147483647, _this61._enableProcessCollisions = !0, _this61._inPhysicUpdateListIndex = -1,
                _this61.canScaleShape = !0, _this61._collisionGroup = e, _this61._canCollideWith = t,
                Rr._physicObjectsMap[_this61.id] = _assertThisInitialized(_this61);
            return _this61;
        }
        _createClass(Rr, [{
            key: "_parseShape",
            value: function _parseShape(e) {
                var t = e.length;
                if (1 === t) {
                    var r = Rr._creatShape(e[0]);
                    this.colliderShape = r;
                } else {
                    for (var i = new Er(), a = 0; a < t; a++) {
                        r = Rr._creatShape(e[a]), i.addChildShape(r);
                    }
                    this.colliderShape = i;
                }
            }
        }, {
            key: "_onScaleChange",
            value: function _onScaleChange(e) {
                this._colliderShape._setScale(e);
            }
        }, {
            key: "_onEnable",
            value: function _onEnable() {
                this._simulation = this.owner._scene.physicsSimulation, x._bullet.btCollisionObject_setContactProcessingThreshold(this._btColliderObject, 1e30),
                    this._colliderShape && this._enabled && (this._derivePhysicsTransformation(!0),
                        this._addToSimulation());
            }
        }, {
            key: "_onDisable",
            value: function _onDisable() {
                this._colliderShape && this._enabled && (this._removeFromSimulation(), -1 !== this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.remove(this)),
                    this._simulation = null;
            }
        }, {
            key: "_onDestroy",
            value: function _onDestroy() {
                delete Rr._physicObjectsMap[this.id], x._bullet.btCollisionObject_destroy(this._btColliderObject),
                    this._colliderShape.destroy(), _get(_getPrototypeOf(Rr.prototype), "_onDestroy", this).call(this),
                    this._btColliderObject = null, this._colliderShape = null, this._simulation = null,
                    this.owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
            }
        }, {
            key: "_isValid",
            value: function _isValid() {
                return this._simulation && this._colliderShape && this._enabled;
            }
        }, {
            key: "_parse",
            value: function _parse(e) {
                null != e.collisionGroup && (this.collisionGroup = e.collisionGroup), null != e.canCollideWith && (this.canCollideWith = e.canCollideWith),
                    null != e.ccdMotionThreshold && (this.ccdMotionThreshold = e.ccdMotionThreshold),
                    null != e.ccdSweptSphereRadius && (this.ccdSweptSphereRadius = e.ccdSweptSphereRadius);
            }
        }, {
            key: "_setTransformFlag",
            value: function _setTransformFlag(e, t) {
                t ? this._transformFlag |= e : this._transformFlag &= ~e;
            }
        }, {
            key: "_getTransformFlag",
            value: function _getTransformFlag(e) {
                return 0 != (this._transformFlag & e);
            }
        }, {
            key: "_addToSimulation",
            value: function _addToSimulation() {}
        }, {
            key: "_removeFromSimulation",
            value: function _removeFromSimulation() {}
        }, {
            key: "_derivePhysicsTransformation",
            value: function _derivePhysicsTransformation(e) {
                this._innerDerivePhysicsTransformation(x._bullet.btCollisionObject_getWorldTransform(this._btColliderObject), e);
            }
        }, {
            key: "_innerDerivePhysicsTransformation",
            value: function _innerDerivePhysicsTransformation(e, t) {
                var r = x._bullet,
                    i = this.owner._transform;
                if (t || this._getTransformFlag(De.TRANSFORM_WORLDPOSITION)) {
                    var a = this._colliderShape.localOffset,
                        s = i.position,
                        o = Rr._btVector30;
                    if (0 !== a.x || 0 !== a.y || 0 !== a.z) {
                        var l = Rr._tempVector30,
                            _ = i.worldMatrix;
                        n.transformCoordinate(a, _, l), r.btVector3_setValue(o, -l.x, l.y, l.z);
                    } else r.btVector3_setValue(o, -s.x, s.y, s.z);
                    r.btTransform_setOrigin(e, o), this._setTransformFlag(De.TRANSFORM_WORLDPOSITION, !1);
                }
                if (t || this._getTransformFlag(De.TRANSFORM_WORLDQUATERNION)) {
                    var h = this._colliderShape.localRotation,
                        c = Rr._btQuaternion0,
                        d = i.rotation;
                    if (0 !== h.x || 0 !== h.y || 0 !== h.z || 1 !== h.w) {
                        var u = Rr._tempQuaternion0;
                        Rr.physicQuaternionMultiply(d.x, d.y, d.z, d.w, h, u), r.btQuaternion_setValue(c, -u.x, u.y, u.z, -u.w);
                    } else r.btQuaternion_setValue(c, -d.x, d.y, d.z, -d.w);
                    r.btTransform_setRotation(e, c), this._setTransformFlag(De.TRANSFORM_WORLDQUATERNION, !1);
                }
                (t || this._getTransformFlag(De.TRANSFORM_WORLDSCALE)) && (this._onScaleChange(i.getWorldLossyScale()),
                    this._setTransformFlag(De.TRANSFORM_WORLDSCALE, !1));
            }
        }, {
            key: "_updateTransformComponent",
            value: function _updateTransformComponent(e) {
                var t = x._bullet,
                    r = this._colliderShape.localOffset,
                    i = this._colliderShape.localRotation,
                    a = this.owner._transform,
                    n = a.position,
                    s = a.rotation,
                    o = t.btTransform_getOrigin(e),
                    l = t.btTransform_getRotation(e),
                    _ = -t.btQuaternion_x(l),
                    h = t.btQuaternion_y(l),
                    c = t.btQuaternion_z(l),
                    d = -t.btQuaternion_w(l);
                if (0 !== r.x || 0 !== r.y || 0 !== r.z) {
                    var u = Rr._tempVector30;
                    Rr.physicVector3TransformQuat(r, _, h, c, d, u), n.x = -t.btVector3_x(o) - u.x,
                        n.y = t.btVector3_y(o) - u.y, n.z = t.btVector3_z(o) - u.z;
                } else n.x = -t.btVector3_x(o), n.y = t.btVector3_y(o), n.z = t.btVector3_z(o);
                if (a.position = n, 0 !== i.x || 0 !== i.y || 0 !== i.z || 1 !== i.w) {
                    var m = Rr._tempQuaternion0;
                    i.invert(m), Rr.physicQuaternionMultiply(_, h, c, d, m, s);
                } else s.x = _, s.y = h, s.z = c, s.w = d;
                a.rotation = s;
            }
        }, {
            key: "_onShapeChange",
            value: function _onShapeChange(e) {
                var t = this._btColliderObject,
                    r = x._bullet,
                    i = r.btCollisionObject_getCollisionFlags(t);
                e.needsCustomCollisionCallback ? 0 == (i & Rr.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) && r.btCollisionObject_setCollisionFlags(t, i | Rr.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) : (i & Rr.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) > 0 && r.btCollisionObject_setCollisionFlags(t, i ^ Rr.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK);
            }
        }, {
            key: "_onAdded",
            value: function _onAdded() {
                this.enabled = this._enabled, this.restitution = this._restitution, this.friction = this._friction,
                    this.rollingFriction = this._rollingFriction, this.ccdMotionThreshold = this._ccdMotionThreshold,
                    this.ccdSweptSphereRadius = this._ccdSweptSphereRadius, this.owner.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
            }
        }, {
            key: "_onTransformChanged",
            value: function _onTransformChanged(e) {
                Rr._addUpdateList && (e &= De.TRANSFORM_WORLDPOSITION | De.TRANSFORM_WORLDQUATERNION | De.TRANSFORM_WORLDSCALE) && (this._transformFlag |= e,
                    this._isValid() && -1 === this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.add(this));
            }
        }, {
            key: "_cloneTo",
            value: function _cloneTo(e) {
                var t = e;
                t.restitution = this._restitution, t.friction = this._friction, t.rollingFriction = this._rollingFriction,
                    t.ccdMotionThreshold = this._ccdMotionThreshold, t.ccdSweptSphereRadius = this._ccdSweptSphereRadius,
                    t.collisionGroup = this._collisionGroup, t.canCollideWith = this._canCollideWith,
                    t.canScaleShape = this.canScaleShape, this._colliderShape && (t.colliderShape = this._colliderShape.clone());
            }
        }, {
            key: "restitution",
            get: function get() {
                return this._restitution;
            },
            set: function set(e) {
                this._restitution = e, this._btColliderObject && x._bullet.btCollisionObject_setRestitution(this._btColliderObject, e);
            }
        }, {
            key: "friction",
            get: function get() {
                return this._friction;
            },
            set: function set(e) {
                this._friction = e, this._btColliderObject && x._bullet.btCollisionObject_setFriction(this._btColliderObject, e);
            }
        }, {
            key: "rollingFriction",
            get: function get() {
                return this._rollingFriction;
            },
            set: function set(e) {
                this._rollingFriction = e, this._btColliderObject && x._bullet.btCollisionObject_setRollingFriction(this._btColliderObject, e);
            }
        }, {
            key: "ccdMotionThreshold",
            get: function get() {
                return this._ccdMotionThreshold;
            },
            set: function set(e) {
                this._ccdMotionThreshold = e, this._btColliderObject && x._bullet.btCollisionObject_setCcdMotionThreshold(this._btColliderObject, e);
            }
        }, {
            key: "ccdSweptSphereRadius",
            get: function get() {
                return this._ccdSweptSphereRadius;
            },
            set: function set(e) {
                this._ccdSweptSphereRadius = e, this._btColliderObject && x._bullet.btCollisionObject_setCcdSweptSphereRadius(this._btColliderObject, e);
            }
        }, {
            key: "isActive",
            get: function get() {
                return !!this._btColliderObject && x._bullet.btCollisionObject_isActive(this._btColliderObject);
            }
        }, {
            key: "enabled",
            get: function get() {
                return _get(_getPrototypeOf(Rr.prototype), "enabled", this);
            },
            set: function set(e) {
                this._enabled != e && (this._simulation && this._colliderShape && (e ? (this._derivePhysicsTransformation(!0),
                    this._addToSimulation()) : this._removeFromSimulation()), _set(_getPrototypeOf(Rr.prototype), "enabled", e, this, true));
            }
        }, {
            key: "colliderShape",
            get: function get() {
                return this._colliderShape;
            },
            set: function set(e) {
                var t = this._colliderShape;
                if (t && (t._attatched = !1, t._attatchedCollisionObject = null), this._colliderShape = e,
                    e) {
                    if (e._attatched) throw "PhysicsComponent: this shape has attatched to other entity.";
                    if (e._attatched = !0, e._attatchedCollisionObject = this, this._btColliderObject) {
                        x._bullet.btCollisionObject_setCollisionShape(this._btColliderObject, e._btShape);
                        var r = this._simulation && this._enabled;
                        r && t && this._removeFromSimulation(), this._onShapeChange(e), r && (this._derivePhysicsTransformation(!0),
                            this._addToSimulation());
                    }
                } else this._simulation && this._enabled && t && this._removeFromSimulation();
            }
        }, {
            key: "simulation",
            get: function get() {
                return this._simulation;
            }
        }, {
            key: "collisionGroup",
            get: function get() {
                return this._collisionGroup;
            },
            set: function set(e) {
                this._collisionGroup !== e && (this._collisionGroup = e, this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(),
                    this._addToSimulation()));
            }
        }, {
            key: "canCollideWith",
            get: function get() {
                return this._canCollideWith;
            },
            set: function set(e) {
                this._canCollideWith !== e && (this._canCollideWith = e, this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(),
                    this._addToSimulation()));
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                var e = x._bullet;
                Rr._btVector30 = e.btVector3_create(0, 0, 0), Rr._btQuaternion0 = e.btQuaternion_create(0, 0, 0, 1);
            }
        }, {
            key: "_createAffineTransformationArray",
            value: function _createAffineTransformationArray(e, t, r, i, a, n, s, o, l) {
                var _ = i + i,
                    h = a + a,
                    c = n + n,
                    d = i * _,
                    u = i * h,
                    m = i * c,
                    f = a * h,
                    E = a * c,
                    T = n * c,
                    p = s * _,
                    g = s * h,
                    S = s * c,
                    R = o[0],
                    v = o[1],
                    x = o[2];
                l[0] = (1 - (f + T)) * R, l[1] = (u + S) * R, l[2] = (m - g) * R, l[3] = 0, l[4] = (u - S) * v,
                    l[5] = (1 - (d + T)) * v, l[6] = (E + p) * v, l[7] = 0, l[8] = (m + g) * x, l[9] = (E - p) * x,
                    l[10] = (1 - (d + f)) * x, l[11] = 0, l[12] = e, l[13] = t, l[14] = r, l[15] = 1;
            }
        }, {
            key: "_creatShape",
            value: function _creatShape(e) {
                var r;
                switch (e.type) {
                    case "BoxColliderShape":
                        var i = e.size;
                        r = i ? new mr(i[0], i[1], i[2]) : new mr();
                        break;

                    case "SphereColliderShape":
                        r = new Sr(e.radius);
                        break;

                    case "CapsuleColliderShape":
                        r = new fr(e.radius, e.height, e.orientation);
                        break;

                    case "MeshColliderShape":
                        var a = new gr();
                        e.mesh && (a.mesh = t.Loader.getRes(e.mesh)), r = a;
                        break;

                    case "ConeColliderShape":
                        r = new Tr(e.radius, e.height, e.orientation);
                        break;

                    case "CylinderColliderShape":
                        r = new pr(e.radius, e.height, e.orientation);
                        break;

                    default:
                        throw "unknown shape type.";
                }
                if (e.center) {
                    var n = r.localOffset;
                    n.fromArray(e.center), r.localOffset = n;
                }
                return r;
            }
        }, {
            key: "physicVector3TransformQuat",
            value: function physicVector3TransformQuat(e, t, r, i, a, n) {
                var s = e.x,
                    o = e.y,
                    l = e.z,
                    _ = a * s + r * l - i * o,
                    h = a * o + i * s - t * l,
                    c = a * l + t * o - r * s,
                    d = -t * s - r * o - i * l;
                n.x = _ * a + d * -t + h * -i - c * -r, n.y = h * a + d * -r + c * -t - _ * -i,
                    n.z = c * a + d * -i + _ * -r - h * -t;
            }
        }, {
            key: "physicQuaternionMultiply",
            value: function physicQuaternionMultiply(e, t, r, i, a, n) {
                var s = a.x,
                    o = a.y,
                    l = a.z,
                    _ = a.w,
                    h = t * l - r * o,
                    c = r * s - e * l,
                    d = e * o - t * s,
                    u = e * s + t * o + r * l;
                n.x = e * _ + s * i + h, n.y = t * _ + o * i + c, n.z = r * _ + l * i + d, n.w = i * _ - u;
            }
        }]);
        return Rr;
    }(t.Component);
    Rr.ACTIVATIONSTATE_ACTIVE_TAG = 1, Rr.ACTIVATIONSTATE_ISLAND_SLEEPING = 2, Rr.ACTIVATIONSTATE_WANTS_DEACTIVATION = 3,
        Rr.ACTIVATIONSTATE_DISABLE_DEACTIVATION = 4, Rr.ACTIVATIONSTATE_DISABLE_SIMULATION = 5,
        Rr.COLLISIONFLAGS_STATIC_OBJECT = 1, Rr.COLLISIONFLAGS_KINEMATIC_OBJECT = 2, Rr.COLLISIONFLAGS_NO_CONTACT_RESPONSE = 4,
        Rr.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK = 8, Rr.COLLISIONFLAGS_CHARACTER_OBJECT = 16,
        Rr.COLLISIONFLAGS_DISABLE_VISUALIZE_OBJECT = 32, Rr.COLLISIONFLAGS_DISABLE_SPU_COLLISION_PROCESSING = 64,
        Rr._tempVector30 = new n(), Rr._tempQuaternion0 = new f(), Rr._tempQuaternion1 = new f(),
        Rr._tempMatrix4x40 = new C(), Rr._physicObjectsMap = {}, Rr._addUpdateList = !0;
    var vr = /* */ function() {
        function vr(e) {
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            _classCallCheck(this, vr);
            this._gravity = new n(0, -10, 0), this._btVector3Zero = x._bullet.btVector3_create(0, 0, 0),
                this._btDefaultQuaternion = x._bullet.btQuaternion_create(0, 0, 0, -1), this._collisionsUtils = new dr(),
                this._previousFrameCollisions = [], this._currentFrameCollisions = [], this._physicsUpdateList = new _r(),
                this._characters = [], this._updatedRigidbodies = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 / 60,
                this.maxSubSteps = e.maxSubSteps, this.fixedTimeStep = e.fixedTimeStep;
            var r = x._bullet;
            this._btCollisionConfiguration = r.btDefaultCollisionConfiguration_create(), this._btDispatcher = r.btCollisionDispatcher_create(this._btCollisionConfiguration),
                this._btBroadphase = r.btDbvtBroadphase_create(), r.btOverlappingPairCache_setInternalGhostPairCallback(r.btDbvtBroadphase_getOverlappingPairCache(this._btBroadphase), r.btGhostPairCallback_create());
            var i = e.flags;
            if (i & vr.PHYSICSENGINEFLAGS_COLLISIONSONLY) this._btCollisionWorld = new r.btCollisionWorld(this._btDispatcher, this._btBroadphase, this._btCollisionConfiguration);
            else {
                if (i & vr.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT) throw "PhysicsSimulation:SoftBody processing is not yet available";
                var a = r.btSequentialImpulseConstraintSolver_create();
                this._btDiscreteDynamicsWorld = r.btDiscreteDynamicsWorld_create(this._btDispatcher, this._btBroadphase, a, this._btCollisionConfiguration),
                    this._btCollisionWorld = this._btDiscreteDynamicsWorld;
            }
            this._btDiscreteDynamicsWorld && (this._btSolverInfo = r.btDynamicsWorld_getSolverInfo(this._btDiscreteDynamicsWorld),
                    this._btDispatchInfo = r.btCollisionWorld_getDispatchInfo(this._btDiscreteDynamicsWorld)),
                this._btClosestRayResultCallback = r.ClosestRayResultCallback_create(this._btVector3Zero, this._btVector3Zero),
                this._btAllHitsRayResultCallback = r.AllHitsRayResultCallback_create(this._btVector3Zero, this._btVector3Zero),
                this._btClosestConvexResultCallback = r.ClosestConvexResultCallback_create(this._btVector3Zero, this._btVector3Zero),
                this._btAllConvexResultCallback = r.AllConvexResultCallback_create(this._btVector3Zero, this._btVector3Zero),
                r.btGImpactCollisionAlgorithm_RegisterAlgorithm(this._btDispatcher);
        }
        _createClass(vr, [{
            key: "_simulate",
            value: function _simulate(e) {
                this._updatedRigidbodies = 0;
                var t = x._bullet;
                this._btDiscreteDynamicsWorld ? t.btDiscreteDynamicsWorld_stepSimulation(this._btDiscreteDynamicsWorld, e, this.maxSubSteps, this.fixedTimeStep) : t.PerformDiscreteCollisionDetection(this._btCollisionWorld);
            }
        }, {
            key: "_destroy",
            value: function _destroy() {
                var e = x._bullet;
                this._btDiscreteDynamicsWorld ? (e.btCollisionWorld_destroy(this._btDiscreteDynamicsWorld),
                        this._btDiscreteDynamicsWorld = null) : (e.btCollisionWorld_destroy(this._btCollisionWorld),
                        this._btCollisionWorld = null), e.btDbvtBroadphase_destroy(this._btBroadphase),
                    this._btBroadphase = null, e.btCollisionDispatcher_destroy(this._btDispatcher),
                    this._btDispatcher = null, e.btDefaultCollisionConfiguration_destroy(this._btCollisionConfiguration),
                    this._btCollisionConfiguration = null;
            }
        }, {
            key: "_addPhysicsCollider",
            value: function _addPhysicsCollider(e, t, r) {
                x._bullet.btCollisionWorld_addCollisionObject(this._btCollisionWorld, e._btColliderObject, t, r);
            }
        }, {
            key: "_removePhysicsCollider",
            value: function _removePhysicsCollider(e) {
                x._bullet.btCollisionWorld_removeCollisionObject(this._btCollisionWorld, e._btColliderObject);
            }
        }, {
            key: "_addRigidBody",
            value: function _addRigidBody(e, t, r) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                x._bullet.btDiscreteDynamicsWorld_addRigidBody(this._btCollisionWorld, e._btColliderObject, t, r);
            }
        }, {
            key: "_removeRigidBody",
            value: function _removeRigidBody(e) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                x._bullet.btDiscreteDynamicsWorld_removeRigidBody(this._btCollisionWorld, e._btColliderObject);
            }
        }, {
            key: "_addCharacter",
            value: function _addCharacter(e, t, r) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                var i = x._bullet;
                i.btCollisionWorld_addCollisionObject(this._btCollisionWorld, e._btColliderObject, t, r),
                    i.btDynamicsWorld_addAction(this._btCollisionWorld, e._btKinematicCharacter);
            }
        }, {
            key: "_removeCharacter",
            value: function _removeCharacter(e) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                var t = x._bullet;
                t.btCollisionWorld_removeCollisionObject(this._btCollisionWorld, e._btColliderObject),
                    t.btDynamicsWorld_removeAction(this._btCollisionWorld, e._btKinematicCharacter);
            }
        }, {
            key: "raycastFromTo",
            value: function raycastFromTo(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Xt.COLLISIONFILTERGROUP_ALLFILTER;
                var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Xt.COLLISIONFILTERGROUP_ALLFILTER;
                var n = x._bullet,
                    s = this._btClosestRayResultCallback,
                    o = vr._btTempVector30,
                    l = vr._btTempVector31;
                if (n.btVector3_setValue(o, -e.x, e.y, e.z), n.btVector3_setValue(l, -t.x, t.y, t.z),
                    n.ClosestRayResultCallback_set_m_rayFromWorld(s, o), n.ClosestRayResultCallback_set_m_rayToWorld(s, l),
                    n.RayResultCallback_set_m_collisionFilterGroup(s, i), n.RayResultCallback_set_m_collisionFilterMask(s, a),
                    n.RayResultCallback_set_m_collisionObject(s, null), n.RayResultCallback_set_m_closestHitFraction(s, 1),
                    n.btCollisionWorld_rayTest(this._btCollisionWorld, o, l, s), n.RayResultCallback_hasHit(s)) {
                    if (r) {
                        r.succeeded = !0, r.collider = Rr._physicObjectsMap[n.btCollisionObject_getUserIndex(n.RayResultCallback_get_m_collisionObject(s))],
                            r.hitFraction = n.RayResultCallback_get_m_closestHitFraction(s);
                        var _ = n.ClosestRayResultCallback_get_m_hitPointWorld(s),
                            h = r.point;
                        h.x = -n.btVector3_x(_), h.y = n.btVector3_y(_), h.z = n.btVector3_z(_);
                        var c = n.ClosestRayResultCallback_get_m_hitNormalWorld(s),
                            d = r.normal;
                        d.x = -n.btVector3_x(c), d.y = n.btVector3_y(c), d.z = n.btVector3_z(c);
                    }
                    return !0;
                }
                return r && (r.succeeded = !1), !1;
            }
        }, {
            key: "raycastAllFromTo",
            value: function raycastAllFromTo(e, t, r) {
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Xt.COLLISIONFILTERGROUP_ALLFILTER;
                var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Xt.COLLISIONFILTERGROUP_ALLFILTER;
                var n = x._bullet,
                    s = this._btAllHitsRayResultCallback,
                    o = vr._btTempVector30,
                    l = vr._btTempVector31;
                r.length = 0, n.btVector3_setValue(o, -e.x, e.y, e.z), n.btVector3_setValue(l, -t.x, t.y, t.z),
                    n.AllHitsRayResultCallback_set_m_rayFromWorld(s, o), n.AllHitsRayResultCallback_set_m_rayToWorld(s, l),
                    n.RayResultCallback_set_m_collisionFilterGroup(s, i), n.RayResultCallback_set_m_collisionFilterMask(s, a);
                var _ = n.AllHitsRayResultCallback_get_m_collisionObjects(s),
                    h = n.AllHitsRayResultCallback_get_m_hitPointWorld(s),
                    c = n.AllHitsRayResultCallback_get_m_hitNormalWorld(s),
                    d = n.AllHitsRayResultCallback_get_m_hitFractions(s);
                n.tBtCollisionObjectArray_clear(_), n.tVector3Array_clear(h), n.tVector3Array_clear(c),
                    n.tScalarArray_clear(d), n.btCollisionWorld_rayTest(this._btCollisionWorld, o, l, s);
                var u = n.tBtCollisionObjectArray_size(_);
                if (u > 0) {
                    this._collisionsUtils.recoverAllHitResultsPool();
                    for (var m = 0; m < u; m++) {
                        var f = this._collisionsUtils.getHitResult();
                        r.push(f), f.succeeded = !0, f.collider = Rr._physicObjectsMap[n.btCollisionObject_getUserIndex(n.tBtCollisionObjectArray_at(_, m))],
                            f.hitFraction = n.tScalarArray_at(d, m);
                        var E = n.tVector3Array_at(h, m),
                            T = f.point;
                        T.x = -n.btVector3_x(E), T.y = n.btVector3_y(E), T.z = n.btVector3_z(E);
                        var p = n.tVector3Array_at(c, m),
                            g = f.normal;
                        g.x = -n.btVector3_x(p), g.y = n.btVector3_y(p), g.z = n.btVector3_z(p);
                    }
                    return !0;
                }
                return !1;
            }
        }, {
            key: "rayCast",
            value: function rayCast(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2147483647;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Xt.COLLISIONFILTERGROUP_ALLFILTER;
                var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Xt.COLLISIONFILTERGROUP_ALLFILTER;
                var s = e.origin,
                    o = vr._tempVector30;
                return n.normalize(e.direction, o), n.scale(o, r, o), n.add(s, o, o), this.raycastFromTo(s, o, t, i, a);
            }
        }, {
            key: "rayCastAll",
            value: function rayCastAll(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2147483647;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Xt.COLLISIONFILTERGROUP_ALLFILTER;
                var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Xt.COLLISIONFILTERGROUP_ALLFILTER;
                var s = e.origin,
                    o = vr._tempVector30;
                return n.normalize(e.direction, o), n.scale(o, r, o), n.add(s, o, o), this.raycastAllFromTo(s, o, t, i, a);
            }
        }, {
            key: "shapeCast",
            value: function shapeCast(e, t, r) {
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
                var n = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
                var s = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Xt.COLLISIONFILTERGROUP_ALLFILTER;
                var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : Xt.COLLISIONFILTERGROUP_ALLFILTER;
                var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
                var _ = x._bullet,
                    h = this._btClosestConvexResultCallback,
                    c = vr._btTempVector30,
                    d = vr._btTempVector31,
                    u = vr._btTempQuaternion0,
                    m = vr._btTempQuaternion1,
                    f = vr._btTempTransform0,
                    E = vr._btTempTransform1,
                    T = e._btShape;
                if (_.btVector3_setValue(c, -t.x, t.y, t.z), _.btVector3_setValue(d, -r.x, r.y, r.z),
                    _.ConvexResultCallback_set_m_collisionFilterGroup(h, s), _.ConvexResultCallback_set_m_collisionFilterMask(h, o),
                    _.btTransform_setOrigin(f, c), _.btTransform_setOrigin(E, d), a ? (_.btQuaternion_setValue(u, -a.x, a.y, a.z, -a.w),
                        _.btTransform_setRotation(f, u)) : _.btTransform_setRotation(f, this._btDefaultQuaternion),
                    n ? (_.btQuaternion_setValue(m, -n.x, n.y, n.z, -n.w), _.btTransform_setRotation(E, m)) : _.btTransform_setRotation(E, this._btDefaultQuaternion),
                    _.ClosestConvexResultCallback_set_m_hitCollisionObject(h, null), _.ConvexResultCallback_set_m_closestHitFraction(h, 1),
                    _.btCollisionWorld_convexSweepTest(this._btCollisionWorld, T, f, E, h, l), _.ConvexResultCallback_hasHit(h)) {
                    if (i) {
                        i.succeeded = !0, i.collider = Rr._physicObjectsMap[_.btCollisionObject_getUserIndex(_.ClosestConvexResultCallback_get_m_hitCollisionObject(h))],
                            i.hitFraction = _.ConvexResultCallback_get_m_closestHitFraction(h);
                        var p = _.ClosestConvexResultCallback_get_m_hitPointWorld(h),
                            g = _.ClosestConvexResultCallback_get_m_hitNormalWorld(h),
                            S = i.point,
                            R = i.normal;
                        S.x = -_.btVector3_x(p), S.y = _.btVector3_y(p), S.z = _.btVector3_z(p), R.x = -_.btVector3_x(g),
                            R.y = _.btVector3_y(g), R.z = _.btVector3_z(g);
                    }
                    return !0;
                }
                return i && (i.succeeded = !1), !1;
            }
        }, {
            key: "shapeCastAll",
            value: function shapeCastAll(e, t, r, i) {
                var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
                var n = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
                var s = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Xt.COLLISIONFILTERGROUP_ALLFILTER;
                var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : Xt.COLLISIONFILTERGROUP_ALLFILTER;
                var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
                var _ = x._bullet,
                    h = this._btAllConvexResultCallback,
                    c = vr._btTempVector30,
                    d = vr._btTempVector31,
                    u = vr._btTempQuaternion0,
                    m = vr._btTempQuaternion1,
                    f = vr._btTempTransform0,
                    E = vr._btTempTransform1,
                    T = e._btShape;
                i.length = 0, _.btVector3_setValue(c, -t.x, t.y, t.z), _.btVector3_setValue(d, -r.x, r.y, r.z),
                    _.ConvexResultCallback_set_m_collisionFilterGroup(h, s), _.ConvexResultCallback_set_m_collisionFilterMask(h, o),
                    _.btTransform_setOrigin(f, c), _.btTransform_setOrigin(E, d), a ? (_.btQuaternion_setValue(u, -a.x, a.y, a.z, -a.w),
                        _.btTransform_setRotation(f, u)) : _.btTransform_setRotation(f, this._btDefaultQuaternion),
                    n ? (_.btQuaternion_setValue(m, -n.x, n.y, n.z, -n.w), _.btTransform_setRotation(E, m)) : _.btTransform_setRotation(E, this._btDefaultQuaternion);
                var p = _.AllConvexResultCallback_get_m_collisionObjects(h);
                _.tBtCollisionObjectArray_clear(p), _.btCollisionWorld_convexSweepTest(this._btCollisionWorld, T, f, E, h, l);
                var g = _.tBtCollisionObjectArray_size(p);
                if (g > 0) {
                    for (var S = _.AllConvexResultCallback_get_m_hitPointWorld(h), R = _.AllConvexResultCallback_get_m_hitNormalWorld(h), v = _.AllConvexResultCallback_get_m_hitFractions(h), I = 0; I < g; I++) {
                        var A = this._collisionsUtils.getHitResult();
                        i.push(A), A.succeeded = !0, A.collider = Rr._physicObjectsMap[_.btCollisionObject_getUserIndex(_.tBtCollisionObjectArray_at(p, I))],
                            A.hitFraction = _.tScalarArray_at(v, I);
                        var M = _.tVector3Array_at(S, I),
                            D = A.point;
                        D.x = -_.btVector3_x(M), D.y = _.btVector3_y(M), D.z = _.btVector3_z(M);
                        var L = _.tVector3Array_at(R, I),
                            y = A.normal;
                        y.x = -_.btVector3_x(L), y.y = _.btVector3_y(L), y.z = _.btVector3_z(L);
                    }
                    return !0;
                }
                return !1;
            }
        }, {
            key: "addConstraint",
            value: function addConstraint(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
                if (!this._btDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
                e._simulation = this;
            }
        }, {
            key: "removeConstraint",
            value: function removeConstraint(e) {
                if (!this._btDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
            }
        }, {
            key: "_updatePhysicsTransformFromRender",
            value: function _updatePhysicsTransformFromRender() {
                for (var e = this._physicsUpdateList.elements, t = 0, r = this._physicsUpdateList.length; t < r; t++) {
                    var i = e[t];
                    i._derivePhysicsTransformation(!1), i._inPhysicUpdateListIndex = -1;
                }
                this._physicsUpdateList.length = 0;
            }
        }, {
            key: "_updateCharacters",
            value: function _updateCharacters() {
                for (var e = 0, t = this._characters.length; e < t; e++) {
                    var r = this._characters[e];
                    r._updateTransformComponent(x._bullet.btCollisionObject_getWorldTransform(r._btColliderObject));
                }
            }
        }, {
            key: "_updateCollisions",
            value: function _updateCollisions() {
                this._collisionsUtils.recoverAllContactPointsPool();
                var e = this._currentFrameCollisions;
                this._currentFrameCollisions = this._previousFrameCollisions, this._currentFrameCollisions.length = 0,
                    this._previousFrameCollisions = e;
                for (var r = t.Stat.loopCount, i = x._bullet, a = i.btDispatcher_getNumManifolds(this._btDispatcher), n = 0; n < a; n++) {
                    var s, o = i.btDispatcher_getManifoldByIndexInternal(this._btDispatcher, n),
                        l = Rr._physicObjectsMap[i.btCollisionObject_getUserIndex(i.btPersistentManifold_getBody0(o))],
                        _ = Rr._physicObjectsMap[i.btCollisionObject_getUserIndex(i.btPersistentManifold_getBody1(o))],
                        h = null,
                        c = null;
                    if ((l.isTrigger || _.isTrigger) && (l.owner._needProcessTriggers || _.owner._needProcessTriggers))
                        for (var d = i.btPersistentManifold_getNumContacts(o), u = 0; u < d; u++) {
                            var m = i.btPersistentManifold_getContactPoint(o, u),
                                f = i.btManifoldPoint_getDistance(m);
                            if (f <= 0) {
                                c = (h = this._collisionsUtils.getCollision(l, _)).contacts, (s = h._updateFrame !== r) && (h._isTrigger = !0,
                                    c.length = 0);
                                break;
                            }
                        } else if ((l.owner._needProcessCollisions || _.owner._needProcessCollisions) && (l._enableProcessCollisions || _._enableProcessCollisions))
                            for (d = i.btPersistentManifold_getNumContacts(o),
                                u = 0; u < d; u++) {
                                if (m = i.btPersistentManifold_getContactPoint(o, u), (f = i.btManifoldPoint_getDistance(m)) <= 0) {
                                    var E = this._collisionsUtils.getContactPoints();
                                    E.colliderA = l, E.colliderB = _, E.distance = f;
                                    var T = i.btManifoldPoint_get_m_normalWorldOnB(m),
                                        p = E.normal;
                                    p.x = -i.btVector3_x(T), p.y = i.btVector3_y(T), p.z = i.btVector3_z(T);
                                    var g = i.btManifoldPoint_get_m_positionWorldOnA(m),
                                        S = E.positionOnA;
                                    S.x = -i.btVector3_x(g), S.y = i.btVector3_y(g), S.z = i.btVector3_z(g);
                                    var R = i.btManifoldPoint_get_m_positionWorldOnB(m),
                                        v = E.positionOnB;
                                    v.x = -i.btVector3_x(R), v.y = i.btVector3_y(R), v.z = i.btVector3_z(R), h || (c = (h = this._collisionsUtils.getCollision(l, _)).contacts,
                                        (s = h._updateFrame !== r) && (h._isTrigger = !1, c.length = 0)), c.push(E);
                                }
                            }
                    h && s && (this._currentFrameCollisions.push(h), h._setUpdateFrame(r));
                }
            }
        }, {
            key: "_eventScripts",
            value: function _eventScripts() {
                for (var e = t.Stat.loopCount, r = 0, i = this._currentFrameCollisions.length; r < i; r++) {
                    var a = this._currentFrameCollisions[r],
                        n = a._colliderA,
                        s = a._colliderB;
                    if (!n.destroyed && !s.destroyed)
                        if (e - a._lastUpdateFrame == 1) {
                            var o = n.owner,
                                l = o._scripts;
                            if (l)
                                if (a._isTrigger) {
                                    if (o._needProcessTriggers)
                                        for (var _ = 0, h = l.length; _ < h; _++) {
                                            l[_].onTriggerStay(s);
                                        }
                                } else if (o._needProcessCollisions)
                                for (_ = 0, h = l.length; _ < h; _++) {
                                    a.other = s, l[_].onCollisionStay(a);
                                }
                            var c = s.owner,
                                d = c._scripts;
                            if (d)
                                if (a._isTrigger) {
                                    if (c._needProcessTriggers)
                                        for (_ = 0, h = d.length; _ < h; _++) {
                                            d[_].onTriggerStay(n);
                                        }
                                } else if (c._needProcessCollisions)
                                for (_ = 0, h = d.length; _ < h; _++) {
                                    a.other = n, d[_].onCollisionStay(a);
                                }
                        } else {
                            if (l = (o = n.owner)._scripts)
                                if (a._isTrigger) {
                                    if (o._needProcessTriggers)
                                        for (_ = 0, h = l.length; _ < h; _++) {
                                            l[_].onTriggerEnter(s);
                                        }
                                } else if (o._needProcessCollisions)
                                for (_ = 0, h = l.length; _ < h; _++) {
                                    a.other = s, l[_].onCollisionEnter(a);
                                }
                            if (d = (c = s.owner)._scripts)
                                if (a._isTrigger) {
                                    if (c._needProcessTriggers)
                                        for (_ = 0, h = d.length; _ < h; _++) {
                                            d[_].onTriggerEnter(n);
                                        }
                                } else if (c._needProcessCollisions)
                                for (_ = 0, h = d.length; _ < h; _++) {
                                    a.other = n, d[_].onCollisionEnter(a);
                                }
                        }
                }
                for (r = 0, i = this._previousFrameCollisions.length; r < i; r++) {
                    var u = this._previousFrameCollisions[r],
                        m = u._colliderA,
                        f = u._colliderB;
                    if (!m.destroyed && !f.destroyed && e - u._updateFrame == 1) {
                        if (this._collisionsUtils.recoverCollision(u), l = (o = m.owner)._scripts)
                            if (u._isTrigger) {
                                if (o._needProcessTriggers)
                                    for (_ = 0, h = l.length; _ < h; _++) {
                                        l[_].onTriggerExit(f);
                                    }
                            } else if (o._needProcessCollisions)
                            for (_ = 0, h = l.length; _ < h; _++) {
                                u.other = f, l[_].onCollisionExit(u);
                            }
                        if (d = (c = f.owner)._scripts)
                            if (u._isTrigger) {
                                if (c._needProcessTriggers)
                                    for (_ = 0, h = d.length; _ < h; _++) {
                                        d[_].onTriggerExit(m);
                                    }
                            } else if (c._needProcessCollisions)
                            for (_ = 0, h = d.length; _ < h; _++) {
                                u.other = m, d[_].onCollisionExit(u);
                            }
                    }
                }
            }
        }, {
            key: "clearForces",
            value: function clearForces() {
                if (!this._btDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
                x._bullet.btDiscreteDynamicsWorld_clearForces(this._btDiscreteDynamicsWorld);
            }
        }, {
            key: "continuousCollisionDetection",
            get: function get() {
                return x._bullet.btCollisionWorld_get_m_useContinuous(this._btDispatchInfo);
            },
            set: function set(e) {
                x._bullet.btCollisionWorld_set_m_useContinuous(this._btDispatchInfo, e);
            }
        }, {
            key: "gravity",
            get: function get() {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                return this._gravity;
            },
            set: function set(e) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                this._gravity = e;
                var t = x._bullet,
                    r = vr._btTempVector30;
                t.btVector3_setValue(r, -e.x, e.y, e.z), t.btDiscreteDynamicsWorld_setGravity(this._btDiscreteDynamicsWorld, r);
            }
        }, {
            key: "speculativeContactRestitution",
            get: function get() {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
                return x._bullet.btDiscreteDynamicsWorld_getApplySpeculativeContactRestitution(this._btDiscreteDynamicsWorld);
            },
            set: function set(e) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
                x._bullet.btDiscreteDynamicsWorld_setApplySpeculativeContactRestitution(this._btDiscreteDynamicsWorld, e);
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                var e = x._bullet;
                vr._btTempVector30 = e.btVector3_create(0, 0, 0), vr._btTempVector31 = e.btVector3_create(0, 0, 0),
                    vr._btTempQuaternion0 = e.btQuaternion_create(0, 0, 0, 1), vr._btTempQuaternion1 = e.btQuaternion_create(0, 0, 0, 1),
                    vr._btTempTransform0 = e.btTransform_create(), vr._btTempTransform1 = e.btTransform_create();
            }
        }, {
            key: "createConstraint",
            value: function createConstraint() {}
        }]);
        return vr;
    }();
    vr.PHYSICSENGINEFLAGS_NONE = 0, vr.PHYSICSENGINEFLAGS_COLLISIONSONLY = 1, vr.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT = 2,
        vr.PHYSICSENGINEFLAGS_MULTITHREADED = 4, vr.PHYSICSENGINEFLAGS_USEHARDWAREWHENPOSSIBLE = 8,
        vr.SOLVERMODE_RANDMIZE_ORDER = 1, vr.SOLVERMODE_FRICTION_SEPARATE = 2, vr.SOLVERMODE_USE_WARMSTARTING = 4,
        vr.SOLVERMODE_USE_2_FRICTION_DIRECTIONS = 16, vr.SOLVERMODE_ENABLE_FRICTION_DIRECTION_CACHING = 32,
        vr.SOLVERMODE_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION = 64, vr.SOLVERMODE_CACHE_FRIENDLY = 128,
        vr.SOLVERMODE_SIMD = 256, vr.SOLVERMODE_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS = 512,
        vr.SOLVERMODE_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS = 1024, vr._tempVector30 = new n(),
        vr.disableSimulation = !1;
    var xr = /* */ function() {
        function xr() {
            var _this62 = this;
            _classCallCheck(this, xr);
            this._eventList = [], this._mouseTouch = new sr(), this._touchPool = [], this._touches = new ar(),
                this._multiTouchEnabled = !0, this._pushEventList = function(e) {
                    e.cancelable && e.preventDefault(), _this62._eventList.push(e);
                }.bind(this);
        }
        _createClass(xr, [{
            key: "__init__",
            value: function __init__(e, t) {
                this._scene = t, e.oncontextmenu = function(e) {
                    return !1;
                };
            }
        }, {
            key: "_onCanvasEvent",
            value: function _onCanvasEvent(e) {
                e.addEventListener("mousedown", this._pushEventList), e.addEventListener("mouseup", this._pushEventList, !0),
                    e.addEventListener("mousemove", this._pushEventList, !0), e.addEventListener("touchstart", this._pushEventList),
                    e.addEventListener("touchend", this._pushEventList, !0), e.addEventListener("touchmove", this._pushEventList, !0),
                    e.addEventListener("touchcancel", this._pushEventList, !0);
            }
        }, {
            key: "_offCanvasEvent",
            value: function _offCanvasEvent(e) {
                e.removeEventListener("mousedown", this._pushEventList), e.removeEventListener("mouseup", this._pushEventList, !0),
                    e.removeEventListener("mousemove", this._pushEventList, !0), e.removeEventListener("touchstart", this._pushEventList),
                    e.removeEventListener("touchend", this._pushEventList, !0), e.removeEventListener("touchmove", this._pushEventList, !0),
                    e.removeEventListener("touchcancel", this._pushEventList, !0), this._eventList.length = 0,
                    this._touches.clear();
            }
        }, {
            key: "touchCount",
            value: function touchCount() {
                return this._touches.length;
            }
        }, {
            key: "_getTouch",
            value: function _getTouch(e) {
                var t = this._touchPool[e];
                return t || (t = new or(), this._touchPool[e] = t, t._identifier = e), t;
            }
        }, {
            key: "_mouseTouchDown",
            value: function _mouseTouchDown() {
                var e = this._mouseTouch,
                    r = e.sprite;
                if (e._pressedSprite = r, e._pressedLoopCount = t.Stat.loopCount, r) {
                    var i = r._scripts;
                    if (i)
                        for (var a = 0, n = i.length; a < n; a++) {
                            i[a].onMouseDown();
                        }
                }
            }
        }, {
            key: "_mouseTouchUp",
            value: function _mouseTouchUp() {
                var e, t, r = this._mouseTouch,
                    i = r._pressedSprite;
                r._pressedSprite = null, r._pressedLoopCount = -1;
                var a = r.sprite;
                if (a && a === i) {
                    var n = a._scripts;
                    if (n)
                        for (e = 0, t = n.length; e < t; e++) {
                            n[e].onMouseClick();
                        }
                }
                if (i) {
                    var s = i._scripts;
                    if (s)
                        for (e = 0, t = s.length; e < t; e++) {
                            s[e].onMouseUp();
                        }
                }
            }
        }, {
            key: "_mouseTouchRayCast",
            value: function _mouseTouchRayCast(t) {
                var r = xr._tempHitResult0,
                    i = xr._tempVector20,
                    a = xr._tempRay0;
                r.succeeded = !1;
                var n = this._mouseTouch.mousePositionX,
                    s = this._mouseTouch.mousePositionY;
                i.x = n, i.y = s;
                for (var o = t.length - 1; o >= 0; o--) {
                    var l = t[o],
                        _ = l.viewport;
                    if (i.x >= _.x && i.y >= _.y && i.x <= _.width && i.y <= _.height)
                        if (l.viewportPointToRay(i, a),
                            this._scene._physicsSimulation.rayCast(a, r) || l.clearFlag === e.CameraClearFlags.SolidColor || l.clearFlag === e.CameraClearFlags.Sky) break;
                }
                var h = this._mouseTouch,
                    c = h.sprite;
                if (r.succeeded) {
                    var d = r.collider.owner;
                    h.sprite = d;
                    var u = d._scripts;
                    if (c !== d && u)
                        for (var m = 0, f = u.length; m < f; m++) {
                            u[m].onMouseEnter();
                        }
                } else h.sprite = null;
                if (c && c !== d) {
                    var E = c._scripts;
                    if (E)
                        for (m = 0, f = E.length; m < f; m++) {
                            E[m].onMouseOut();
                        }
                }
            }
        }, {
            key: "_changeTouches",
            value: function _changeTouches(e, r) {
                for (var i = 0, a = 0, n = this._touches.length, s = 0, o = e.length; s < o; s++) {
                    var l = e[s],
                        _ = l.identifier;
                    if (this._multiTouchEnabled || 0 === _) {
                        var h = this._getTouch(_),
                            c = h._position,
                            d = xr._tempPoint;
                        d.setTo(l.pageX, l.pageY), t.ILaya.stage._canvasTransform.invertTransformPoint(d);
                        var u = d.x,
                            m = d.y;
                        switch (r) {
                            case 0:
                                this._touches.add(h), i += u, a += m;
                                break;

                            case 1:
                                this._touches.remove(h), i -= u, a -= m;
                                break;

                            case 2:
                                i = u - c.x, a = m - c.y;
                        }
                        c.x = u, c.y = m;
                    }
                }
                var f = this._touches.length;
                0 === f ? (this._mouseTouch.mousePositionX = 0, this._mouseTouch.mousePositionY = 0) : (this._mouseTouch.mousePositionX = (this._mouseTouch.mousePositionX * n + i) / f,
                    this._mouseTouch.mousePositionY = (this._mouseTouch.mousePositionY * n + a) / f);
            }
        }, {
            key: "_update",
            value: function _update() {
                var e, r, i, a, n = x._enablePhysics && !vr.disableSimulation;
                r = this._eventList.length;
                var s = this._scene._cameraPool;
                if (r > 0) {
                    var o = !1;
                    for (e = 0; e < r; e++) {
                        var l = this._eventList[e];
                        switch (l.type) {
                            case "mousedown":
                                n && this._mouseTouchDown();
                                break;

                            case "mouseup":
                                n && this._mouseTouchUp();
                                break;

                            case "mousemove":
                                var _ = xr._tempPoint;
                                _.setTo(l.pageX, l.pageY), t.ILaya.stage._canvasTransform.invertTransformPoint(_),
                                    this._mouseTouch.mousePositionX = _.x, this._mouseTouch.mousePositionY = _.y, n && (o = !0);
                                break;

                            case "touchstart":
                                var h = this._touches.length;
                                this._changeTouches(l.changedTouches, 0), n && (o = !0, 0 === h && this._mouseTouchDown());
                                break;

                            case "touchend":
                            case "touchcancel":
                                this._changeTouches(l.changedTouches, 1), n && 0 === this._touches.length && this._mouseTouchUp();
                                break;

                            case "touchmove":
                                this._changeTouches(l.changedTouches, 2), n && (o = !0);
                                break;

                            default:
                                throw "Input3D:unkonwn event type.";
                        }
                    }
                    o && this._mouseTouchRayCast(s), this._eventList.length = 0;
                }
                if (n) {
                    var c = this._mouseTouch,
                        d = c._pressedSprite;
                    if (d && t.Stat.loopCount > c._pressedLoopCount) {
                        var u = d._scripts;
                        if (u)
                            for (i = 0, a = u.length; i < a; i++) {
                                u[i].onMouseDrag();
                            }
                    }
                    var m = c.sprite;
                    if (m) {
                        var f = m._scripts;
                        if (f)
                            for (i = 0, a = f.length; i < a; i++) {
                                f[i].onMouseOver();
                            }
                    }
                }
            }
        }, {
            key: "getTouch",
            value: function getTouch(e) {
                return e < this._touches.length ? this._touches.elements[e] : null;
            }
        }, {
            key: "multiTouchEnabled",
            get: function get() {
                return this._multiTouchEnabled;
            },
            set: function set(e) {
                this._multiTouchEnabled = e;
            }
        }]);
        return xr;
    }();
    xr._tempPoint = new t.Point(), xr._tempVector20 = new i(), xr._tempRay0 = new Ue(new n(), new n()),
        xr._tempHitResult0 = new lr();
    var Ir = function Ir() {
        _classCallCheck(this, Ir);
        this.flags = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 / 60;
    };
    var Ar = /* */ function() {
        _createClass(Ar, [{
            key: "position",
            get: function get() {
                return this._position;
            }
        }, {
            key: "textureCoordinate0",
            get: function get() {
                return this._textureCoordinate0;
            }
        }, {
            key: "vertexDeclaration",
            get: function get() {
                return Ar._vertexDeclaration;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                Ar._vertexDeclaration = new _e(20, [new he(0, le.Vector3, ce.MESH_POSITION0), new he(12, le.Vector2, ce.MESH_TEXTURECOORDINATE0)]);
            }
        }, {
            key: "vertexDeclaration",
            get: function get() {
                return Ar._vertexDeclaration;
            }
        }]);

        function Ar(e, t) {
            _classCallCheck(this, Ar);
            this._position = e, this._textureCoordinate0 = t;
        }
        return Ar;
    }();
    var Mr = /* */ function(_Ze2) {
        _inherits(Mr, _Ze2);

        function Mr() {
            var _this63;
            var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 48;
            var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 48;
            _classCallCheck(this, Mr);
            _this63 = _possibleConstructorReturn(this, _getPrototypeOf(Mr).call(this));
            var a = t.LayaGL.instance;
            _this63._stacks = r, _this63._slices = i;
            for (var n = Ar.vertexDeclaration, s = n.vertexStride / 4, o = (_this63._stacks + 1) * (_this63._slices + 1), l = 3 * _this63._stacks * (_this63._slices + 1) * 2, _ = new Float32Array(o * s), h = new Uint16Array(l), c = Math.PI / _this63._stacks, d = 2 * Math.PI / _this63._slices, u = 0, m = 0, f = 0, E = 0; E < _this63._stacks + 1; E++) {
                for (var T = Math.sin(E * c), p = Math.cos(E * c), g = 0; g < _this63._slices + 1; g++) {
                    var S = T * Math.sin(g * d),
                        R = T * Math.cos(g * d);
                    _[m + 0] = S * Mr._radius, _[m + 1] = p * Mr._radius, _[m + 2] = R * Mr._radius,
                        _[m + 3] = -g / _this63._slices + .75, _[m + 4] = E / _this63._stacks, m += s, E != _this63._stacks - 1 && (h[f++] = u + 1,
                            h[f++] = u, h[f++] = u + (_this63._slices + 1), h[f++] = u + (_this63._slices + 1),
                            h[f++] = u, h[f++] = u + _this63._slices, u++);
                }
            }
            _this63._vertexBuffer = new be(4 * _.length, a.STATIC_DRAW, !1), _this63._vertexBuffer.vertexDeclaration = n,
                _this63._indexBuffer = new Ye(e.IndexFormat.UInt16, h.length, a.STATIC_DRAW, !1),
                _this63._vertexBuffer.setData(_.buffer), _this63._indexBuffer.setData(h);
            var v = new Xe();
            v.bind(), v.applyVertexBuffer(_this63._vertexBuffer), v.applyIndexBuffer(_this63._indexBuffer),
                v.unBind(), _this63._bufferState = v;
            return _this63;
        }
        _createClass(Mr, [{
            key: "_render",
            value: function _render(e) {
                var r = t.LayaGL.instance,
                    i = this._indexBuffer.indexCount;
                r.drawElements(r.TRIANGLES, i, r.UNSIGNED_SHORT, 0), t.Stat.trianglesFaces += i / 3,
                    t.Stat.renderBatches++;
            }
        }, {
            key: "stacks",
            get: function get() {
                return this._stacks;
            }
        }, {
            key: "slices",
            get: function get() {
                return this._slices;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                Mr.instance = new Mr();
            }
        }]);
        return Mr;
    }(Ze);
    Mr._radius = 1;
    var Dr = /* */ function(_t$BaseTexture2) {
        _inherits(Dr, _t$BaseTexture2);

        function Dr(e) {
            var _this64;
            var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : t.TextureFormat.R8G8B8;
            var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
            _classCallCheck(this, Dr);
            _this64 = _possibleConstructorReturn(this, _getPrototypeOf(Dr).call(this, r, i)),
                _this64._glTextureType = t.LayaGL.instance.TEXTURE_CUBE_MAP, _this64._width = e,
                _this64._height = e;
            var a = t.LayaGL.instance;
            if (_this64._setWarpMode(a.TEXTURE_WRAP_S, _this64._wrapModeU), _this64._setWarpMode(a.TEXTURE_WRAP_T, _this64._wrapModeV),
                _this64._setFilterMode(_this64._filterMode), _this64._setAnisotropy(_this64._anisoLevel),
                _this64._mipmap) {
                _this64._mipmapCount = Math.ceil(Math.log2(e)) + 1;
                for (var n = 0; n < _this64._mipmapCount; n++) {
                    _this64._setPixels([], n, Math.max(e >> n, 1), Math.max(e >> n, 1));
                }
                _this64._setGPUMemory(e * e * 4 * (1 + 1 / 3) * 6);
            } else _this64._mipmapCount = 1, _this64._setGPUMemory(e * e * 4 * 6);
            return _this64;
        }
        _createClass(Dr, [{
            key: "_setPixels",
            value: function _setPixels(e, r, i, a) {
                var n = t.LayaGL.instance,
                    s = this._getGLFormat();
                t.WebGLContext.bindTexture(n, this._glTextureType, this._glTexture), this.format === t.TextureFormat.R8G8B8 ? (n.pixelStorei(n.UNPACK_ALIGNMENT, 1),
                    n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_Z, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[0]),
                    n.texImage2D(n.TEXTURE_CUBE_MAP_NEGATIVE_Z, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[1]),
                    n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[2]),
                    n.texImage2D(n.TEXTURE_CUBE_MAP_NEGATIVE_X, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[3]),
                    n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_Y, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[4]),
                    n.texImage2D(n.TEXTURE_CUBE_MAP_NEGATIVE_Y, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[5]),
                    n.pixelStorei(n.UNPACK_ALIGNMENT, 4)) : (n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_Z, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[0]),
                    n.texImage2D(n.TEXTURE_CUBE_MAP_NEGATIVE_Z, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[1]),
                    n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[2]),
                    n.texImage2D(n.TEXTURE_CUBE_MAP_NEGATIVE_X, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[3]),
                    n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_Y, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[4]),
                    n.texImage2D(n.TEXTURE_CUBE_MAP_NEGATIVE_Y, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[5]));
            }
        }, {
            key: "setSixSideImageSources",
            value: function setSixSideImageSources(e) {
                var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
                for (var i, a, n = 0; n < 6; n++) {
                    var s = e[n];
                    if (!s) return void console.log("TextureCube: image Source can't be null.");
                    var o = s.width,
                        l = s.height;
                    if (n > 0 && i !== o) return void console.log("TextureCube: each side image's width and height must same.");
                    if ((i = o) !== (a = l)) return void console.log("TextureCube: each side image's width and height must same.");
                }
                this._width = i, this._height = a;
                var _ = t.LayaGL.instance;
                t.WebGLContext.bindTexture(_, this._glTextureType, this._glTexture);
                var h = this._getGLFormat();
                if (t.Render.isConchApp) {
                    if (1 == r)
                        for (var c = 0; c < 6; c++) {
                            e[c].setPremultiplyAlpha(r);
                        }
                    _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[0]),
                        _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[1]),
                        _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_X, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[2]),
                        _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[3]),
                        _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[4]),
                        _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[5]);
                } else r && _.pixelStorei(_.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, h, h, _.UNSIGNED_BYTE, e[0]),
                    _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, h, h, _.UNSIGNED_BYTE, e[1]), _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_X, 0, h, h, _.UNSIGNED_BYTE, e[2]),
                    _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, h, h, _.UNSIGNED_BYTE, e[3]), _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, h, h, _.UNSIGNED_BYTE, e[4]),
                    _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, h, h, _.UNSIGNED_BYTE, e[5]), r && _.pixelStorei(_.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1);
                this._mipmap && this._isPot(i) && this._isPot(a) ? (_.generateMipmap(this._glTextureType),
                        this._setGPUMemory(i * a * 4 * (1 + 1 / 3) * 6)) : this._setGPUMemory(i * a * 4 * 6),
                    this._setWarpMode(_.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(_.TEXTURE_WRAP_T, this._wrapModeV),
                    this._setFilterMode(this._filterMode), this._readyed = !0, this._activeResource();
            }
        }, {
            key: "setSixSidePixels",
            value: function setSixSidePixels(e) {
                var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                if (!e) throw new Error("TextureCube:pixels can't be null.");
                var i = Math.max(this._width >> r, 1),
                    a = Math.max(this._height >> r, 1),
                    n = i * a * this._getFormatByteCount();
                if (e[0].length < n) throw "TextureCube:pixels length should at least " + n + ".";
                if (this._setPixels(e, r, i, a), 0 === r) {
                    var s = t.LayaGL.instance;
                    this._setWarpMode(s.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(s.TEXTURE_WRAP_T, this._wrapModeV);
                }
                this._readyed = !0, this._activeResource();
            }
        }, {
            key: "_recoverResource",
            value: function _recoverResource() {}
        }, {
            key: "defaulteTexture",
            get: function get() {
                return Dr.grayTexture;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                var e = new Dr(1, t.TextureFormat.R8G8B8, !1),
                    r = new Dr(1, t.TextureFormat.R8G8B8, !1),
                    i = new Uint8Array(3);
                i[0] = 0, i[1] = 0, i[2] = 0, e.setSixSidePixels([i, i, i, i, i, i]), e.lock = !0,
                    i[0] = 128, i[1] = 128, i[2] = 128, r.setSixSidePixels([i, i, i, i, i, i]), r.lock = !0,
                    Dr._grayTexture = r, Dr._blackTexture = e;
            }
        }, {
            key: "_parse",
            value: function _parse(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i = r ? new Dr(0, r[0], r[1]) : new Dr(0);
                return i.setSixSideImageSources(e), i;
            }
        }, {
            key: "_parseBin",
            value: function _parseBin(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i = r ? new Dr(0, r[0], r[1]) : new Dr(0);
                return i.setSixSideImageSources(e), i;
            }
        }, {
            key: "load",
            value: function load(e, r) {
                t.ILaya.loader.create(e, r, null, Dr.TEXTURECUBE);
            }
        }, {
            key: "blackTexture",
            get: function get() {
                return Dr._blackTexture;
            }
        }, {
            key: "grayTexture",
            get: function get() {
                return Dr._grayTexture;
            }
        }]);
        return Dr;
    }(t.BaseTexture);
    Dr.TEXTURECUBE = "TEXTURECUBE";
    var Lr = /* */ function() {
        function Lr() {
            _classCallCheck(this, Lr);
            this._length = 0, this._elements = [];
        }
        _createClass(Lr, [{
            key: "add",
            value: function add(e) {
                this._length === this._elements.length ? this._elements.push(e) : this._elements[this._length] = e,
                    this._length++;
            }
        }, {
            key: "remove",
            value: function remove(e) {
                var t = this._elements.indexOf(e);
                if (this._length--, t !== this._length) {
                    var r = this._elements[this._length];
                    this._elements[t] = r;
                }
            }
        }, {
            key: "shift",
            value: function shift() {
                return this._length--, this._elements.shift();
            }
        }]);
        return Lr;
    }();
    var yr = /* */ function(_Lr) {
        _inherits(yr, _Lr);

        function yr() {
            _classCallCheck(this, yr);
            return _possibleConstructorReturn(this, _getPrototypeOf(yr).apply(this, arguments));
        }
        _createClass(yr, [{
            key: "getSunLight",
            value: function getSunLight() {
                for (var e, t = -1, r = this._elements, i = 0; i < this._length; i++) {
                    var a = r[i]._intensity;
                    t < a && (t = a, e = i);
                }
                return e;
            }
        }]);
        return yr;
    }(Lr);
    var Cr = /* */ function(_Lr2) {
        _inherits(Cr, _Lr2);

        function Cr() {
            _classCallCheck(this, Cr);
            return _possibleConstructorReturn(this, _getPrototypeOf(Cr).apply(this, arguments));
        }
        _createClass(Cr, [{
            key: "remove",
            value: function remove(e) {
                var t = this._elements.indexOf(e);
                this._elements.splice(t, 1), this._length--;
            }
        }]);
        return Cr;
    }(Lr);
    var Or = /* */ function(_Pe5) {
        _inherits(Or, _Pe5);

        function Or(e, r) {
            var _this65;
            _classCallCheck(this, Or);
            _this65 = _possibleConstructorReturn(this, _getPrototypeOf(Or).call(this)), _this65._floatCountPerVertices = 7,
                _this65._minUpdate = Number.MAX_VALUE, _this65._maxUpdate = Number.MIN_VALUE, _this65._bufferState = new Xe(),
                _this65._floatBound = new Float32Array(6), _this65._calculateBound = !1, _this65._maxLineCount = 0,
                _this65._lineCount = 0;
            var i = 2 * r;
            _this65._owner = e, _this65._maxLineCount = r, _this65._vertices = new Float32Array(i * _this65._floatCountPerVertices),
                _this65._vertexBuffer = new be(ir.vertexDeclaration.vertexStride * i, t.LayaGL.instance.STATIC_DRAW, !1),
                _this65._vertexBuffer.vertexDeclaration = ir.vertexDeclaration, _this65._bufferState.bind(),
                _this65._bufferState.applyVertexBuffer(_this65._vertexBuffer), _this65._bufferState.unBind();
            var a = Or._tempVector0,
                n = Or._tempVector1;
            a.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), n.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE),
                _this65._bounds = new ut(a, n);
            return _this65;
        }
        _createClass(Or, [{
            key: "_getType",
            value: function _getType() {
                return Or._type;
            }
        }, {
            key: "_resizeLineData",
            value: function _resizeLineData(e) {
                var r = 2 * e,
                    i = this._vertices;
                this._vertexBuffer.destroy(), this._maxLineCount = e;
                var a = r * this._floatCountPerVertices;
                this._vertices = new Float32Array(a), this._vertexBuffer = new be(ir.vertexDeclaration.vertexStride * r, t.LayaGL.instance.STATIC_DRAW, !1),
                    this._vertexBuffer.vertexDeclaration = ir.vertexDeclaration, a < i.length ? (this._vertices.set(new Float32Array(i.buffer, 0, a)),
                        this._vertexBuffer.setData(this._vertices.buffer, 0, 0, 4 * a)) : (this._vertices.set(i),
                        this._vertexBuffer.setData(this._vertices.buffer, 0, 0, 4 * i.length)), this._bufferState.bind(),
                    this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.unBind();
            }
        }, {
            key: "_updateLineVertices",
            value: function _updateLineVertices(e, t, r, i, a) {
                t && (this._vertices[e + 0] = t.x, this._vertices[e + 1] = t.y, this._vertices[e + 2] = t.z),
                    i && (this._vertices[e + 3] = i.r, this._vertices[e + 4] = i.g, this._vertices[e + 5] = i.b,
                        this._vertices[e + 6] = i.a), r && (this._vertices[e + 7] = r.x, this._vertices[e + 8] = r.y,
                        this._vertices[e + 9] = r.z), a && (this._vertices[e + 10] = a.r, this._vertices[e + 11] = a.g,
                        this._vertices[e + 12] = a.b, this._vertices[e + 13] = a.a), this._minUpdate = Math.min(this._minUpdate, e),
                    this._maxUpdate = Math.max(this._maxUpdate, e + 2 * this._floatCountPerVertices);
                var s = this._bounds,
                    o = this._floatBound,
                    l = s.getMin(),
                    _ = s.getMax();
                n.min(l, t, l), n.min(l, r, l), n.max(_, t, _), n.max(_, r, _), s.setMin(l), s.setMax(_),
                    o[0] = l.x, o[1] = l.y, o[2] = l.z, o[3] = _.x, o[4] = _.y, o[5] = _.z;
            }
        }, {
            key: "_reCalculateBound",
            value: function _reCalculateBound() {
                if (this._calculateBound) {
                    var e = this._vertices,
                        t = Or._tempVector0,
                        r = Or._tempVector1;
                    t.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), r.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                    for (var i = 0; i < 2 * this._lineCount; ++i) {
                        var a = this._floatCountPerVertices * i,
                            n = e[a + 0],
                            s = e[a + 1],
                            o = e[a + 2];
                        t.x = Math.min(n, t.x), t.y = Math.min(s, t.y), t.z = Math.min(o, t.z), r.x = Math.max(n, r.x),
                            r.y = Math.max(s, r.y), r.z = Math.max(o, r.z);
                    }
                    this._bounds.setMin(t), this._bounds.setMax(r);
                    var l = this._floatBound;
                    l[0] = t.x, l[1] = t.y, l[2] = t.z, l[3] = r.x, l[4] = r.y, l[5] = r.z, this._calculateBound = !1;
                }
            }
        }, {
            key: "_removeLineData",
            value: function _removeLineData(e) {
                var t = 2 * this._floatCountPerVertices,
                    r = e + 1,
                    i = e * t,
                    a = this._vertices,
                    n = new Float32Array(a.buffer, r * t * 4, (this._lineCount - r) * t);
                a.set(n, i), this._minUpdate = Math.min(this._minUpdate, i), this._maxUpdate = Math.max(this._maxUpdate, i + n.length),
                    this._lineCount--;
                var s = this._floatBound,
                    o = a[i],
                    l = a[i + 1],
                    _ = a[i + 2],
                    h = a[i + 7],
                    c = a[i + 8],
                    d = a[i + 9],
                    u = s[0],
                    m = s[1],
                    f = s[2],
                    E = s[3],
                    T = s[4],
                    p = s[5];
                o !== u && o !== E && l !== m && l !== T && _ !== f && _ !== p && h !== u && h !== E && c !== m && c !== T && d !== f && d !== p || (this._calculateBound = !0);
            }
        }, {
            key: "_updateLineData",
            value: function _updateLineData(e, t, r, i, a) {
                var n = 2 * this._floatCountPerVertices;
                this._updateLineVertices(e * n, t, r, i, a);
            }
        }, {
            key: "_updateLineDatas",
            value: function _updateLineDatas(e, t) {
                for (var r = 2 * this._floatCountPerVertices, i = t.length, a = 0; a < i; a++) {
                    var n = t[a];
                    this._updateLineVertices((e + a) * r, n.startPosition, n.endPosition, n.startColor, n.endColor);
                }
            }
        }, {
            key: "_getLineData",
            value: function _getLineData(e, t) {
                var r = t.startPosition,
                    i = t.startColor,
                    a = t.endPosition,
                    n = t.endColor,
                    s = this._vertices,
                    o = e * this._floatCountPerVertices * 2;
                r.x = s[o + 0], r.y = s[o + 1], r.z = s[o + 2], i.r = s[o + 3], i.g = s[o + 4],
                    i.b = s[o + 5], i.a = s[o + 6], a.x = s[o + 7], a.y = s[o + 8], a.z = s[o + 9],
                    n.r = s[o + 10], n.g = s[o + 11], n.b = s[o + 12], n.a = s[o + 13];
            }
        }, {
            key: "_prepareRender",
            value: function _prepareRender(e) {
                return !0;
            }
        }, {
            key: "_render",
            value: function _render(e) {
                if (this._minUpdate !== Number.MAX_VALUE && this._maxUpdate !== Number.MIN_VALUE && (this._vertexBuffer.setData(this._vertices.buffer, 4 * this._minUpdate, 4 * this._minUpdate, 4 * (this._maxUpdate - this._minUpdate)),
                        this._minUpdate = Number.MAX_VALUE, this._maxUpdate = Number.MIN_VALUE), this._lineCount > 0) {
                    this._bufferState.bind();
                    var r = t.LayaGL.instance;
                    r.drawArrays(r.LINES, 0, 2 * this._lineCount), t.Stat.renderBatches++;
                }
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._destroyed || (_get(_getPrototypeOf(Or.prototype), "destroy", this).call(this),
                    this._bufferState.destroy(), this._vertexBuffer.destroy(), this._bufferState = null,
                    this._vertexBuffer = null, this._vertices = null);
            }
        }]);
        return Or;
    }(Pe);
    Or._tempVector0 = new n(), Or._tempVector1 = new n(), Or._type = Pe._typeCounter++;
    var Nr = /* */ function(_mt3) {
        _inherits(Nr, _mt3);

        function Nr(e) {
            var _this66;
            _classCallCheck(this, Nr);
            _this66 = _possibleConstructorReturn(this, _getPrototypeOf(Nr).call(this, e)), _this66._projectionViewWorldMatrix = new C();
            return _this66;
        }
        _createClass(Nr, [{
            key: "_calculateBoundingBox",
            value: function _calculateBoundingBox() {
                var e = this._owner.transform.worldMatrix,
                    r = this._owner._geometryFilter;
                if (r._reCalculateBound(), r._bounds._tranform(e, this._bounds), t.Render.supportWebGLPlusCulling) {
                    var i = this._bounds.getMin(),
                        a = this._bounds.getMax(),
                        n = Oe._cullingBuffer;
                    n[this._cullingBufferIndex + 1] = i.x, n[this._cullingBufferIndex + 2] = i.y, n[this._cullingBufferIndex + 3] = i.z,
                        n[this._cullingBufferIndex + 4] = a.x, n[this._cullingBufferIndex + 5] = a.y, n[this._cullingBufferIndex + 6] = a.z;
                }
            }
        }, {
            key: "_renderUpdateWithCamera",
            value: function _renderUpdateWithCamera(e, t) {
                var r = e.projectionViewMatrix,
                    i = this._shaderValues;
                if (t) {
                    var a = t.worldMatrix;
                    i.setMatrix4x4(Le.WORLDMATRIX, a), C.multiply(r, a, this._projectionViewWorldMatrix),
                        i.setMatrix4x4(Le.MVPMATRIX, this._projectionViewWorldMatrix);
                } else i.setMatrix4x4(Le.WORLDMATRIX, C.DEFAULT), i.setMatrix4x4(Le.MVPMATRIX, r);
            }
        }]);
        return Nr;
    }(mt);
    var Pr = /* */ function(_ye3) {
        _inherits(Pr, _ye3);
        _createClass(Pr, [{
            key: "maxLineCount",
            get: function get() {
                return this._geometryFilter._maxLineCount;
            },
            set: function set(e) {
                this._geometryFilter._resizeLineData(e), this._geometryFilter._lineCount = Math.min(this._geometryFilter._lineCount, e);
            }
        }, {
            key: "lineCount",
            get: function get() {
                return this._geometryFilter._lineCount;
            },
            set: function set(e) {
                if (e > this.maxLineCount) throw "PixelLineSprite3D: lineCount can't large than maxLineCount";
                this._geometryFilter._lineCount = e;
            }
        }, {
            key: "pixelLineRenderer",
            get: function get() {
                return this._render;
            }
        }]);

        function Pr() {
            var _this67;
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            _classCallCheck(this, Pr);
            _this67 = _possibleConstructorReturn(this, _getPrototypeOf(Pr).call(this, t)), _this67._geometryFilter = new Or(_assertThisInitialized(_this67), e),
                _this67._render = new Nr(_assertThisInitialized(_this67)), _this67._changeRenderObjects(_this67._render, 0, rr.defaultMaterial);
            return _this67;
        }
        _createClass(Pr, [{
            key: "_changeRenderObjects",
            value: function _changeRenderObjects(e, t, r) {
                var i = this._render._renderElements;
                r || (r = rr.defaultMaterial);
                var a = i[t];
                a || (a = i[t] = new st()), a.setTransform(this._transform), a.setGeometry(this._geometryFilter),
                    a.render = this._render, a.material = r;
            }
        }, {
            key: "addLine",
            value: function addLine(e, t, r, i) {
                if (this._geometryFilter._lineCount === this._geometryFilter._maxLineCount) throw "PixelLineSprite3D: lineCount has equal with maxLineCount.";
                this._geometryFilter._updateLineData(this._geometryFilter._lineCount++, e, t, r, i);
            }
        }, {
            key: "addLines",
            value: function addLines(e) {
                var t = this._geometryFilter._lineCount,
                    r = e.length;
                if (t + r > this._geometryFilter._maxLineCount) throw "PixelLineSprite3D: lineCount plus lines count must less than maxLineCount.";
                this._geometryFilter._updateLineDatas(t, e), this._geometryFilter._lineCount += r;
            }
        }, {
            key: "removeLine",
            value: function removeLine(e) {
                if (!(e < this._geometryFilter._lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
                this._geometryFilter._removeLineData(e);
            }
        }, {
            key: "setLine",
            value: function setLine(e, t, r, i, a) {
                if (!(e < this._geometryFilter._lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
                this._geometryFilter._updateLineData(e, t, r, i, a);
            }
        }, {
            key: "getLine",
            value: function getLine(e, t) {
                if (!(e < this.lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
                this._geometryFilter._getLineData(e, t);
            }
        }, {
            key: "clear",
            value: function clear() {
                this._geometryFilter._lineCount = 0;
            }
        }, {
            key: "_create",
            value: function _create() {
                return new Pr();
            }
        }]);
        return Pr;
    }(ye);
    var br = /* */ function() {
        function br() {
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
            _classCallCheck(this, br);
            this.isTransparent = !1, this.elements = new _t(), this.lastTransparentRenderElement = null,
                this.lastTransparentBatched = !1, this.isTransparent = e;
        }
        _createClass(br, [{
            key: "_compare",
            value: function _compare(e, t) {
                var r = e.material.renderQueue - t.material.renderQueue;
                return 0 === r ? (this.isTransparent ? t.render._distanceForSort - e.render._distanceForSort : e.render._distanceForSort - t.render._distanceForSort) + t.render.sortingFudge - e.render.sortingFudge : r;
            }
        }, {
            key: "_partitionRenderObject",
            value: function _partitionRenderObject(e, t) {
                for (var r = this.elements.elements, i = r[Math.floor((t + e) / 2)]; e <= t;) {
                    for (; this._compare(r[e], i) < 0;) {
                        e++;
                    }
                    for (; this._compare(r[t], i) > 0;) {
                        t--;
                    }
                    if (e < t) {
                        var a = r[e];
                        r[e] = r[t], r[t] = a, e++, t--;
                    } else if (e === t) {
                        e++;
                        break;
                    }
                }
                return e;
            }
        }, {
            key: "_quickSort",
            value: function _quickSort(e, t) {
                if (this.elements.length > 1) {
                    var r = this._partitionRenderObject(e, t),
                        i = r - 1;
                    e < i && this._quickSort(e, i), r < t && this._quickSort(r, t);
                }
            }
        }, {
            key: "_render",
            value: function _render(e) {
                for (var t = this.elements.elements, r = 0, i = this.elements.length; r < i; r++) {
                    t[r]._render(e);
                }
            }
        }, {
            key: "clear",
            value: function clear() {
                this.elements.length = 0, this.lastTransparentRenderElement = null, this.lastTransparentBatched = !1;
            }
        }]);
        return br;
    }();
    var Vr = /* */ function() {
        function Vr(e, t, r, i) {
            _classCallCheck(this, Vr);
            this._bounds = new dt(new n(), new n()), this._objects = [], this._isContaion = !1,
                this.center = new n(), this.baseLength = 0, this._setValues(e, t, r, i);
        }
        _createClass(Vr, [{
            key: "_setValues",
            value: function _setValues(e, t, r, i) {
                this._octree = e, this._parent = t, this.baseLength = r, i.cloneTo(this.center);
                var a = this._bounds.min,
                    n = this._bounds.max,
                    s = e._looseness * r / 2;
                a.setValue(i.x - s, i.y - s, i.z - s), n.setValue(i.x + s, i.y + s, i.z + s);
            }
        }, {
            key: "_getChildBound",
            value: function _getChildBound(e) {
                if (null != this._children && this._children[e]) return this._children[e]._bounds;
                var t = this.baseLength / 4,
                    r = this.baseLength / 2 * this._octree._looseness / 2,
                    i = Vr._tempBoundBox,
                    a = i.min,
                    n = i.max;
                switch (e) {
                    case 0:
                        a.x = this.center.x - t - r, a.y = this.center.y + t - r, a.z = this.center.z - t - r,
                            n.x = this.center.x - t + r, n.y = this.center.y + t + r, n.z = this.center.z - t + r;
                        break;

                    case 1:
                        a.x = this.center.x + t - r, a.y = this.center.y + t - r, a.z = this.center.z - t - r,
                            n.x = this.center.x + t + r, n.y = this.center.y + t + r, n.z = this.center.z - t + r;
                        break;

                    case 2:
                        a.x = this.center.x - t - r, a.y = this.center.y + t - r, a.z = this.center.z + t - r,
                            n.x = this.center.x - t + r, n.y = this.center.y + t + r, n.z = this.center.z + t + r;
                        break;

                    case 3:
                        a.x = this.center.x + t - r, a.y = this.center.y + t - r, a.z = this.center.z + t - r,
                            n.x = this.center.x + t + r, n.y = this.center.y + t + r, n.z = this.center.z + t + r;
                        break;

                    case 4:
                        a.x = this.center.x - t - r, a.y = this.center.y - t - r, a.z = this.center.z - t - r,
                            n.x = this.center.x - t + r, n.y = this.center.y - t + r, n.z = this.center.z - t + r;
                        break;

                    case 5:
                        a.x = this.center.x + t - r, a.y = this.center.y - t - r, a.z = this.center.z - t - r,
                            n.x = this.center.x + t + r, n.y = this.center.y - t + r, n.z = this.center.z - t + r;
                        break;

                    case 6:
                        a.x = this.center.x - t - r, a.y = this.center.y - t - r, a.z = this.center.z + t - r,
                            n.x = this.center.x - t + r, n.y = this.center.y - t + r, n.z = this.center.z + t + r;
                        break;

                    case 7:
                        a.x = this.center.x + t - r, a.y = this.center.y - t - r, a.z = this.center.z + t - r,
                            n.x = this.center.x + t + r, n.y = this.center.y - t + r, n.z = this.center.z + t + r;
                }
                return i;
            }
        }, {
            key: "_getChildCenter",
            value: function _getChildCenter(e) {
                if (null != this._children) return this._children[e].center;
                var t = this.baseLength / 4,
                    r = Vr._tempVector30;
                switch (e) {
                    case 0:
                        r.x = this.center.x - t, r.y = this.center.y + t, r.z = this.center.z - t;
                        break;

                    case 1:
                        r.x = this.center.x + t, r.y = this.center.y + t, r.z = this.center.z - t;
                        break;

                    case 2:
                        r.x = this.center.x - t, r.y = this.center.y + t, r.z = this.center.z + t;
                        break;

                    case 3:
                        r.x = this.center.x + t, r.y = this.center.y + t, r.z = this.center.z + t;
                        break;

                    case 4:
                        r.x = this.center.x - t, r.y = this.center.y - t, r.z = this.center.z - t;
                        break;

                    case 5:
                        r.x = this.center.x + t, r.y = this.center.y - t, r.z = this.center.z - t;
                        break;

                    case 6:
                        r.x = this.center.x - t, r.y = this.center.y - t, r.z = this.center.z + t;
                        break;

                    case 7:
                        r.x = this.center.x + t, r.y = this.center.y - t, r.z = this.center.z + t;
                }
                return r;
            }
        }, {
            key: "_getChild",
            value: function _getChild(e) {
                var t = this.baseLength / 4;
                switch (this._children || (this._children = []), e) {
                    case 0:
                        return this._children[0] || (this._children[0] = new Vr(this._octree, this, this.baseLength / 2, new n(this.center.x + -t, this.center.y + t, this.center.z - t)));

                    case 1:
                        return this._children[1] || (this._children[1] = new Vr(this._octree, this, this.baseLength / 2, new n(this.center.x + t, this.center.y + t, this.center.z - t)));

                    case 2:
                        return this._children[2] || (this._children[2] = new Vr(this._octree, this, this.baseLength / 2, new n(this.center.x - t, this.center.y + t, this.center.z + t)));

                    case 3:
                        return this._children[3] || (this._children[3] = new Vr(this._octree, this, this.baseLength / 2, new n(this.center.x + t, this.center.y + t, this.center.z + t)));

                    case 4:
                        return this._children[4] || (this._children[4] = new Vr(this._octree, this, this.baseLength / 2, new n(this.center.x - t, this.center.y - t, this.center.z - t)));

                    case 5:
                        return this._children[5] || (this._children[5] = new Vr(this._octree, this, this.baseLength / 2, new n(this.center.x + t, this.center.y - t, this.center.z - t)));

                    case 6:
                        return this._children[6] || (this._children[6] = new Vr(this._octree, this, this.baseLength / 2, new n(this.center.x - t, this.center.y - t, this.center.z + t)));

                    case 7:
                        return this._children[7] || (this._children[7] = new Vr(this._octree, this, this.baseLength / 2, new n(this.center.x + t, this.center.y - t, this.center.z + t)));

                    default:
                        throw "BoundsOctreeNode: unknown index.";
                }
            }
        }, {
            key: "_shouldMerge",
            value: function _shouldMerge() {
                for (var e = this._objects.length, t = 0; t < 8; t++) {
                    var r = this._children[t];
                    if (r) {
                        if (null != r._children) return !1;
                        e += r._objects.length;
                    }
                }
                return e <= Vr._NUM_OBJECTS_ALLOWED;
            }
        }, {
            key: "_mergeChildren",
            value: function _mergeChildren() {
                for (var e = 0; e < 8; e++) {
                    var t = this._children[e];
                    if (t) {
                        t._parent = null;
                        for (var r = t._objects, i = r.length - 1; i >= 0; i--) {
                            var a = r[i];
                            this._objects.push(a), a._setOctreeNode(this);
                        }
                    }
                }
                this._children = null;
            }
        }, {
            key: "_merge",
            value: function _merge() {
                if (null === this._children) {
                    var e = this._parent;
                    e && e._shouldMerge() && (e._mergeChildren(), e._merge());
                }
            }
        }, {
            key: "_checkAddNode",
            value: function _checkAddNode(e) {
                if (null == this._children) {
                    if (this._objects.length < Vr._NUM_OBJECTS_ALLOWED || this.baseLength / 2 < this._octree._minSize) return this;
                    for (var t = this._objects.length - 1; t >= 0; t--) {
                        var r = this._objects[t],
                            i = this._bestFitChild(r.bounds.getCenter());
                        Vr._encapsulates(this._getChildBound(i), r.bounds._getBoundBox()) && (this._objects.splice(this._objects.indexOf(r), 1),
                            this._getChild(i)._add(r));
                    }
                }
                var a = this._bestFitChild(e.bounds.getCenter());
                return Vr._encapsulates(this._getChildBound(a), e.bounds._getBoundBox()) ? this._getChild(a)._checkAddNode(e) : this;
            }
        }, {
            key: "_add",
            value: function _add(e) {
                var t = this._checkAddNode(e);
                t._objects.push(e), e._setOctreeNode(t);
            }
        }, {
            key: "_remove",
            value: function _remove(e) {
                var t = this._objects.indexOf(e);
                this._objects.splice(t, 1), e._setOctreeNode(null), this._merge();
            }
        }, {
            key: "_addUp",
            value: function _addUp(e) {
                return ze.boxContainsBox(this._bounds, e.bounds._getBoundBox()) === Ge.Contains ? (this._add(e), !0) : !!this._parent && this._parent._addUp(e);
            }
        }, {
            key: "_getCollidingWithFrustum",
            value: function _getCollidingWithFrustum(e, r, i, a, s, o, l) {
                if (i) {
                    var _ = r.containsBoundBox(this._bounds);
                    if (t.Stat.octreeNodeCulling++, _ === Ge.Disjoint) return;
                    i = _ === Ge.Intersects;
                }
                this._isContaion = !i;
                for (var h = e.camera, c = e.scene, d = t.Stat.loopCount, u = 0, m = this._objects.length; u < m; u++) {
                    var f = this._objects[u];
                    if (l ? f._castShadow && f._enable : h._isLayerVisible(f._owner._layer) && f._enable) {
                        if (i && (t.Stat.frustumCulling++, !f._needRender(r, e))) continue;
                        f._renderMark = d, f._distanceForSort = n.distance(f.bounds.getCenter(), a);
                        for (var E = f._renderElements, T = 0, p = E.length; T < p; T++) {
                            E[T]._update(c, e, s, o);
                        }
                    }
                }
                if (null != this._children)
                    for (u = 0; u < 8; u++) {
                        var g = this._children[u];
                        g && g._getCollidingWithFrustum(e, r, i, a, s, o, l);
                    }
            }
        }, {
            key: "_getCollidingWithBoundBox",
            value: function _getCollidingWithBoundBox(e, t, r) {
                if (t) {
                    var i = ze.boxContainsBox(this._bounds, e);
                    if (i === Ge.Disjoint) return;
                    t = i === Ge.Intersects;
                }
                if (t)
                    for (var a = 0, n = this._objects.length; a < n; a++) {
                        var s = this._objects[a];
                        ze.intersectsBoxAndBox(s.bounds._getBoundBox(), e) && r.push(s);
                    }
                if (null != this._children)
                    for (a = 0; a < 8; a++) {
                        this._children[a]._getCollidingWithBoundBox(e, t, r);
                    }
            }
        }, {
            key: "_bestFitChild",
            value: function _bestFitChild(e) {
                return (e.x <= this.center.x ? 0 : 1) + (e.y >= this.center.y ? 0 : 4) + (e.z <= this.center.z ? 0 : 2);
            }
        }, {
            key: "_update",
            value: function _update(e) {
                if (ze.boxContainsBox(this._bounds, e.bounds._getBoundBox()) === Ge.Contains) {
                    var t = this._checkAddNode(e);
                    if (t !== e._getOctreeNode()) {
                        t._objects.push(e), e._setOctreeNode(t);
                        var r = this._objects.indexOf(e);
                        this._objects.splice(r, 1), this._merge();
                    }
                    return !0;
                }
                if (this._parent) {
                    var i = this._parent._addUp(e);
                    return i && (r = this._objects.indexOf(e), this._objects.splice(r, 1), this._merge()),
                        i;
                }
                return !1;
            }
        }, {
            key: "add",
            value: function add(e) {
                return !!Vr._encapsulates(this._bounds, e.bounds._getBoundBox()) && (this._add(e), !0);
            }
        }, {
            key: "remove",
            value: function remove(e) {
                return e._getOctreeNode() === this && (this._remove(e), !0);
            }
        }, {
            key: "update",
            value: function update(e) {
                return e._getOctreeNode() === this && this._update(e);
            }
        }, {
            key: "shrinkIfPossible",
            value: function shrinkIfPossible(e) {
                if (this.baseLength < 2 * e) return this;
                for (var t = -1, r = 0, i = this._objects.length; r < i; r++) {
                    var a = this._objects[r],
                        n = this._bestFitChild(a.bounds.getCenter());
                    if (0 != r && n != t) return this;
                    var s = this._getChildBound(n);
                    if (!Vr._encapsulates(s, a.bounds._getBoundBox())) return this;
                    0 == r && (t = n);
                }
                if (null == this._children) {
                    if (-1 != t) {
                        var o = this._getChildCenter(t);
                        this._setValues(this._octree, null, this.baseLength / 2, o);
                    }
                    return this;
                }
                var l = !1;
                for (r = 0, i = this._children.length; r < i; r++) {
                    var _ = this._children[r];
                    if (_ && _.hasAnyObjects()) {
                        if (l) return this;
                        if (t >= 0 && t != r) return this;
                        l = !0, t = r;
                    }
                }
                if (-1 != t) {
                    var h = this._children[t];
                    return h._parent = null, h;
                }
                return this;
            }
        }, {
            key: "hasAnyObjects",
            value: function hasAnyObjects() {
                if (this._objects.length > 0) return !0;
                if (null != this._children)
                    for (var e = 0; e < 8; e++) {
                        var t = this._children[e];
                        if (t && t.hasAnyObjects()) return !0;
                    }
                return !1;
            }
        }, {
            key: "getCollidingWithBoundBox",
            value: function getCollidingWithBoundBox(e, t) {
                this._getCollidingWithBoundBox(e, !0, t);
            }
        }, {
            key: "getCollidingWithRay",
            value: function getCollidingWithRay(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.MAX_VALUE;
                var i = ze.intersectsRayAndBoxRD(e, this._bounds);
                if (!(-1 == i || i > r)) {
                    for (var a = 0, n = this._objects.length; a < n; a++) {
                        var s = this._objects[a]; -
                        1 !== (i = ze.intersectsRayAndBoxRD(e, s.bounds._getBoundBox())) && i <= r && t.push(s);
                    }
                    if (null != this._children)
                        for (a = 0; a < 8; a++) {
                            this._children[a].getCollidingWithRay(e, t, r);
                        }
                }
            }
        }, {
            key: "getCollidingWithFrustum",
            value: function getCollidingWithFrustum(e, t, r, i) {
                var a = e.camera.transform.position,
                    n = e.camera.boundFrustum;
                this._getCollidingWithFrustum(e, n, !0, a, t, r, i);
            }
        }, {
            key: "isCollidingWithBoundBox",
            value: function isCollidingWithBoundBox(e) {
                if (!ze.intersectsBoxAndBox(this._bounds, e)) return !1;
                for (var t = 0, r = this._objects.length; t < r; t++) {
                    var i = this._objects[t];
                    if (ze.intersectsBoxAndBox(i.bounds._getBoundBox(), e)) return !0;
                }
                if (null != this._children)
                    for (t = 0; t < 8; t++) {
                        if (this._children[t].isCollidingWithBoundBox(e)) return !0;
                    }
                return !1;
            }
        }, {
            key: "isCollidingWithRay",
            value: function isCollidingWithRay(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;
                var r = ze.intersectsRayAndBoxRD(e, this._bounds);
                if (-1 == r || r > t) return !1;
                for (var i = 0, a = this._objects.length; i < a; i++) {
                    var n = this._objects[i];
                    if (-1 !== (r = ze.intersectsRayAndBoxRD(e, n.bounds._getBoundBox())) && r <= t) return !0;
                }
                if (null != this._children)
                    for (i = 0; i < 8; i++) {
                        if (this._children[i].isCollidingWithRay(e, t)) return !0;
                    }
                return !1;
            }
        }, {
            key: "getBound",
            value: function getBound() {
                return this._bounds;
            }
        }, {
            key: "drawAllBounds",
            value: function drawAllBounds(e, t, r) {
                if (null !== this._children || 0 != this._objects.length) {
                    t++;
                    var i = Vr._tempColor0;
                    if (this._isContaion) i.r = 0, i.g = 0, i.b = 1;
                    else {
                        var a = r ? t / r : 0;
                        i.r = 1 - a, i.g = a, i.b = 0;
                    }
                    if (i.a = .3, I._drawBound(e, this._bounds, i), null != this._children)
                        for (var n = 0; n < 8; n++) {
                            var s = this._children[n];
                            s && s.drawAllBounds(e, t, r);
                        }
                }
            }
        }, {
            key: "drawAllObjects",
            value: function drawAllObjects(e, t, r) {
                t++;
                var i = Vr._tempColor0;
                if (this._isContaion) i.r = 0, i.g = 0, i.b = 1;
                else {
                    var a = r ? t / r : 0;
                    i.r = 1 - a, i.g = a, i.b = 0;
                }
                i.a = 1;
                for (var n = 0, s = this._objects.length; n < s; n++) {
                    I._drawBound(e, this._objects[n].bounds._getBoundBox(), i);
                }
                if (null != this._children)
                    for (n = 0; n < 8; n++) {
                        var o = this._children[n];
                        o && o.drawAllObjects(e, t, r);
                    }
            }
        }], [{
            key: "_encapsulates",
            value: function _encapsulates(e, t) {
                return ze.boxContainsBox(e, t) == Ge.Contains;
            }
        }]);
        return Vr;
    }();
    Vr._tempVector3 = new n(), Vr._tempVector30 = new n(), Vr._tempVector31 = new n(),
        Vr._tempColor0 = new Ae(), Vr._tempBoundBox = new dt(new n(), new n()), Vr._NUM_OBJECTS_ALLOWED = 8;
    var wr = /* */ function(_t4) {
        _inherits(wr, _t4);

        function wr() {
            _classCallCheck(this, wr);
            return _possibleConstructorReturn(this, _getPrototypeOf(wr).call(this));
        }
        _createClass(wr, [{
            key: "add",
            value: function add(e) {
                if (-1 !== e._getIndexInMotionList()) throw "OctreeMotionList:element has  in  PhysicsUpdateList.";
                this._add(e), e._setIndexInMotionList(this.length++);
            }
        }, {
            key: "remove",
            value: function remove(e) {
                var t = e._getIndexInMotionList();
                if (this.length--, t !== this.length) {
                    var r = this.elements[this.length];
                    this.elements[t] = r, r._setIndexInMotionList(t);
                }
                e._setIndexInMotionList(-1);
            }
        }]);
        return wr;
    }(_t);
    var Fr = /* */ function() {
        function Fr(e, t, r, i) {
            _classCallCheck(this, Fr);
            this._motionObjects = new wr(), this.count = 0, r > e && (console.warn("Minimum node size must be at least as big as the initial world size. Was: " + r + " Adjusted to: " + e),
                    r = e), this._initialSize = e, this._minSize = r, this._looseness = Math.min(Math.max(i, 1), 2),
                this._rootNode = new Vr(this, null, e, t);
        }
        _createClass(Fr, [{
            key: "_getMaxDepth",
            value: function _getMaxDepth(e, t) {
                t++;
                var r = e._children;
                if (null != r)
                    for (var i = t, a = 0, n = r.length; a < n; a++) {
                        var s = r[a];
                        s && (t = Math.max(this._getMaxDepth(s, i), t));
                    }
                return t;
            }
        }, {
            key: "_grow",
            value: function _grow(e) {
                var t = e.x >= 0 ? 1 : -1,
                    r = e.y >= 0 ? 1 : -1,
                    i = e.z >= 0 ? 1 : -1,
                    a = this._rootNode,
                    s = this._rootNode.baseLength / 2,
                    o = 2 * this._rootNode.baseLength,
                    l = this._rootNode.center,
                    _ = new n(l.x + t * s, l.y + r * s, l.z + i * s);
                if (this._rootNode = new Vr(this, null, o, _), a.hasAnyObjects()) {
                    for (var h = this._rootNode._bestFitChild(a.center), c = [], d = 0; d < 8; d++) {
                        d == h && (a._parent = this._rootNode, c[d] = a);
                    }
                    this._rootNode._children = c;
                }
            }
        }, {
            key: "add",
            value: function add(e) {
                for (var t = 0; !this._rootNode.add(e);) {
                    var r = Fr._tempVector30;
                    if (n.subtract(e.bounds.getCenter(), this._rootNode.center, r), this._grow(r), ++t > 20) throw "Aborted Add operation as it seemed to be going on forever (" + (t - 1) + ") attempts at growing the octree.";
                }
                this.count++;
            }
        }, {
            key: "remove",
            value: function remove(e) {
                var t = e._getOctreeNode().remove(e);
                return t && this.count--, t;
            }
        }, {
            key: "update",
            value: function update(e) {
                var t = 0,
                    r = e._getOctreeNode();
                if (r) {
                    for (; !r._update(e);) {
                        var i = Fr._tempVector30;
                        if (n.subtract(e.bounds.getCenter(), this._rootNode.center, i), this._grow(i), ++t > 20) throw "Aborted Add operation as it seemed to be going on forever (" + (t - 1) + ") attempts at growing the octree.";
                    }
                    return !0;
                }
                return !1;
            }
        }, {
            key: "shrinkRootIfPossible",
            value: function shrinkRootIfPossible() {
                this._rootNode = this._rootNode.shrinkIfPossible(this._initialSize);
            }
        }, {
            key: "addMotionObject",
            value: function addMotionObject(e) {
                this._motionObjects.add(e);
            }
        }, {
            key: "removeMotionObject",
            value: function removeMotionObject(e) {
                this._motionObjects.remove(e);
            }
        }, {
            key: "updateMotionObjects",
            value: function updateMotionObjects() {
                for (var e = this._motionObjects.elements, t = 0, r = this._motionObjects.length; t < r; t++) {
                    var i = e[t];
                    this.update(i), i._setIndexInMotionList(-1);
                }
                this._motionObjects.length = 0;
            }
        }, {
            key: "isCollidingWithBoundBox",
            value: function isCollidingWithBoundBox(e) {
                return this._rootNode.isCollidingWithBoundBox(e);
            }
        }, {
            key: "isCollidingWithRay",
            value: function isCollidingWithRay(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;
                return this._rootNode.isCollidingWithRay(e, t);
            }
        }, {
            key: "getCollidingWithBoundBox",
            value: function getCollidingWithBoundBox(e, t) {
                this._rootNode.getCollidingWithBoundBox(e, t);
            }
        }, {
            key: "getCollidingWithRay",
            value: function getCollidingWithRay(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.MAX_VALUE;
                this._rootNode.getCollidingWithRay(e, t, r);
            }
        }, {
            key: "getCollidingWithFrustum",
            value: function getCollidingWithFrustum(e, t, r, i) {
                this._rootNode.getCollidingWithFrustum(e, t, r, i);
            }
        }, {
            key: "getMaxBounds",
            value: function getMaxBounds() {
                return this._rootNode.getBound();
            }
        }, {
            key: "drawAllBounds",
            value: function drawAllBounds(e) {
                var t = this._getMaxDepth(this._rootNode, -1);
                this._rootNode.drawAllBounds(e, -1, t);
            }
        }, {
            key: "drawAllObjects",
            value: function drawAllObjects(e) {
                var t = this._getMaxDepth(this._rootNode, -1);
                this._rootNode.drawAllObjects(e, -1, t);
            }
        }]);
        return Fr;
    }();
    Fr._tempVector30 = new n(), (Ee = e.AmbientMode || (e.AmbientMode = {}))[Ee.SolidColor = 0] = "SolidColor",
        Ee[Ee.SphericalHarmonics = 1] = "SphericalHarmonics";
    var Br = /* */ function(_t$Sprite) {
        _inherits(Br, _t$Sprite);

        function Br() {
            var _this68;
            _classCallCheck(this, Br);
            _this68 = _possibleConstructorReturn(this, _getPrototypeOf(Br).call(this)), _this68._lightCount = 0,
                _this68._pointLights = new Lr(), _this68._spotLights = new Lr(), _this68._directionLights = new yr(),
                _this68._alternateLights = new Cr(), _this68._lightmaps = [], _this68._skyRenderer = new qe(),
                _this68._input = new xr(), _this68._timer = t.ILaya.timer, _this68._time = 0, _this68._shCoefficients = new Array(7),
                _this68._ambientMode = e.AmbientMode.SolidColor, _this68._ambientSphericalHarmonics = new nr(),
                _this68._ambientSphericalHarmonicsIntensity = 1, _this68._reflectionDecodeFormat = t.TextureDecodeFormat.Normal,
                _this68._reflectionIntensity = 1, _this68._collsionTestList = [], _this68._renders = new ar(),
                _this68._opaqueQueue = new br(!1), _this68._transparentQueue = new br(!0), _this68._cameraPool = [],
                _this68._animatorPool = new ar(), _this68._scriptPool = new Array(), _this68._tempScriptPool = new Array(),
                _this68._needClearScriptPool = !1, _this68._reflectionCubeHDRParams = new a(), _this68.currentCreationLayer = Math.pow(2, 0),
                _this68.enableLight = !0, _this68._key = new t.SubmitKey(), _this68._pickIdToSprite = new Object(),
                _this68._reflectionMode = 0, x._enablePhysics && (_this68._physicsSimulation = new vr(Br.physicsSettings)),
                _this68._shaderValues = new k(null), _this68.parallelSplitShadowMaps = [], _this68.enableFog = !1,
                _this68.fogStart = 300, _this68.fogRange = 1e3, _this68.fogColor = new n(.7, .7, .7),
                _this68.ambientColor = new n(.212, .227, .259), _this68.reflectionIntensity = 1,
                _this68.reflection = Dr.blackTexture;
            for (var r = 0; r < 7; r++) {
                _this68._shCoefficients[r] = new a();
            }
            var i = l._config;
            switch (i._multiLighting || _this68._shaderValues.addDefine(H.SHADERDEFINE_LEGACYSINGALLIGHTING),
                i.pbrRenderQuality) {
                case e.PBRRenderQuality.High:
                    _this68._shaderValues.addDefine(ee.SHADERDEFINE_LAYA_PBR_BRDF_HIGH);
                    break;

                case e.PBRRenderQuality.Low:
                    _this68._shaderValues.addDefine(ee.SHADERDEFINE_LAYA_PBR_BRDF_LOW);
                    break;

                default:
                    throw "Scene3D:unknown shader quality.";
            }
            if (_this68._shaderValues.setVector(Br.REFLECTIONCUBE_HDR_PARAMS, _this68._reflectionCubeHDRParams),
                t.Render.supportWebGLPlusCulling && (_this68._cullingBufferIndices = new Int32Array(1024),
                    _this68._cullingBufferResult = new Int32Array(1024)), _this68._scene = _assertThisInitialized(_this68),
                _this68._input.__init__(t.Render.canvas, _assertThisInitialized(_this68)), Br.octreeCulling && (_this68._octree = new Fr(Br.octreeInitialSize, Br.octreeInitialCenter, Br.octreeMinNodeSize, Br.octreeLooseness)),
                Oe.debugFrustumCulling) {
                _this68._debugTool = new Pr();
                var s = new rr();
                s.renderQueue = j.RENDERQUEUE_TRANSPARENT, s.alphaTest = !1, s.depthWrite = !1,
                    s.cull = Q.CULL_BACK, s.blend = Q.BLEND_ENABLE_ALL, s.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                    s.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA, s.depthTest = Q.DEPTHTEST_LESS, _this68._debugTool.pixelLineRenderer.sharedMaterial = s;
            }
            return _this68;
        }
        _createClass(Br, [{
            key: "_applySHCoefficients",
            value: function _applySHCoefficients(e, t) {
                for (var r = this._shCoefficients, i = 0; i < 3; i++) {
                    var a = r[i],
                        n = r[i + 3];
                    a.setValue(e.getCoefficient(i, 3) * t, e.getCoefficient(i, 1) * t, e.getCoefficient(i, 2) * t, (e.getCoefficient(i, 0) - e.getCoefficient(i, 6)) * t),
                        n.setValue(e.getCoefficient(i, 4) * t, e.getCoefficient(i, 5) * t, 3 * e.getCoefficient(i, 6) * t, e.getCoefficient(i, 7) * t);
                }
                r[6].setValue(e.getCoefficient(0, 8) * t, e.getCoefficient(1, 8) * t, e.getCoefficient(2, 8) * t, 1);
                var s = this._shaderValues;
                s.setVector(Br.AMBIENTSHAR, r[0]), s.setVector(Br.AMBIENTSHAG, r[1]), s.setVector(Br.AMBIENTSHAB, r[2]),
                    s.setVector(Br.AMBIENTSHBR, r[3]), s.setVector(Br.AMBIENTSHBG, r[4]), s.setVector(Br.AMBIENTSHBB, r[5]),
                    s.setVector(Br.AMBIENTSHC, r[6]);
            }
        }, {
            key: "_setLightmapToChildNode",
            value: function _setLightmapToChildNode(e) {
                e instanceof ye && e._render._applyLightMapParams();
                for (var t = e._children, r = 0, i = t.length; r < i; r++) {
                    this._setLightmapToChildNode(t[r]);
                }
            }
        }, {
            key: "_update",
            value: function _update() {
                var e = this.timer._delta / 1e3;
                this._time += e, this._shaderValues.setNumber(Br.TIME, this._time);
                var t = this._physicsSimulation;
                x._enablePhysics && !vr.disableSimulation && (t._updatePhysicsTransformFromRender(),
                        Rr._addUpdateList = !1, t._simulate(e), t._updateCharacters(), Rr._addUpdateList = !0,
                        t._updateCollisions(), t._eventScripts()), this._input._update(), this._clearScript(),
                    this._updateScript(), b._update(this), this._lateUpdateScript();
            }
        }, {
            key: "_binarySearchIndexInCameraPool",
            value: function _binarySearchIndexInCameraPool(e) {
                for (var t, r = 0, i = this._cameraPool.length - 1; r <= i;) {
                    t = Math.floor((r + i) / 2);
                    var a = this._cameraPool[t]._renderingOrder;
                    if (a == e._renderingOrder) return t;
                    a > e._renderingOrder ? i = t - 1 : r = t + 1;
                }
                return r;
            }
        }, {
            key: "_allotPickColorByID",
            value: function _allotPickColorByID(e, t) {
                var r = Math.floor(e / 65025);
                e -= 255 * r * 255;
                var i = Math.floor(e / 255),
                    a = e -= 255 * i;
                t.x = r / 255, t.y = i / 255, t.z = a / 255, t.w = 1;
            }
        }, {
            key: "_searchIDByPickColor",
            value: function _searchIDByPickColor(e) {
                return 255 * e.x * 255 + 255 * e.y + e.z;
            }
        }, {
            key: "onEnable",
            value: function onEnable() {
                this._input._onCanvasEvent(t.Render.canvas);
            }
        }, {
            key: "onDisable",
            value: function onDisable() {
                this._input._offCanvasEvent(t.Render.canvas);
            }
        }, {
            key: "_setCreateURL",
            value: function _setCreateURL(e) {
                this._url = t.URL.formatURL(e);
            }
        }, {
            key: "_getGroup",
            value: function _getGroup() {
                return this._group;
            }
        }, {
            key: "_setGroup",
            value: function _setGroup(e) {
                this._group = e;
            }
        }, {
            key: "_clearScript",
            value: function _clearScript() {
                if (this._needClearScriptPool) {
                    for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                        var i = e[t];
                        i && (i._indexInPool = this._tempScriptPool.length, this._tempScriptPool.push(i));
                    }
                    this._scriptPool = this._tempScriptPool, e.length = 0, this._tempScriptPool = e,
                        this._needClearScriptPool = !1;
                }
            }
        }, {
            key: "_updateScript",
            value: function _updateScript() {
                for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                    var i = e[t];
                    i && i.enabled && i.onUpdate();
                }
            }
        }, {
            key: "_lateUpdateScript",
            value: function _lateUpdateScript() {
                for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                    var i = e[t];
                    i && i.enabled && i.onLateUpdate();
                }
            }
        }, {
            key: "_onActive",
            value: function _onActive() {
                _get(_getPrototypeOf(Br.prototype), "_onActive", this).call(this), t.ILaya.stage._scene3Ds.push(this);
            }
        }, {
            key: "_onInActive",
            value: function _onInActive() {
                _get(_getPrototypeOf(Br.prototype), "_onInActive", this).call(this);
                var e = t.ILaya.stage._scene3Ds;
                e.splice(e.indexOf(this), 1);
            }
        }, {
            key: "_prepareSceneToRender",
            value: function _prepareSceneToRender() {
                var e = this._shaderValues;
                if (l._config._multiLighting) {
                    var t = Br._lightTexture,
                        r = Br._lightPixles;
                    var _l = t.width,
                        _R = 4 * _l;
                    var i = 0,
                        a = this._directionLights._length,
                        s = this._directionLights._elements;
                    if (a > 0) {
                        for (var o = this._directionLights.getSunLight(), _ = 0; _ < a; _++, i++) {
                            var h = (g = s[_])._direction,
                                c = g._intensityColor,
                                d = _R * i;
                            n.scale(g.color, g._intensity, c), g.transform.worldMatrix.getForward(h), n.normalize(h, h),
                                r[d] = c.x, r[d + 1] = c.y, r[d + 2] = c.z, r[d + 4] = h.x, r[d + 5] = h.y, r[d + 6] = h.z,
                                _ == o && (e.setVector3(Br.SUNLIGHTDIRCOLOR, c), e.setVector3(Br.SUNLIGHTDIRECTION, h));
                        }
                        e.addDefine(at.SHADERDEFINE_DIRECTIONLIGHT);
                    } else e.removeDefine(at.SHADERDEFINE_DIRECTIONLIGHT);
                    var u = this._pointLights._length;
                    if (u > 0) {
                        var m = this._pointLights._elements;
                        for (_ = 0; _ < u; _++, i++) {
                            var f = (S = m[_]).transform.position;
                            c = S._intensityColor, d = _R * i;
                            n.scale(S.color, S._intensity, c), r[d] = c.x, r[d + 1] = c.y, r[d + 2] = c.z, r[d + 3] = S.range,
                                r[d + 4] = f.x, r[d + 5] = f.y, r[d + 6] = f.z;
                        }
                        e.addDefine(at.SHADERDEFINE_POINTLIGHT);
                    } else e.removeDefine(at.SHADERDEFINE_POINTLIGHT);
                    var E = this._spotLights._length;
                    if (E > 0) {
                        var T = this._spotLights._elements;
                        for (_ = 0; _ < E; _++, i++) {
                            var p = T[_];
                            h = p._direction, f = p.transform.position, c = p._intensityColor, d = _R * i;
                            n.scale(p.color, p._intensity, c), p.transform.worldMatrix.getForward(h), n.normalize(h, h),
                                r[d] = c.x, r[d + 1] = c.y, r[d + 2] = c.z, r[d + 3] = p.range, r[d + 4] = f.x,
                                r[d + 5] = f.y, r[d + 6] = f.z, r[d + 7] = p.spotAngle * Math.PI / 180, r[d + 8] = h.x,
                                r[d + 9] = h.y, r[d + 10] = h.z;
                        }
                        e.addDefine(at.SHADERDEFINE_SPOTLIGHT);
                    } else e.removeDefine(at.SHADERDEFINE_SPOTLIGHT);
                    i > 0 && t.setSubPixels(0, 0, _l, i, r, 0), e.setTexture(Br.LIGHTBUFFER, t), e.setInt(Br.DIRECTIONLIGHTCOUNT, this._directionLights._length),
                        e.setTexture(Br.CLUSTERBUFFER, Fe.instance._clusterTexture);
                } else {
                    if (this._directionLights._length > 0) {
                        var g = this._directionLights._elements[0];
                        n.scale(g.color, g._intensity, g._intensityColor), g.transform.worldMatrix.getForward(g._direction),
                            n.normalize(g._direction, g._direction), e.setVector3(Br.LIGHTDIRCOLOR, g._intensityColor),
                            e.setVector3(Br.LIGHTDIRECTION, g._direction), e.setVector3(Br.SUNLIGHTDIRCOLOR, g._intensityColor),
                            e.setVector3(Br.SUNLIGHTDIRECTION, g._direction), e.addDefine(at.SHADERDEFINE_DIRECTIONLIGHT);
                    } else e.removeDefine(at.SHADERDEFINE_DIRECTIONLIGHT);
                    if (this._pointLights._length > 0) {
                        var S = this._pointLights._elements[0];
                        n.scale(S.color, S._intensity, S._intensityColor), e.setVector3(Br.POINTLIGHTCOLOR, S._intensityColor),
                            e.setVector3(Br.POINTLIGHTPOS, S.transform.position), e.setNumber(Br.POINTLIGHTRANGE, S.range),
                            e.addDefine(at.SHADERDEFINE_POINTLIGHT);
                    } else e.removeDefine(at.SHADERDEFINE_POINTLIGHT);
                    if (this._spotLights._length > 0) {
                        var R = this._spotLights._elements[0];
                        n.scale(R.color, R._intensity, R._intensityColor), e.setVector3(Br.SPOTLIGHTCOLOR, R._intensityColor),
                            e.setVector3(Br.SPOTLIGHTPOS, R.transform.position), R.transform.worldMatrix.getForward(R._direction),
                            n.normalize(R._direction, R._direction), e.setVector3(Br.SPOTLIGHTDIRECTION, R._direction),
                            e.setNumber(Br.SPOTLIGHTRANGE, R.range), e.setNumber(Br.SPOTLIGHTSPOTANGLE, R.spotAngle * Math.PI / 180),
                            e.addDefine(at.SHADERDEFINE_SPOTLIGHT);
                    } else e.removeDefine(at.SHADERDEFINE_SPOTLIGHT);
                }
            }
        }, {
            key: "_addScript",
            value: function _addScript(e) {
                var t = this._scriptPool;
                e._indexInPool = t.length, t.push(e);
            }
        }, {
            key: "_removeScript",
            value: function _removeScript(e) {
                this._scriptPool[e._indexInPool] = null, e._indexInPool = -1, this._needClearScriptPool = !0;
            }
        }, {
            key: "_preRenderScript",
            value: function _preRenderScript() {
                for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                    var i = e[t];
                    i && i.enabled && i.onPreRender();
                }
            }
        }, {
            key: "_postRenderScript",
            value: function _postRenderScript() {
                for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                    var i = e[t];
                    i && i.enabled && i.onPostRender();
                }
            }
        }, {
            key: "_addCamera",
            value: function _addCamera(e) {
                for (var t = this._binarySearchIndexInCameraPool(e), r = e._renderingOrder, i = this._cameraPool.length; t < i && this._cameraPool[t]._renderingOrder <= r;) {
                    t++;
                }
                this._cameraPool.splice(t, 0, e);
            }
        }, {
            key: "_removeCamera",
            value: function _removeCamera(e) {
                this._cameraPool.splice(this._cameraPool.indexOf(e), 1);
            }
        }, {
            key: "_preCulling",
            value: function _preCulling(e, t, r, i) {
                Oe.renderObjectCulling(t, this, e, r, i, !1);
            }
        }, {
            key: "_clear",
            value: function _clear(r, i) {
                var a, n, s, o = i.viewport,
                    l = i.camera,
                    _ = l._getRenderTexture(),
                    h = o.width,
                    c = o.height;
                l._needInternalRenderTexture() ? (a = 0, n = 0) : (a = o.x, n = l._getCanvasHeight() - o.y - c),
                    r.viewport(a, n, h, c);
                var d = l.clearFlag;
                switch (d !== e.CameraClearFlags.Sky || l.skyRenderer._isAvailable() || this._skyRenderer._isAvailable() || (d = e.CameraClearFlags.SolidColor),
                    d) {
                    case e.CameraClearFlags.SolidColor:
                        var u = l.clearColor;
                        if (r.enable(r.SCISSOR_TEST), r.scissor(a, n, h, c), u ? r.clearColor(u.x, u.y, u.z, u.w) : r.clearColor(0, 0, 0, 0),
                            _) switch (s = r.COLOR_BUFFER_BIT, _.depthStencilFormat) {
                            case t.RenderTextureDepthFormat.DEPTH_16:
                                s |= r.DEPTH_BUFFER_BIT;
                                break;

                            case t.RenderTextureDepthFormat.STENCIL_8:
                                s |= r.STENCIL_BUFFER_BIT;
                                break;

                            case t.RenderTextureDepthFormat.DEPTHSTENCIL_16_8:
                                s |= r.DEPTH_BUFFER_BIT, s |= r.STENCIL_BUFFER_BIT;
                        } else s = r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT;
                        t.WebGLContext.setDepthMask(r, !0), r.clear(s), r.disable(r.SCISSOR_TEST);
                        break;

                    case e.CameraClearFlags.Sky:
                    case e.CameraClearFlags.DepthOnly:
                        if (r.enable(r.SCISSOR_TEST), r.scissor(a, n, h, c), _) switch (_.depthStencilFormat) {
                            case t.RenderTextureDepthFormat.DEPTH_16:
                                s = r.DEPTH_BUFFER_BIT;
                                break;

                            case t.RenderTextureDepthFormat.STENCIL_8:
                                s = r.STENCIL_BUFFER_BIT;
                                break;

                            case t.RenderTextureDepthFormat.DEPTHSTENCIL_16_8:
                                s = r.DEPTH_BUFFER_BIT | r.STENCIL_BUFFER_BIT;
                        } else s = r.DEPTH_BUFFER_BIT;
                        t.WebGLContext.setDepthMask(r, !0), r.clear(s), r.disable(r.SCISSOR_TEST);
                        break;

                    case e.CameraClearFlags.Nothing:
                        break;

                    default:
                        throw new Error("Scene3D:camera clearFlag invalid.");
                }
            }
        }, {
            key: "_renderScene",
            value: function _renderScene(t) {
                var r = t.camera;
                if (this._opaqueQueue._render(t), r.clearFlag === e.CameraClearFlags.Sky && (r.skyRenderer._isAvailable() ? r.skyRenderer._render(t) : this._skyRenderer._isAvailable() && this._skyRenderer._render(t)),
                    this._transparentQueue._render(t), Oe.debugFrustumCulling)
                    for (var i = this._debugTool._render._renderElements, a = 0, n = i.length; a < n; a++) {
                        i[a]._update(this, t, null, null), i[a]._render(t);
                    }
            }
        }, {
            key: "_parse",
            value: function _parse(e, r) {
                var i = e.lightmaps;
                if (i) {
                    for (var a = i.length, n = [], s = 0; s < a; s++) {
                        n[s] = t.Loader.getRes(i[s].path);
                    }
                    this.setlightmaps(n);
                }
                var o = e.ambientColor;
                if (o) {
                    var l = this.ambientColor;
                    l.fromArray(o), this.ambientColor = l;
                }
                var _ = e.sky;
                if (_) switch (this._skyRenderer.material = t.Loader.getRes(_.material.path), _.mesh) {
                    case "SkyBox":
                        this._skyRenderer.mesh = je.instance;
                        break;

                    case "SkyDome":
                        this._skyRenderer.mesh = Mr.instance;
                        break;

                    default:
                        this.skyRenderer.mesh = je.instance;
                }
                this.enableFog = e.enableFog, this.fogStart = e.fogStart, this.fogRange = e.fogRange;
                var h = e.fogColor;
                if (h) {
                    var c = this.fogColor;
                    c.fromArray(h), this.fogColor = c;
                }
                var d = e.ambientSphericalHarmonics;
                if (d) {
                    var u = this.ambientSphericalHarmonics;
                    for (s = 0; s < 3; s++) {
                        var m = 9 * s;
                        u.setCoefficients(s, d[m], d[m + 1], d[m + 2], d[m + 3], d[m + 4], d[m + 5], d[m + 6], d[m + 7], d[m + 8]);
                    }
                    this.ambientSphericalHarmonics = u;
                }
                var f = e.reflection;
                null != f && (this.reflection = t.Loader.getRes(f));
                var E = e.reflectionDecodingFormat;
                null != E && (this.reflectionDecodingFormat = E);
                var T = e.ambientMode;
                null != T && (this.ambientMode = T);
                var p = e.ambientSphericalHarmonicsIntensity;
                null != p && (this.ambientSphericalHarmonicsIntensity = p);
                var g = e.reflectionIntensity;
                null != g && (this.reflectionIntensity = g);
            }
        }, {
            key: "_addRenderObject",
            value: function _addRenderObject(e) {
                if (this._octree && e._supportOctree) this._octree.add(e);
                else if (this._renders.add(e),
                    t.Render.supportWebGLPlusCulling) {
                    var r = e._getIndexInList(),
                        i = this._cullingBufferIndices.length;
                    if (r >= i) {
                        var a = this._cullingBufferIndices,
                            n = this._cullingBufferResult;
                        this._cullingBufferIndices = new Int32Array(i + 1024), this._cullingBufferResult = new Int32Array(i + 1024),
                            this._cullingBufferIndices.set(a, 0), this._cullingBufferResult.set(n, 0);
                    }
                    this._cullingBufferIndices[r] = e._cullingBufferIndex;
                }
            }
        }, {
            key: "_removeRenderObject",
            value: function _removeRenderObject(e) {
                var r;
                this._octree && e._supportOctree ? this._octree.remove(e) : (t.Render.supportWebGLPlusCulling && (r = this._renders.elements[this._renders.length - 1]),
                    this._renders.remove(e), t.Render.supportWebGLPlusCulling && (this._cullingBufferIndices[r._getIndexInList()] = r._cullingBufferIndex));
            }
        }, {
            key: "_getRenderQueue",
            value: function _getRenderQueue(e) {
                return e <= 2500 ? this._opaqueQueue : this._transparentQueue;
            }
        }, {
            key: "setlightmaps",
            value: function setlightmaps(e) {
                for (var t = this._lightmaps, r = 0, i = t.length; r < i; r++) {
                    t[r]._removeReference();
                }
                if (!e) throw new Error("Scene3D: value value can't be null.");
                var a = e.length;
                for (t.length = a, r = 0; r < a; r++) {
                    var n = e[r];
                    n._addReference(), t[r] = n;
                }
                for (r = 0, i = this._children.length; r < i; r++) {
                    this._setLightmapToChildNode(this._children[r]);
                }
            }
        }, {
            key: "getlightmaps",
            value: function getlightmaps() {
                return this._lightmaps.slice();
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
                this.destroyed || (_get(_getPrototypeOf(Br.prototype), "destroy", this).call(this, e),
                    this._skyRenderer.destroy(), this._skyRenderer = null, this._directionLights = null,
                    this._pointLights = null, this._spotLights = null, this._alternateLights = null,
                    this._lightmaps = null, this._shaderValues = null, this._renders = null, this._cameraPool = null,
                    this._octree = null, this.parallelSplitShadowMaps = null, this._physicsSimulation && this._physicsSimulation._destroy(),
                    t.Loader.clearRes(this.url));
            }
        }, {
            key: "render",
            value: function render(e, r, i) {
                e._curSubmit = t.SubmitBase.RENDERBASE, this._children.length > 0 && e.addRenderObject(this);
            }
        }, {
            key: "renderSubmit",
            value: function renderSubmit() {
                var e, r, i;
                t.LayaGL.instance;
                for (this._prepareSceneToRender(), e = 0, i = (r = this._cameraPool.length) - 1; e < r; e++) {
                    t.Render.supportWebGLPlusRendering && k.setRuntimeValueMode(e == i);
                    var a = this._cameraPool[e];
                    a.enableRender && a.render();
                }
                return t.Context.set2DRenderConfig(), 1;
            }
        }, {
            key: "getRenderType",
            value: function getRenderType() {
                return 0;
            }
        }, {
            key: "releaseRender",
            value: function releaseRender() {}
        }, {
            key: "reUse",
            value: function reUse(e, t) {
                return 0;
            }
        }, {
            key: "url",
            get: function get() {
                return this._url;
            }
        }, {
            key: "enableFog",
            get: function get() {
                return this._enableFog;
            },
            set: function set(e) {
                this._enableFog !== e && (this._enableFog = e, e ? this._shaderValues.addDefine(at.SHADERDEFINE_FOG) : this._shaderValues.removeDefine(at.SHADERDEFINE_FOG));
            }
        }, {
            key: "fogColor",
            get: function get() {
                return this._shaderValues.getVector3(Br.FOGCOLOR);
            },
            set: function set(e) {
                this._shaderValues.setVector3(Br.FOGCOLOR, e);
            }
        }, {
            key: "fogStart",
            get: function get() {
                return this._shaderValues.getNumber(Br.FOGSTART);
            },
            set: function set(e) {
                this._shaderValues.setNumber(Br.FOGSTART, e);
            }
        }, {
            key: "fogRange",
            get: function get() {
                return this._shaderValues.getNumber(Br.FOGRANGE);
            },
            set: function set(e) {
                this._shaderValues.setNumber(Br.FOGRANGE, e);
            }
        }, {
            key: "ambientMode",
            get: function get() {
                return this._ambientMode;
            },
            set: function set(t) {
                if (this._ambientMode !== t) {
                    switch (t) {
                        case e.AmbientMode.SolidColor:
                            this._shaderValues.removeDefine(at.SHADERDEFINE_GI_AMBIENT_SH);
                            break;

                        case e.AmbientMode.SphericalHarmonics:
                            this._shaderValues.addDefine(at.SHADERDEFINE_GI_AMBIENT_SH);
                            break;

                        default:
                            throw "Scene3D: unknown ambientMode.";
                    }
                    this._ambientMode = t;
                }
            }
        }, {
            key: "ambientColor",
            get: function get() {
                return this._shaderValues.getVector3(Br.AMBIENTCOLOR);
            },
            set: function set(e) {
                this._shaderValues.setVector3(Br.AMBIENTCOLOR, e);
            }
        }, {
            key: "ambientSphericalHarmonics",
            get: function get() {
                return this._ambientSphericalHarmonics;
            },
            set: function set(e) {
                var t = e || nr._default;
                this._applySHCoefficients(t, Math.pow(this._ambientSphericalHarmonicsIntensity, 2.2)),
                    this._ambientSphericalHarmonics != e && e.cloneTo(this._ambientSphericalHarmonics);
            }
        }, {
            key: "ambientSphericalHarmonicsIntensity",
            get: function get() {
                return this._ambientSphericalHarmonicsIntensity;
            },
            set: function set(e) {
                if (e = Math.max(Math.min(e, 8), 0), this._ambientSphericalHarmonicsIntensity !== e) {
                    var t = this._ambientSphericalHarmonics || nr._default;
                    this._applySHCoefficients(t, Math.pow(e, 2.2)), this._ambientSphericalHarmonicsIntensity = e;
                }
            }
        }, {
            key: "reflection",
            get: function get() {
                return this._reflection;
            },
            set: function set(e) {
                this._reflection != e && (this._shaderValues.setTexture(Br.REFLECTIONTEXTURE, e || Dr.blackTexture),
                    this._reflection = e);
            }
        }, {
            key: "reflectionDecodingFormat",
            get: function get() {
                return this._reflectionDecodeFormat;
            },
            set: function set(e) {
                this._reflectionDecodeFormat != e && (this._reflectionCubeHDRParams.x = this._reflectionIntensity,
                    this._reflectionDecodeFormat == t.TextureDecodeFormat.RGBM && (this._reflectionCubeHDRParams.x *= 5),
                    this._reflectionDecodeFormat = e);
            }
        }, {
            key: "reflectionIntensity",
            get: function get() {
                return this._reflectionIntensity;
            },
            set: function set(e) {
                e = Math.max(Math.min(e, 1), 0), this._reflectionCubeHDRParams.x = e, this._reflectionDecodeFormat == t.TextureDecodeFormat.RGBM && (this._reflectionCubeHDRParams.x *= 5),
                    this._reflectionIntensity = e;
            }
        }, {
            key: "skyRenderer",
            get: function get() {
                return this._skyRenderer;
            }
        }, {
            key: "physicsSimulation",
            get: function get() {
                return this._physicsSimulation;
            }
        }, {
            key: "timer",
            get: function get() {
                return this._timer;
            },
            set: function set(e) {
                this._timer = e;
            }
        }, {
            key: "input",
            get: function get() {
                return this._input;
            }
        }, {
            key: "customReflection",
            get: function get() {
                return this._reflection;
            },
            set: function set(e) {
                this._reflection != e && (this._shaderValues.setTexture(Br.REFLECTIONTEXTURE, e || Dr.blackTexture),
                    this._reflection = e);
            }
        }, {
            key: "reflectionMode",
            get: function get() {
                return this._reflectionMode;
            },
            set: function set(e) {
                this._reflectionMode = e;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                var e = l._config;
                if (e._multiLighting) {
                    var _i2 = 4;
                    var t = e.maxLightCount,
                        r = e.lightClusterCount;
                    Fe.instance = new Fe(r.x, r.y, r.z, Math.min(e.maxLightCount, e._maxAreaLightCountPerClusterAverage)),
                        Br._lightTexture = I._createFloatTextureBuffer(_i2, t), Br._lightTexture.lock = !0,
                        Br._lightPixles = new Float32Array(t * _i2 * 4);
                }
                at.SHADERDEFINE_FOG = H.getDefineByName("FOG"), at.SHADERDEFINE_DIRECTIONLIGHT = H.getDefineByName("DIRECTIONLIGHT"),
                    at.SHADERDEFINE_POINTLIGHT = H.getDefineByName("POINTLIGHT"), at.SHADERDEFINE_SPOTLIGHT = H.getDefineByName("SPOTLIGHT"),
                    at.SHADERDEFINE_CAST_SHADOW = H.getDefineByName("CASTSHADOW"), at.SHADERDEFINE_SHADOW_PSSM1 = H.getDefineByName("SHADOWMAP_PSSM1"),
                    at.SHADERDEFINE_SHADOW_PSSM2 = H.getDefineByName("SHADOWMAP_PSSM2"), at.SHADERDEFINE_SHADOW_PSSM3 = H.getDefineByName("SHADOWMAP_PSSM3"),
                    at.SHADERDEFINE_SHADOW_PCF_NO = H.getDefineByName("SHADOWMAP_PCF_NO"), at.SHADERDEFINE_SHADOW_PCF1 = H.getDefineByName("SHADOWMAP_PCF1"),
                    at.SHADERDEFINE_SHADOW_PCF2 = H.getDefineByName("SHADOWMAP_PCF2"), at.SHADERDEFINE_SHADOW_PCF3 = H.getDefineByName("SHADOWMAP_PCF3"),
                    at.SHADERDEFINE_GI_AMBIENT_SH = H.getDefineByName("GI_AMBIENT_SH");
            }
        }, {
            key: "load",
            value: function load(e, r) {
                t.ILaya.loader.create(e, r, null, Br.HIERARCHY);
            }
        }]);
        return Br;
    }(t.Sprite);
    Br.HIERARCHY = "HIERARCHY", Br.physicsSettings = new Ir(), Br.octreeCulling = !1,
        Br.octreeInitialSize = 64, Br.octreeInitialCenter = new n(0, 0, 0), Br.octreeMinNodeSize = 2,
        Br.octreeLooseness = 1.25, Br.REFLECTIONMODE_SKYBOX = 0, Br.REFLECTIONMODE_CUSTOM = 1,
        Br.FOGCOLOR = H.propertyNameToID("u_FogColor"), Br.FOGSTART = H.propertyNameToID("u_FogStart"),
        Br.FOGRANGE = H.propertyNameToID("u_FogRange"), Br.DIRECTIONLIGHTCOUNT = H.propertyNameToID("u_DirationLightCount"),
        Br.LIGHTBUFFER = H.propertyNameToID("u_LightBuffer"), Br.CLUSTERBUFFER = H.propertyNameToID("u_LightClusterBuffer"),
        Br.SUNLIGHTDIRECTION = H.propertyNameToID("u_SunLight.direction"), Br.SUNLIGHTDIRCOLOR = H.propertyNameToID("u_SunLight.color"),
        Br.AMBIENTSHAR = H.propertyNameToID("u_AmbientSHAr"), Br.AMBIENTSHAG = H.propertyNameToID("u_AmbientSHAg"),
        Br.AMBIENTSHAB = H.propertyNameToID("u_AmbientSHAb"), Br.AMBIENTSHBR = H.propertyNameToID("u_AmbientSHBr"),
        Br.AMBIENTSHBG = H.propertyNameToID("u_AmbientSHBg"), Br.AMBIENTSHBB = H.propertyNameToID("u_AmbientSHBb"),
        Br.AMBIENTSHC = H.propertyNameToID("u_AmbientSHC"), Br.REFLECTIONPROBE = H.propertyNameToID("u_ReflectionProbe"),
        Br.REFLECTIONCUBE_HDR_PARAMS = H.propertyNameToID("u_ReflectCubeHDRParams"), Br.LIGHTDIRECTION = H.propertyNameToID("u_DirectionLight.direction"),
        Br.LIGHTDIRCOLOR = H.propertyNameToID("u_DirectionLight.color"), Br.POINTLIGHTPOS = H.propertyNameToID("u_PointLight.position"),
        Br.POINTLIGHTRANGE = H.propertyNameToID("u_PointLight.range"), Br.POINTLIGHTATTENUATION = H.propertyNameToID("u_PointLight.attenuation"),
        Br.POINTLIGHTCOLOR = H.propertyNameToID("u_PointLight.color"), Br.SPOTLIGHTPOS = H.propertyNameToID("u_SpotLight.position"),
        Br.SPOTLIGHTDIRECTION = H.propertyNameToID("u_SpotLight.direction"), Br.SPOTLIGHTSPOTANGLE = H.propertyNameToID("u_SpotLight.spot"),
        Br.SPOTLIGHTRANGE = H.propertyNameToID("u_SpotLight.range"), Br.SPOTLIGHTCOLOR = H.propertyNameToID("u_SpotLight.color"),
        Br.SHADOWDISTANCE = H.propertyNameToID("u_shadowPSSMDistance"), Br.SHADOWLIGHTVIEWPROJECT = H.propertyNameToID("u_lightShadowVP"),
        Br.SHADOWMAPPCFOFFSET = H.propertyNameToID("u_shadowPCFoffset"), Br.SHADOWMAPTEXTURE1 = H.propertyNameToID("u_shadowMap1"),
        Br.SHADOWMAPTEXTURE2 = H.propertyNameToID("u_shadowMap2"), Br.SHADOWMAPTEXTURE3 = H.propertyNameToID("u_shadowMap3"),
        Br.AMBIENTCOLOR = H.propertyNameToID("u_AmbientColor"), Br.REFLECTIONTEXTURE = H.propertyNameToID("u_ReflectTexture"),
        Br.TIME = H.propertyNameToID("u_Time");
    var Ur = function Ur() {
        _classCallCheck(this, Ur);
    };
    var Gr = /* */ function(_ft) {
        _inherits(Gr, _ft);

        function Gr(e) {
            var _this69;
            _classCallCheck(this, Gr);
            _this69 = _possibleConstructorReturn(this, _getPrototypeOf(Gr).call(this, e)), _this69._bones = [],
                _this69._skinnedDataLoopMarks = [], _this69._localBounds = new ut(n._ZERO, n._ZERO),
                _this69._cacheAnimationNode = [];
            return _this69;
        }
        _createClass(Gr, [{
            key: "_computeSkinnedData",
            value: function _computeSkinnedData() {
                if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && !this._cacheAvatar)
                    for (var e = this._cacheMesh._inverseBindPoses, t = this._cacheMesh._skinnedMatrixCaches, r = 0, i = this._cacheMesh.subMeshCount; r < i; r++) {
                        for (var a = this._cacheMesh.getSubMesh(r)._boneIndicesList, n = this._skinnedData[r], s = 0, o = a.length; s < o; s++) {
                            var l = a[s];
                            this._computeSubSkinnedData(e, l, n[s], t);
                        }
                    }
            }
        }, {
            key: "_computeSubSkinnedData",
            value: function _computeSubSkinnedData(e, r, i, a) {
                for (var n = 0, s = r.length; n < s; n++) {
                    var o = r[n];
                    if (this._skinnedDataLoopMarks[o] === t.Stat.loopCount)
                        for (var l = a[o], _ = this._skinnedData[l.subMeshIndex][l.batchIndex], h = 16 * l.batchBoneIndex, c = 16 * n, d = 0; d < 16; d++) {
                            i[c + d] = _[h + d];
                        } else this._cacheAvatar ? I._mulMatrixArray(this._cacheAnimationNode[o].transform.getWorldMatrix(), e[o], i, 16 * n) : I._mulMatrixArray(this._bones[o].transform.worldMatrix.elements, e[o], i, 16 * n),
                            this._skinnedDataLoopMarks[o] = t.Stat.loopCount;
                }
            }
        }, {
            key: "_onWorldMatNeedChange",
            value: function _onWorldMatNeedChange(e) {
                this._boundsChange = !0, this._octreeNode && (this._cacheAvatar ? -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this) : (e &= De.TRANSFORM_WORLDPOSITION | De.TRANSFORM_WORLDQUATERNION | De.TRANSFORM_WORLDSCALE) && -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this));
            }
        }, {
            key: "_createRenderElement",
            value: function _createRenderElement() {
                return new st();
            }
        }, {
            key: "_onMeshChange",
            value: function _onMeshChange(e) {
                _get(_getPrototypeOf(Gr.prototype), "_onMeshChange", this).call(this, e), this._cacheMesh = e;
                var t = e.subMeshCount;
                this._skinnedData = [], this._skinnedDataLoopMarks.length = e._inverseBindPoses.length;
                for (var r = 0; r < t; r++) {
                    for (var i = e.getSubMesh(r)._boneIndicesList, a = i.length, n = this._skinnedData[r] = [], s = 0; s < a; s++) {
                        n[s] = new Float32Array(16 * i[s].length);
                    }
                }
                this._cacheAvatar && e && this._getCacheAnimationNodes();
            }
        }, {
            key: "_setCacheAnimator",
            value: function _setCacheAnimator(e) {
                this._cacheAnimator = e, this._shaderValues.addDefine(Ur.SHADERDEFINE_BONE), this._setRootNode();
            }
        }, {
            key: "_calculateBoundingBox",
            value: function _calculateBoundingBox() {
                if (this._cacheAvatar) {
                    if (this._cacheAnimator && this._rootBone) {
                        var e = Gr._tempMatrix4x4;
                        I.matrix4x4MultiplyMFM(this._cacheAnimator.owner.transform.worldMatrix, this._cacheRootAnimationNode.transform.getWorldMatrix(), e),
                            this._localBounds._tranform(e, this._bounds);
                    } else _get(_getPrototypeOf(Gr.prototype), "_calculateBoundingBox", this).call(this);
                } else this._cacheRootBone ? this._localBounds._tranform(this._cacheRootBone.transform.worldMatrix, this._bounds) : this._localBounds._tranform(this._owner.transform.worldMatrix, this._bounds);
                if (t.Render.supportWebGLPlusCulling) {
                    var r = this._bounds.getMin(),
                        i = this._bounds.getMax(),
                        a = Oe._cullingBuffer;
                    a[this._cullingBufferIndex + 1] = r.x, a[this._cullingBufferIndex + 2] = r.y, a[this._cullingBufferIndex + 3] = r.z,
                        a[this._cullingBufferIndex + 4] = i.x, a[this._cullingBufferIndex + 5] = i.y, a[this._cullingBufferIndex + 6] = i.z;
                }
            }
        }, {
            key: "_renderUpdate",
            value: function _renderUpdate(e, t) {
                if (this._cacheAnimator) {
                    if (this._computeSkinnedData(), this._cacheAvatar) {
                        var r = this._cacheAnimator.owner._transform;
                        this._shaderValues.setMatrix4x4(Le.WORLDMATRIX, r.worldMatrix);
                    } else this._shaderValues.setMatrix4x4(Le.WORLDMATRIX, C.DEFAULT);
                } else this._shaderValues.setMatrix4x4(Le.WORLDMATRIX, t.worldMatrix);
            }
        }, {
            key: "_renderUpdateWithCamera",
            value: function _renderUpdateWithCamera(e, t) {
                var r = e.projectionViewMatrix;
                if (this._cacheAnimator) {
                    if (this._cacheAvatar) {
                        var i = this._cacheAnimator.owner._transform;
                        C.multiply(r, i.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(Le.MVPMATRIX, this._projectionViewWorldMatrix);
                    } else this._shaderValues.setMatrix4x4(Le.MVPMATRIX, r);
                } else C.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(Le.MVPMATRIX, this._projectionViewWorldMatrix);
            }
        }, {
            key: "_destroy",
            value: function _destroy() {
                _get(_getPrototypeOf(Gr.prototype), "_destroy", this).call(this), this._cacheAvatar ? this._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._cacheRootBone ? !this._cacheRootBone.destroyed && this._cacheRootBone.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner && !this._owner.destroyed && this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
            }
        }, {
            key: "_setRootBone",
            value: function _setRootBone(e) {
                this._rootBone = e, this._setRootNode();
            }
        }, {
            key: "_setRootNode",
            value: function _setRootNode() {
                var e;
                e = this._cacheAnimator && this._rootBone && this._cacheAvatar ? this._cacheAnimator._avatarNodeMap[this._rootBone] : null,
                    this._cacheRootAnimationNode != e && (this._onWorldMatNeedChange(De.TRANSFORM_WORLDPOSITION | De.TRANSFORM_WORLDQUATERNION | De.TRANSFORM_WORLDSCALE),
                        this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                        this._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                        e && e.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                        this._cacheRootAnimationNode = e);
            }
        }, {
            key: "_getCacheAnimationNodes",
            value: function _getCacheAnimationNodes() {
                var e = this._cacheMesh._boneNames,
                    r = this._cacheMesh._inverseBindPoses.length;
                if (t.Render.supportWebGLPlusAnimation) {
                    this._cacheAnimationNodeIndices = new Uint16Array(r);
                    var i = this._cacheAnimator._avatarNodeMap;
                    for (s = 0; s < r; s++) {
                        var a = i[e[s]];
                        this._cacheAnimationNodeIndices[s] = a ? a._worldMatrixIndex : 0;
                    }
                } else {
                    this._cacheAnimationNode.length = r;
                    for (var n = this._cacheAnimator._avatarNodeMap, s = 0; s < r; s++) {
                        var o = n[e[s]];
                        this._cacheAnimationNode[s] = o;
                    }
                }
            }
        }, {
            key: "_setCacheAvatar",
            value: function _setCacheAvatar(e) {
                this._cacheAvatar !== e && (this._cacheMesh ? (this._cacheAvatar = e, e && (this._shaderValues.addDefine(Ur.SHADERDEFINE_BONE),
                    this._getCacheAnimationNodes())) : this._cacheAvatar = e, this._setRootNode());
            }
        }, {
            key: "_computeSubSkinnedDataNative",
            value: function _computeSubSkinnedDataNative(e, r, i, a, n) {
                t.LayaGL.instance.computeSubSkinnedData(e, r, i, a, n);
            }
        }, {
            key: "_computeSkinnedDataForNative",
            value: function _computeSkinnedDataForNative() {
                if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && !this._cacheAvatar)
                    for (var e = this._cacheMesh._inverseBindPoses, r = this._cacheMesh._skinnedMatrixCaches, i = 0, a = this._cacheMesh.subMeshCount; i < a; i++) {
                        for (var n = this._cacheMesh.getSubMesh(i)._boneIndicesList, s = this._skinnedData[i], o = 0, l = n.length; o < l; o++) {
                            var _ = n[o];
                            this._cacheAvatar && t.Render.supportWebGLPlusAnimation ? this._computeSubSkinnedDataNative(this._cacheAnimator._animationNodeWorldMatrixs, this._cacheAnimationNodeIndices, this._cacheMesh._inverseBindPosesBuffer, _, s[o]) : this._computeSubSkinnedData(e, _, s[o], r);
                        }
                    }
            }
        }, {
            key: "localBounds",
            get: function get() {
                return this._localBounds;
            },
            set: function set(e) {
                this._localBounds = e;
            }
        }, {
            key: "rootBone",
            get: function get() {
                return this._cacheRootBone;
            },
            set: function set(e) {
                this._cacheRootBone != e && (this._cacheRootBone ? this._cacheRootBone.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                    e ? e.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                    this._cacheRootBone = e, this._onWorldMatNeedChange(De.TRANSFORM_WORLDPOSITION | De.TRANSFORM_WORLDQUATERNION | De.TRANSFORM_WORLDSCALE));
            }
        }, {
            key: "bones",
            get: function get() {
                return this._bones;
            }
        }, {
            key: "bounds",
            get: function get() {
                return (this._boundsChange || this._cacheAvatar) && (this._calculateBoundingBox(),
                    this._boundsChange = !1), this._bounds;
            }
        }]);
        return Gr;
    }(ft);
    Gr._tempMatrix4x4 = new C();
    var zr = /* */ function(_ye4) {
        _inherits(zr, _ye4);

        function zr() {
            var _this70;
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            _classCallCheck(this, zr);
            _this70 = _possibleConstructorReturn(this, _getPrototypeOf(zr).call(this, t)), _this70._meshFilter = new Et(_assertThisInitialized(_this70)),
                _this70._render = new Gr(_assertThisInitialized(_this70)), e && (_this70._meshFilter.sharedMesh = e);
            return _this70;
        }
        _createClass(zr, [{
            key: "_parse",
            value: function _parse(e, r) {
                _get(_getPrototypeOf(zr.prototype), "_parse", this).call(this, e, r);
                var i = this.skinnedMeshRenderer,
                    s = e.lightmapIndex;
                null != s && (i.lightmapIndex = s);
                var o, l = e.lightmapScaleOffset;
                if (l && (i.lightmapScaleOffset = new a(l[0], l[1], l[2], l[3])), o = e.meshPath) {
                    var _ = t.Loader.getRes(o);
                    _ && (this.meshFilter.sharedMesh = _);
                }
                var h = e.materials;
                if (h) {
                    var c = i.sharedMaterials,
                        d = h.length;
                    c.length = d;
                    for (var u = 0; u < d; u++) {
                        c[u] = t.Loader.getRes(h[u].path);
                    }
                    i.sharedMaterials = c;
                }
                var m = e.boundBox,
                    f = m.min,
                    E = m.max;
                if (i.localBounds.setMin(new n(f[0], f[1], f[2])), i.localBounds.setMax(new n(E[0], E[1], E[2])),
                    r) {
                    var T = e.rootBone;
                    i.rootBone = r[T];
                    var p, g = e.bones;
                    for (u = 0, p = g.length; u < p; u++) {
                        i.bones.push(r[g[u]]);
                    }
                } else e.rootBone && i._setRootBone(e.rootBone);
            }
        }, {
            key: "_changeHierarchyAnimator",
            value: function _changeHierarchyAnimator(e) {
                _get(_getPrototypeOf(zr.prototype), "_changeHierarchyAnimator", this).call(this, e),
                    this.skinnedMeshRenderer._setCacheAnimator(e);
            }
        }, {
            key: "_changeAnimatorAvatar",
            value: function _changeAnimatorAvatar(e) {
                this.skinnedMeshRenderer._setCacheAvatar(e);
            }
        }, {
            key: "_cloneTo",
            value: function _cloneTo(e, t, r) {
                var i = e;
                i.meshFilter.sharedMesh = this.meshFilter.sharedMesh;
                var a = this._render,
                    n = i._render;
                n.enable = a.enable, n.sharedMaterials = a.sharedMaterials, n.castShadow = a.castShadow;
                var s = a.lightmapScaleOffset;
                s && (n.lightmapScaleOffset = s.clone()), n.receiveShadow = a.receiveShadow, n.sortingFudge = a.sortingFudge,
                    n._rootBone = a._rootBone;
                var o = a.bones,
                    l = n.bones,
                    _ = o.length;
                l.length = _;
                var h = a.rootBone;
                if (h) {
                    var c = I._getHierarchyPath(t, h, zr._tempArray0);
                    n.rootBone = c ? I._getNodeByHierarchyPath(r, c) : h;
                }
                for (var d = 0; d < o.length; d++) {
                    c = I._getHierarchyPath(t, o[d], zr._tempArray0), l[d] = c ? I._getNodeByHierarchyPath(r, c) : o[d];
                }
                var u = a.localBounds;
                u && u.cloneTo(n.localBounds), _get(_getPrototypeOf(zr.prototype), "_cloneTo", this).call(this, e, t, r);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
                this.destroyed || (_get(_getPrototypeOf(zr.prototype), "destroy", this).call(this, e),
                    this._meshFilter.destroy());
            }
        }, {
            key: "_create",
            value: function _create() {
                return new zr();
            }
        }, {
            key: "meshFilter",
            get: function get() {
                return this._meshFilter;
            }
        }, {
            key: "skinnedMeshRenderer",
            get: function get() {
                return this._render;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                Ur.SHADERDEFINE_BONE = H.getDefineByName("BONE");
            }
        }]);
        return zr;
    }(ye);
    zr._tempArray0 = [], zr.BONES = H.propertyNameToID("u_Bones");
    var Hr = /* */ function(_j11) {
        _inherits(Hr, _j11);

        function Hr() {
            var _this71;
            _classCallCheck(this, Hr);
            _this71 = _possibleConstructorReturn(this, _getPrototypeOf(Hr).call(this)), _this71.setShaderName("Trail"),
                _this71._color = new a(1, 1, 1, 1), _this71._shaderValues.setVector(Hr.TINTCOLOR, new a(1, 1, 1, 1)),
                _this71.renderMode = Hr.RENDERMODE_ALPHABLENDED;
            return _this71;
        }
        _createClass(Hr, [{
            key: "clone",
            value: function clone() {
                var e = new Hr();
                return this.cloneTo(e), e;
            }
        }, {
            key: "_TintColorR",
            get: function get() {
                return this._color.x;
            },
            set: function set(e) {
                this._color.x = e, this.color = this._color;
            }
        }, {
            key: "_TintColorG",
            get: function get() {
                return this._color.y;
            },
            set: function set(e) {
                this._color.y = e, this.color = this._color;
            }
        }, {
            key: "_TintColorB",
            get: function get() {
                return this._color.z;
            },
            set: function set(e) {
                this._color.z = e, this.color = this._color;
            }
        }, {
            key: "_TintColorA",
            get: function get() {
                return this._color.w;
            },
            set: function set(e) {
                this._color.w = e, this.color = this._color;
            }
        }, {
            key: "_MainTex_STX",
            get: function get() {
                return this._shaderValues.getVector(Hr.TILINGOFFSET).x;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(Hr.TILINGOFFSET);
                t.x = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function get() {
                return this._shaderValues.getVector(Hr.TILINGOFFSET).y;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(Hr.TILINGOFFSET);
                t.y = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function get() {
                return this._shaderValues.getVector(Hr.TILINGOFFSET).z;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(Hr.TILINGOFFSET);
                t.z = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function get() {
                return this._shaderValues.getVector(Hr.TILINGOFFSET).w;
            },
            set: function set(e) {
                var t = this._shaderValues.getVector(Hr.TILINGOFFSET);
                t.w = e, this.tilingOffset = t;
            }
        }, {
            key: "renderMode",
            set: function set(e) {
                switch (e) {
                    case Hr.RENDERMODE_ADDTIVE:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                            this.cull = Q.CULL_NONE, this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                            this.blendDst = Q.BLENDPARAM_ONE, this.depthTest = Q.DEPTHTEST_LESS, this._shaderValues.addDefine(Hr.SHADERDEFINE_ADDTIVEFOG);
                        break;

                    case Hr.RENDERMODE_ALPHABLENDED:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                            this.cull = Q.CULL_NONE, this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA,
                            this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Q.DEPTHTEST_LESS,
                            this._shaderValues.removeDefine(Hr.SHADERDEFINE_ADDTIVEFOG);
                        break;

                    default:
                        throw new Error("TrailMaterial : renderMode value error.");
                }
            }
        }, {
            key: "colorR",
            get: function get() {
                return this._TintColorR;
            },
            set: function set(e) {
                this._TintColorR = e;
            }
        }, {
            key: "colorG",
            get: function get() {
                return this._TintColorG;
            },
            set: function set(e) {
                this._TintColorG = e;
            }
        }, {
            key: "colorB",
            get: function get() {
                return this._TintColorB;
            },
            set: function set(e) {
                this._TintColorB = e;
            }
        }, {
            key: "colorA",
            get: function get() {
                return this._TintColorA;
            },
            set: function set(e) {
                this._TintColorA = e;
            }
        }, {
            key: "color",
            get: function get() {
                return this._shaderValues.getVector(Hr.TINTCOLOR);
            },
            set: function set(e) {
                this._shaderValues.setVector(Hr.TINTCOLOR, e);
            }
        }, {
            key: "texture",
            get: function get() {
                return this._shaderValues.getTexture(Hr.MAINTEXTURE);
            },
            set: function set(e) {
                e ? this._shaderValues.addDefine(Hr.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(Hr.SHADERDEFINE_MAINTEXTURE),
                    this._shaderValues.setTexture(Hr.MAINTEXTURE, e);
            }
        }, {
            key: "tilingOffsetX",
            get: function get() {
                return this._MainTex_STX;
            },
            set: function set(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function get() {
                return this._MainTex_STY;
            },
            set: function set(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function get() {
                return this._MainTex_STZ;
            },
            set: function set(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function get() {
                return this._MainTex_STW;
            },
            set: function set(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function get() {
                return this._shaderValues.getVector(Hr.TILINGOFFSET);
            },
            set: function set(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(Hr.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(Hr.SHADERDEFINE_TILINGOFFSET),
                    this._shaderValues.setVector(Hr.TILINGOFFSET, e);
            }
        }, {
            key: "depthWrite",
            set: function set(e) {
                this._shaderValues.setBool(Hr.DEPTH_WRITE, e);
            },
            get: function get() {
                return this._shaderValues.getBool(Hr.DEPTH_WRITE);
            }
        }, {
            key: "cull",
            set: function set(e) {
                this._shaderValues.setInt(Hr.CULL, e);
            },
            get: function get() {
                return this._shaderValues.getInt(Hr.CULL);
            }
        }, {
            key: "blend",
            set: function set(e) {
                this._shaderValues.setInt(Hr.BLEND, e);
            },
            get: function get() {
                return this._shaderValues.getInt(Hr.BLEND);
            }
        }, {
            key: "blendSrc",
            set: function set(e) {
                this._shaderValues.setInt(Hr.BLEND_SRC, e);
            },
            get: function get() {
                return this._shaderValues.getInt(Hr.BLEND_SRC);
            }
        }, {
            key: "blendDst",
            set: function set(e) {
                this._shaderValues.setInt(Hr.BLEND_DST, e);
            },
            get: function get() {
                return this._shaderValues.getInt(Hr.BLEND_DST);
            }
        }, {
            key: "depthTest",
            set: function set(e) {
                this._shaderValues.setInt(Hr.DEPTH_TEST, e);
            },
            get: function get() {
                return this._shaderValues.getInt(Hr.DEPTH_TEST);
            }
        }], [{
            key: "__initDefine__",
            value: function __initDefine__() {
                Hr.SHADERDEFINE_MAINTEXTURE = H.getDefineByName("MAINTEXTURE"), Hr.SHADERDEFINE_TILINGOFFSET = H.getDefineByName("TILINGOFFSET"),
                    Hr.SHADERDEFINE_ADDTIVEFOG = H.getDefineByName("ADDTIVEFOG");
            }
        }]);
        return Hr;
    }(j);
    Hr.RENDERMODE_ALPHABLENDED = 0, Hr.RENDERMODE_ADDTIVE = 1, Hr.MAINTEXTURE = H.propertyNameToID("u_MainTexture"),
        Hr.TINTCOLOR = H.propertyNameToID("u_MainColor"), Hr.TILINGOFFSET = H.propertyNameToID("u_TilingOffset"),
        Hr.CULL = H.propertyNameToID("s_Cull"), Hr.BLEND = H.propertyNameToID("s_Blend"),
        Hr.BLEND_SRC = H.propertyNameToID("s_BlendSrc"), Hr.BLEND_DST = H.propertyNameToID("s_BlendDst"),
        Hr.DEPTH_TEST = H.propertyNameToID("s_DepthTest"), Hr.DEPTH_WRITE = H.propertyNameToID("s_DepthWrite");
    var kr = function kr() {
        _classCallCheck(this, kr);
    };
    kr.Stretch = 0, kr.Tile = 1, (Te = e.TrailAlignment || (e.TrailAlignment = {}))[Te.View = 0] = "View",
        Te[Te.TransformZ = 1] = "TransformZ";
    var Wr = /* */ function() {
        function Wr() {
            _classCallCheck(this, Wr);
        }
        _createClass(Wr, [{
            key: "vertexDeclaration",
            get: function get() {
                return Wr._vertexDeclaration1;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                Wr._vertexDeclaration1 = new _e(32, [new he(0, le.Vector3, Wr.TRAIL_POSITION0), new he(12, le.Vector3, Wr.TRAIL_OFFSETVECTOR), new he(24, le.Single, Wr.TRAIL_TIME0), new he(28, le.Single, Wr.TRAIL_TEXTURECOORDINATE0Y)]),
                    Wr._vertexDeclaration2 = new _e(20, [new he(0, le.Single, Wr.TRAIL_TEXTURECOORDINATE0X), new he(4, le.Color, Wr.TRAIL_COLOR)]);
            }
        }, {
            key: "vertexDeclaration1",
            get: function get() {
                return Wr._vertexDeclaration1;
            }
        }, {
            key: "vertexDeclaration2",
            get: function get() {
                return Wr._vertexDeclaration2;
            }
        }]);
        return Wr;
    }();
    Wr.TRAIL_POSITION0 = 0, Wr.TRAIL_OFFSETVECTOR = 1, Wr.TRAIL_TIME0 = 2, Wr.TRAIL_TEXTURECOORDINATE0Y = 3,
        Wr.TRAIL_TEXTURECOORDINATE0X = 4, Wr.TRAIL_COLOR = 5;
    var Xr = /* */ function(_Pe6) {
        _inherits(Xr, _Pe6);

        function Xr(e) {
            var _this72;
            _classCallCheck(this, Xr);
            _this72 = _possibleConstructorReturn(this, _getPrototypeOf(Xr).call(this)), _this72._floatCountPerVertices1 = 8,
                _this72._floatCountPerVertices2 = 5, _this72._increaseSegementCount = 16, _this72._activeIndex = 0,
                _this72._endIndex = 0, _this72._needAddFirstVertex = !1, _this72._isTempEndVertex = !1,
                _this72._vertices1 = null, _this72._vertices2 = null, _this72._lastFixedVertexPosition = new n(),
                _this72._bufferState = new Xe(), _this72.tmpColor = new Ae(), _this72._disappearBoundsMode = !1,
                _this72._owner = e, _this72._segementCount = _this72._increaseSegementCount, _this72._resizeData(_this72._segementCount, _this72._bufferState);
            var r = _this72._owner._owner.trailRenderer.bounds,
                i = _this72._owner._owner.transform.position;
            r.setMin(i), r.setMax(i), t.Render.supportWebGLPlusCulling && _this72._calculateBoundingBoxForNative();
            return _this72;
        }
        _createClass(Xr, [{
            key: "_resizeData",
            value: function _resizeData(e, r) {
                this._subBirthTime = new Float32Array(e), this._subDistance = new Float64Array(e);
                var i = t.LayaGL.instance,
                    a = 2 * e,
                    n = Wr.vertexDeclaration1,
                    s = Wr.vertexDeclaration2,
                    o = [],
                    l = a * n.vertexStride,
                    _ = a * s.vertexStride,
                    h = l + _;
                this._vertices1 = new Float32Array(a * this._floatCountPerVertices1), this._vertices2 = new Float32Array(a * this._floatCountPerVertices2),
                    this._vertexBuffer1 = new be(l, i.STATIC_DRAW, !1), this._vertexBuffer1.vertexDeclaration = n,
                    this._vertexBuffer2 = new be(_, i.DYNAMIC_DRAW, !1), this._vertexBuffer2.vertexDeclaration = s,
                    o.push(this._vertexBuffer1), o.push(this._vertexBuffer2), r.bind(), r.applyVertexBuffers(o),
                    r.unBind(), t.Resource._addMemory(h, h);
            }
        }, {
            key: "_resetData",
            value: function _resetData() {
                var e = this._endIndex - this._activeIndex,
                    r = new Float32Array(this._vertices1.buffer, 2 * this._floatCountPerVertices1 * this._activeIndex * 4, 2 * this._floatCountPerVertices1 * e),
                    i = new Float32Array(this._vertices2.buffer, 2 * this._floatCountPerVertices2 * this._activeIndex * 4, 2 * this._floatCountPerVertices2 * e),
                    a = new Float64Array(this._subDistance.buffer, 8 * this._activeIndex, e),
                    n = new Float32Array(this._subBirthTime.buffer, 4 * this._activeIndex, e);
                if (e === this._segementCount) {
                    this._vertexBuffer1.destroy(), this._vertexBuffer2.destroy();
                    var s = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
                    t.Resource._addMemory(-s, -s), this._segementCount += this._increaseSegementCount,
                        this._resizeData(this._segementCount, this._bufferState);
                }
                this._vertices1.set(r, 0), this._vertices2.set(i, 0), this._subDistance.set(a, 0),
                    this._subBirthTime.set(n, 0), this._endIndex = e, this._activeIndex = 0, this._vertexBuffer1.setData(this._vertices1.buffer, 0, 2 * this._floatCountPerVertices1 * this._activeIndex * 4, 2 * this._floatCountPerVertices1 * e * 4),
                    this._vertexBuffer2.setData(this._vertices2.buffer, 0, 2 * this._floatCountPerVertices2 * this._activeIndex * 4, 2 * this._floatCountPerVertices2 * e * 4);
            }
        }, {
            key: "_updateTrail",
            value: function _updateTrail(e, t, r) {
                n.equals(t, r) || (this._endIndex - this._activeIndex == 0 ? this._addTrailByFirstPosition(e, r) : this._addTrailByNextPosition(e, r));
            }
        }, {
            key: "_addTrailByFirstPosition",
            value: function _addTrailByFirstPosition(e, t) {
                this._endIndex === this._segementCount && this._resetData(), this._subDistance[this._endIndex] = 0,
                    this._subBirthTime[this._endIndex] = this._owner._curtime, this._endIndex++, t.cloneTo(this._lastFixedVertexPosition),
                    this._needAddFirstVertex = !0;
            }
        }, {
            key: "_addTrailByNextPosition",
            value: function _addTrailByNextPosition(t, i) {
                var a = Xr._tempVector30,
                    s = Xr._tempVector31;
                switch (this._owner.alignment) {
                    case e.TrailAlignment.View:
                        var o = t.viewMatrix;
                        n.transformCoordinate(i, o, Xr._tempVector33), n.transformCoordinate(this._lastFixedVertexPosition, o, Xr._tempVector34),
                            n.subtract(Xr._tempVector33, Xr._tempVector34, a), n.cross(Xr._tempVector33, a, s);
                        break;

                    case e.TrailAlignment.TransformZ:
                        n.subtract(i, this._lastFixedVertexPosition, a);
                        var l = Xr._tempVector32;
                        this._owner._owner.transform.localMatrix.getForward(l), n.cross(a, l, s);
                }
                n.normalize(s, s), n.scale(s, this._owner.widthMultiplier / 2, s);
                var _, h, c = n.scalarLength(a);
                this._needAddFirstVertex && (this._updateVerticesByPositionData(i, s, this._endIndex - 1),
                    this._needAddFirstVertex = !1), c - this._owner.minVertexDistance >= r.zeroTolerance ? (this._isTempEndVertex ? (_ = this._endIndex - 1,
                    h = c - this._subDistance[_], this._updateVerticesByPosition(i, s, c, _), this._owner._totalLength += h) : (this._endIndex === this._segementCount && this._resetData(),
                    this._updateVerticesByPosition(i, s, c, this._endIndex), this._owner._totalLength += c,
                    this._endIndex++), i.cloneTo(this._lastFixedVertexPosition), this._isTempEndVertex = !1) : (this._isTempEndVertex ? (_ = this._endIndex - 1,
                    h = c - this._subDistance[_], this._updateVerticesByPosition(i, s, c, _), this._owner._totalLength += h) : (this._endIndex === this._segementCount && this._resetData(),
                    this._updateVerticesByPosition(i, s, c, this._endIndex), this._owner._totalLength += c,
                    this._endIndex++), this._isTempEndVertex = !0);
            }
        }, {
            key: "_updateVerticesByPositionData",
            value: function _updateVerticesByPositionData(e, r, i) {
                var a = 2 * this._floatCountPerVertices1 * i,
                    s = this._owner._curtime;
                this._vertices1[a] = e.x, this._vertices1[a + 1] = e.y, this._vertices1[a + 2] = e.z,
                    this._vertices1[a + 3] = -r.x, this._vertices1[a + 4] = -r.y, this._vertices1[a + 5] = -r.z,
                    this._vertices1[a + 6] = s, this._vertices1[a + 7] = 1, this._vertices1[a + 8] = e.x,
                    this._vertices1[a + 9] = e.y, this._vertices1[a + 10] = e.z, this._vertices1[a + 11] = r.x,
                    this._vertices1[a + 12] = r.y, this._vertices1[a + 13] = r.z, this._vertices1[a + 14] = s,
                    this._vertices1[a + 15] = 0;
                var o = this._owner._owner.trailRenderer.bounds,
                    l = o.getMin(),
                    _ = o.getMax(),
                    h = Xr._tempVector35,
                    c = Xr._tempVector36,
                    d = Xr._tempVector32;
                n.add(e, r, h), n.subtract(e, r, c), n.min(c, h, d), n.min(l, d, l), o.setMin(l),
                    n.max(h, c, d), n.max(_, d, _), o.setMax(_), t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative();
                var u = 2 * this._floatCountPerVertices1;
                this._vertexBuffer1.setData(this._vertices1.buffer, 4 * a, 4 * a, 4 * u);
            }
        }, {
            key: "_updateVerticesByPosition",
            value: function _updateVerticesByPosition(e, t, r, i) {
                this._updateVerticesByPositionData(e, t, i), this._subDistance[i] = r, this._subBirthTime[i] = this._owner._curtime;
            }
        }, {
            key: "_updateVertexBufferUV",
            value: function _updateVertexBufferUV() {
                var e, r, i;
                if (this._disappearBoundsMode) {
                    e = this._owner._owner.trailRenderer.bounds;
                    var a = this._owner._owner.transform.position;
                    e.setMin(a), e.setMax(a), r = e.getMin(), i = e.getMax(), t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative();
                }
                for (var s = this._endIndex, o = 0, l = this._owner.colorGradient, _ = l.colorAlphaKeysCount - 1, h = l.colorRGBKeysCount - 1, c = this._owner._totalLength, d = 2 * this._floatCountPerVertices2, u = this._activeIndex; u < s; u++) {
                    var m, f;
                    u !== this._activeIndex && (o += this._subDistance[u]), this._owner.textureMode == kr.Stretch ? f = m = 1 - o / c : (f = 1 - o / c,
                        m = 1 - (c - o)), h = l.evaluateColorRGB(f, this.tmpColor, h, !0), _ = l.evaluateColorAlpha(f, this.tmpColor, _, !0);
                    var E = u * d;
                    if (this._vertices2[E + 0] = m, this._vertices2[E + 1] = this.tmpColor.r, this._vertices2[E + 2] = this.tmpColor.g,
                        this._vertices2[E + 3] = this.tmpColor.b, this._vertices2[E + 4] = this.tmpColor.a,
                        this._vertices2[E + 5] = m, this._vertices2[E + 6] = this.tmpColor.r, this._vertices2[E + 7] = this.tmpColor.g,
                        this._vertices2[E + 8] = this.tmpColor.b, this._vertices2[E + 9] = this.tmpColor.a,
                        this._disappearBoundsMode) {
                        var T = 2 * this._floatCountPerVertices1 * u,
                            p = Xr._tempVector32,
                            g = Xr._tempVector33,
                            S = Xr._tempVector34;
                        p.setValue(this._vertices1[T + 0], this._vertices1[T + 1], this._vertices1[T + 2]),
                            g.setValue(this._vertices1[T + 3], this._vertices1[T + 4], this._vertices1[T + 5]),
                            n.add(p, g, S), n.min(S, r, r), n.max(S, i, i), n.subtract(p, g, S), n.min(S, r, r),
                            n.max(S, i, i);
                    }
                }
                this._disappearBoundsMode && (e.setMin(r), e.setMax(i), this._disappearBoundsMode = !1,
                    t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative());
                var R = this._activeIndex * d;
                this._vertexBuffer2.setData(this._vertices2.buffer, 4 * R, 4 * R, 4 * (s * d - R));
            }
        }, {
            key: "_updateDisappear",
            value: function _updateDisappear() {
                for (var e = this._endIndex, t = this._activeIndex; t < e && this._owner._curtime - this._subBirthTime[t] >= this._owner.time + r.zeroTolerance; t++) {
                    var i = t + 1;
                    if (i !== e && (this._owner._totalLength -= this._subDistance[i]), this._isTempEndVertex && i === e - 1) {
                        this._floatCountPerVertices1;
                        var a = this._lastFixedVertexPosition;
                        a.x = this._vertices1[0], a.y = this._vertices1[1], a.z = this._vertices1[2], this._isTempEndVertex = !1;
                    }
                    this._activeIndex++, this._disappearBoundsMode = !0;
                }
            }
        }, {
            key: "_getType",
            value: function _getType() {
                return Xr._type;
            }
        }, {
            key: "_prepareRender",
            value: function _prepareRender(e) {
                return this._endIndex - this._activeIndex > 1;
            }
        }, {
            key: "_render",
            value: function _render(e) {
                this._bufferState.bind();
                var r = t.LayaGL.instance,
                    i = 2 * this._activeIndex,
                    a = 2 * this._endIndex - i;
                r.drawArrays(r.TRIANGLE_STRIP, i, a), t.Stat.renderBatches++, t.Stat.trianglesFaces += a - 2;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                _get(_getPrototypeOf(Xr.prototype), "destroy", this).call(this);
                var e = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
                t.Resource._addMemory(-e, -e), this._bufferState.destroy(), this._vertexBuffer1.destroy(),
                    this._vertexBuffer2.destroy(), this._bufferState = null, this._vertices1 = null,
                    this._vertexBuffer1 = null, this._vertices2 = null, this._vertexBuffer2 = null,
                    this._subBirthTime = null, this._subDistance = null, this._lastFixedVertexPosition = null,
                    this._disappearBoundsMode = !1;
            }
        }, {
            key: "_calculateBoundingBoxForNative",
            value: function _calculateBoundingBoxForNative() {
                var e = this._owner._owner.trailRenderer,
                    t = e.bounds,
                    r = t.getMin(),
                    i = t.getMax(),
                    a = Oe._cullingBuffer;
                a[e._cullingBufferIndex + 1] = r.x, a[e._cullingBufferIndex + 2] = r.y, a[e._cullingBufferIndex + 3] = r.z,
                    a[e._cullingBufferIndex + 4] = i.x, a[e._cullingBufferIndex + 5] = i.y, a[e._cullingBufferIndex + 6] = i.z;
            }
        }]);
        return Xr;
    }(Pe);
    Xr.ALIGNMENT_VIEW = 0, Xr.ALIGNMENT_TRANSFORM_Z = 1, Xr._tempVector30 = new n(),
        Xr._tempVector31 = new n(), Xr._tempVector32 = new n(), Xr._tempVector33 = new n(),
        Xr._tempVector34 = new n(), Xr._tempVector35 = new n(), Xr._tempVector36 = new n(),
        Xr._type = Pe._typeCounter++;
    var Yr = /* */ function() {
        function Yr(e) {
            _classCallCheck(this, Yr);
            this._totalLength = 0, this._lastPosition = new n(), this._curtime = 0, this.alignment = Yr.ALIGNMENT_VIEW,
                this._owner = e, this._initDefaultData(), this.addRenderElement();
        }
        _createClass(Yr, [{
            key: "addRenderElement",
            value: function addRenderElement() {
                var e = this._owner._render,
                    t = e._renderElements,
                    r = e.sharedMaterials[0];
                r || (r = Hr.defaultMaterial);
                var i = new st();
                i.setTransform(this._owner._transform), i.render = e, i.material = r, this._trialGeometry = new Xr(this),
                    i.setGeometry(this._trialGeometry), t.push(i);
            }
        }, {
            key: "_update",
            value: function _update(e) {
                var t = this._owner._render;
                this._curtime += e.scene.timer._delta / 1e3, t._shaderValues.setNumber(Yr.CURTIME, this._curtime);
                var r = this._owner.transform.position,
                    i = t._renderElements[0]._geometry;
                i._updateDisappear(), i._updateTrail(e.camera, this._lastPosition, r), i._updateVertexBufferUV(),
                    r.cloneTo(this._lastPosition);
            }
        }, {
            key: "_initDefaultData",
            value: function _initDefaultData() {
                this.time = 5, this.minVertexDistance = .1, this.widthMultiplier = 1, this.textureMode = kr.Stretch;
                var e = [],
                    t = new u();
                t.time = 0, t.inTangent = 0, t.outTangent = 0, t.value = 1, e.push(t);
                var r = new u();
                r.time = 1, r.inTangent = 0, r.outTangent = 0, r.value = 1, e.push(r), this.widthCurve = e;
                var i = new Rt(2, 2);
                i.mode = St.Blend, i.addColorRGB(0, Ae.WHITE), i.addColorRGB(1, Ae.WHITE), i.addColorAlpha(0, 1),
                    i.addColorAlpha(1, 1), this.colorGradient = i;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._trialGeometry.destroy(), this._trialGeometry = null, this._widthCurve = null,
                    this._colorGradient = null;
            }
        }, {
            key: "time",
            get: function get() {
                return this._time;
            },
            set: function set(e) {
                this._time = e, this._owner._render._shaderValues.setNumber(Yr.LIFETIME, e);
            }
        }, {
            key: "minVertexDistance",
            get: function get() {
                return this._minVertexDistance;
            },
            set: function set(e) {
                this._minVertexDistance = e;
            }
        }, {
            key: "widthMultiplier",
            get: function get() {
                return this._widthMultiplier;
            },
            set: function set(e) {
                this._widthMultiplier = e;
            }
        }, {
            key: "widthCurve",
            get: function get() {
                return this._widthCurve;
            },
            set: function set(e) {
                this._widthCurve = e;
                var t, r, i = new Float32Array(4 * e.length),
                    a = 0;
                for (t = 0, r = e.length; t < r; t++) {
                    i[a++] = e[t].time, i[a++] = e[t].inTangent, i[a++] = e[t].outTangent, i[a++] = e[t].value;
                }
                this._owner._render._shaderValues.setBuffer(Yr.WIDTHCURVE, i), this._owner._render._shaderValues.setInt(Yr.WIDTHCURVEKEYLENGTH, e.length);
            }
        }, {
            key: "colorGradient",
            get: function get() {
                return this._colorGradient;
            },
            set: function set(e) {
                this._colorGradient = e;
            }
        }, {
            key: "textureMode",
            get: function get() {
                return this._textureMode;
            },
            set: function set(e) {
                this._textureMode = e;
            }
        }]);
        return Yr;
    }();
    Yr.CURTIME = H.propertyNameToID("u_CurTime"), Yr.LIFETIME = H.propertyNameToID("u_LifeTime"),
        Yr.WIDTHCURVE = H.propertyNameToID("u_WidthCurve"), Yr.WIDTHCURVEKEYLENGTH = H.propertyNameToID("u_WidthCurveKeyLength"),
        Yr.ALIGNMENT_VIEW = 0, Yr.ALIGNMENT_TRANSFORM_Z = 1;
    var Zr = /* */ function(_mt4) {
        _inherits(Zr, _mt4);

        function Zr(e) {
            var _this73;
            _classCallCheck(this, Zr);
            _this73 = _possibleConstructorReturn(this, _getPrototypeOf(Zr).call(this, e)), _this73._projectionViewWorldMatrix = new C();
            return _this73;
        }
        _createClass(Zr, [{
            key: "_calculateBoundingBox",
            value: function _calculateBoundingBox() {}
        }, {
            key: "_needRender",
            value: function _needRender(e, t) {
                return this._owner.trailFilter._update(t), !e || e.intersects(this.bounds._getBoundBox());
            }
        }, {
            key: "_updateForNative",
            value: function _updateForNative(e) {
                this._owner.trailFilter._update(e);
            }
        }, {
            key: "_renderUpdate",
            value: function _renderUpdate(e, t) {
                _get(_getPrototypeOf(Zr.prototype), "_renderUpdate", this).call(this, e, t);
            }
        }, {
            key: "_renderUpdateWithCamera",
            value: function _renderUpdateWithCamera(e, t) {
                var r = e.projectionViewMatrix;
                t ? (C.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(Le.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(Le.MVPMATRIX, r);
            }
        }]);
        return Zr;
    }(mt);
    var jr = /* */ function(_ye5) {
        _inherits(jr, _ye5);
        _createClass(jr, [{
            key: "trailFilter",
            get: function get() {
                return this._geometryFilter;
            }
        }, {
            key: "trailRenderer",
            get: function get() {
                return this._render;
            }
        }], [{
            key: "__init__",
            value: function __init__() {}
        }]);

        function jr() {
            var _this74;
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            _classCallCheck(this, jr);
            _this74 = _possibleConstructorReturn(this, _getPrototypeOf(jr).call(this, e)), _this74._render = new Zr(_assertThisInitialized(_this74)),
                _this74._geometryFilter = new Yr(_assertThisInitialized(_this74));
            return _this74;
        }
        _createClass(jr, [{
            key: "_parse",
            value: function _parse(e, r) {
                _get(_getPrototypeOf(jr.prototype), "_parse", this).call(this, e, r);
                var i, a, n = this._render,
                    s = this._geometryFilter,
                    o = e.materials;
                if (o) {
                    var l = n.sharedMaterials,
                        _ = o.length;
                    for (l.length = _, i = 0; i < _; i++) {
                        l[i] = t.Loader.getRes(o[i].path);
                    }
                    n.sharedMaterials = l;
                }
                s.time = e.time, s.minVertexDistance = e.minVertexDistance, s.widthMultiplier = e.widthMultiplier,
                    s.textureMode = e.textureMode, null != e.alignment && (s.alignment = e.alignment);
                var h = [],
                    c = e.widthCurve;
                for (i = 0, a = c.length; i < a; i++) {
                    var d = new u();
                    d.time = c[i].time, d.inTangent = c[i].inTangent, d.outTangent = c[i].outTangent,
                        d.value = c[i].value, h.push(d);
                }
                s.widthCurve = h;
                var m = e.colorGradient,
                    f = m.colorKeys,
                    E = m.alphaKeys,
                    T = new Rt(f.length, E.length);
                for (T.mode = m.mode, i = 0, a = f.length; i < a; i++) {
                    var p = f[i];
                    T.addColorRGB(p.time, new Ae(p.value[0], p.value[1], p.value[2], 1));
                }
                for (i = 0, a = E.length; i < a; i++) {
                    var g = E[i];
                    T.addColorAlpha(g.time, g.value);
                }
                s.colorGradient = T;
            }
        }, {
            key: "_onActive",
            value: function _onActive() {
                _get(_getPrototypeOf(jr.prototype), "_onActive", this).call(this), this._transform.position.cloneTo(this._geometryFilter._lastPosition);
            }
        }, {
            key: "_cloneTo",
            value: function _cloneTo(e, t, r) {
                var i, a;
                _get(_getPrototypeOf(jr.prototype), "_cloneTo", this).call(this, e, t, r);
                var n = e,
                    s = n.trailFilter;
                s.time = this.trailFilter.time, s.minVertexDistance = this.trailFilter.minVertexDistance,
                    s.widthMultiplier = this.trailFilter.widthMultiplier, s.textureMode = this.trailFilter.textureMode,
                    s.alignment = this.trailFilter.alignment;
                var o = this.trailFilter.widthCurve,
                    l = [];
                for (i = 0, a = o.length; i < a; i++) {
                    var _ = new u();
                    o[i].cloneTo(_), l.push(_);
                }
                s.widthCurve = l;
                var h = new Rt(this.trailFilter.colorGradient.maxColorRGBKeysCount, this.trailFilter.colorGradient.maxColorAlphaKeysCount);
                this.trailFilter.colorGradient.cloneTo(h), s.colorGradient = h, n.trailRenderer.sharedMaterial = this.trailRenderer.sharedMaterial;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
                this.destroyed || (_get(_getPrototypeOf(jr.prototype), "destroy", this).call(this, e),
                    this._geometryFilter.destroy(), this._geometryFilter = null);
            }
        }, {
            key: "_create",
            value: function _create() {
                return new jr();
            }
        }]);
        return jr;
    }(ye);
    var qr = /* */ function() {
        function qr(e, t, r, i) {
            _classCallCheck(this, qr);
            this._position = e, this._normal = t, this._textureCoord0 = r, this._textureCoord1 = i;
        }
        _createClass(qr, [{
            key: "position",
            get: function get() {
                return this._position;
            }
        }, {
            key: "normal",
            get: function get() {
                return this._normal;
            }
        }, {
            key: "textureCoord0",
            get: function get() {
                return this._textureCoord0;
            }
        }, {
            key: "textureCoord1",
            get: function get() {
                return this._textureCoord1;
            }
        }, {
            key: "vertexDeclaration",
            get: function get() {
                return qr._vertexDeclaration;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                qr._vertexDeclaration = new _e(40, [new he(0, le.Vector3, qr.TERRAIN_POSITION0), new he(12, le.Vector3, qr.TERRAIN_NORMAL0), new he(24, le.Vector2, qr.TERRAIN_TEXTURECOORDINATE0), new he(32, le.Vector2, qr.TERRAIN_TEXTURECOORDINATE1)]);
            }
        }, {
            key: "vertexDeclaration",
            get: function get() {
                return qr._vertexDeclaration;
            }
        }]);
        return qr;
    }();
    qr.TERRAIN_POSITION0 = 0, qr.TERRAIN_NORMAL0 = 1, qr.TERRAIN_TEXTURECOORDINATE0 = 2,
        qr.TERRAIN_TEXTURECOORDINATE1 = 3;
    var Qr = function Qr() {
        _classCallCheck(this, Qr);
    };
    Qr._interactive = {
        getWorldTransform: function getWorldTransform(e, t) {},
        setWorldTransform: function setWorldTransform(e, t) {
            var r = Rr._physicObjectsMap[e];
            r._simulation._updatedRigidbodies++, r._updateTransformComponent(t);
        }
    };
    var Kr = /* */ function(_Rr) {
        _inherits(Kr, _Rr);

        function Kr() {
            var _this75;
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .1;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Xt.COLLISIONFILTERGROUP_DEFAULTFILTER;
            var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Xt.COLLISIONFILTERGROUP_ALLFILTER;
            _classCallCheck(this, Kr);
            _this75 = _possibleConstructorReturn(this, _getPrototypeOf(Kr).call(this, r, i)),
                _this75._upAxis = new n(0, 1, 0), _this75._maxSlope = 45, _this75._jumpSpeed = 10,
                _this75._fallSpeed = 55, _this75._gravity = new n(0, 3 * -9.8, 0), _this75._btKinematicCharacter = null,
                _this75._stepHeight = e, t && (_this75._upAxis = t);
            return _this75;
        }
        _createClass(Kr, [{
            key: "_constructCharacter",
            value: function _constructCharacter() {
                var e = x._bullet;
                this._btKinematicCharacter && e.btKinematicCharacterController_destroy(this._btKinematicCharacter);
                var t = Kr._btTempVector30;
                e.btVector3_setValue(t, this._upAxis.x, this._upAxis.y, this._upAxis.z), this._btKinematicCharacter = e.btKinematicCharacterController_create(this._btColliderObject, this._colliderShape._btShape, this._stepHeight, t),
                    this.fallSpeed = this._fallSpeed, this.maxSlope = this._maxSlope, this.jumpSpeed = this._jumpSpeed,
                    this.gravity = this._gravity;
            }
        }, {
            key: "_onShapeChange",
            value: function _onShapeChange(e) {
                _get(_getPrototypeOf(Kr.prototype), "_onShapeChange", this).call(this, e), this._constructCharacter();
            }
        }, {
            key: "_onAdded",
            value: function _onAdded() {
                var e = x._bullet,
                    t = e.btPairCachingGhostObject_create();
                e.btCollisionObject_setUserIndex(t, this.id), e.btCollisionObject_setCollisionFlags(t, Rr.COLLISIONFLAGS_CHARACTER_OBJECT),
                    this._btColliderObject = t, this._colliderShape && this._constructCharacter(), _get(_getPrototypeOf(Kr.prototype), "_onAdded", this).call(this);
            }
        }, {
            key: "_addToSimulation",
            value: function _addToSimulation() {
                this._simulation._characters.push(this), this._simulation._addCharacter(this, this._collisionGroup, this._canCollideWith);
            }
        }, {
            key: "_removeFromSimulation",
            value: function _removeFromSimulation() {
                this._simulation._removeCharacter(this);
                var e = this._simulation._characters;
                e.splice(e.indexOf(this), 1);
            }
        }, {
            key: "_cloneTo",
            value: function _cloneTo(e) {
                _get(_getPrototypeOf(Kr.prototype), "_cloneTo", this).call(this, e);
                var t = e;
                t.stepHeight = this._stepHeight, t.upAxis = this._upAxis, t.maxSlope = this._maxSlope,
                    t.jumpSpeed = this._jumpSpeed, t.fallSpeed = this._fallSpeed, t.gravity = this._gravity;
            }
        }, {
            key: "_onDestroy",
            value: function _onDestroy() {
                x._bullet.btKinematicCharacterController_destroy(this._btKinematicCharacter), _get(_getPrototypeOf(Kr.prototype), "_onDestroy", this).call(this),
                    this._btKinematicCharacter = null;
            }
        }, {
            key: "move",
            value: function move(e) {
                var t = Kr._btVector30,
                    r = x._bullet;
                r.btVector3_setValue(t, -e.x, e.y, e.z), r.btKinematicCharacterController_setWalkDirection(this._btKinematicCharacter, t);
            }
        }, {
            key: "jump",
            value: function jump() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                var t = x._bullet,
                    r = Kr._btVector30;
                e ? (I._convertToBulletVec3(e, r, !0), t.btKinematicCharacterController_jump(this._btKinematicCharacter, r)) : (t.btVector3_setValue(r, 0, 0, 0),
                    t.btKinematicCharacterController_jump(this._btKinematicCharacter, r));
            }
        }, {
            key: "fallSpeed",
            get: function get() {
                return this._fallSpeed;
            },
            set: function set(e) {
                this._fallSpeed = e, x._bullet.btKinematicCharacterController_setFallSpeed(this._btKinematicCharacter, e);
            }
        }, {
            key: "jumpSpeed",
            get: function get() {
                return this._jumpSpeed;
            },
            set: function set(e) {
                this._jumpSpeed = e, x._bullet.btKinematicCharacterController_setJumpSpeed(this._btKinematicCharacter, e);
            }
        }, {
            key: "gravity",
            get: function get() {
                return this._gravity;
            },
            set: function set(e) {
                this._gravity = e;
                var t = x._bullet,
                    r = Kr._btTempVector30;
                t.btVector3_setValue(r, -e.x, e.y, e.z), t.btKinematicCharacterController_setGravity(this._btKinematicCharacter, r);
            }
        }, {
            key: "maxSlope",
            get: function get() {
                return this._maxSlope;
            },
            set: function set(e) {
                this._maxSlope = e, x._bullet.btKinematicCharacterController_setMaxSlope(this._btKinematicCharacter, e / 180 * Math.PI);
            }
        }, {
            key: "isGrounded",
            get: function get() {
                return x._bullet.btKinematicCharacterController_onGround(this._btKinematicCharacter);
            }
        }, {
            key: "stepHeight",
            get: function get() {
                return this._stepHeight;
            },
            set: function set(e) {
                this._stepHeight = e, x._bullet.btKinematicCharacterController_setStepHeight(this._btKinematicCharacter, e);
            }
        }, {
            key: "upAxis",
            get: function get() {
                return this._upAxis;
            },
            set: function set(e) {
                this._upAxis = e;
                var t = Kr._btTempVector30;
                I._convertToBulletVec3(e, t, !1), x._bullet.btKinematicCharacterController_setUp(this._btKinematicCharacter, t);
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                Kr._btTempVector30 = x._bullet.btVector3_create(0, 0, 0);
            }
        }]);
        return Kr;
    }(Rr);
    Kr.UPAXIS_X = 0, Kr.UPAXIS_Y = 1, Kr.UPAXIS_Z = 2;
    var Jr = /* */ function(_Rr2) {
        _inherits(Jr, _Rr2);

        function Jr(e, t) {
            var _this76;
            _classCallCheck(this, Jr);
            _this76 = _possibleConstructorReturn(this, _getPrototypeOf(Jr).call(this, e, t)),
                _this76._isTrigger = !1;
            return _this76;
        }
        _createClass(Jr, [{
            key: "_onAdded",
            value: function _onAdded() {
                _get(_getPrototypeOf(Jr.prototype), "_onAdded", this).call(this), this.isTrigger = this._isTrigger;
            }
        }, {
            key: "_cloneTo",
            value: function _cloneTo(e) {
                _get(_getPrototypeOf(Jr.prototype), "_cloneTo", this).call(this, e), e.isTrigger = this._isTrigger;
            }
        }, {
            key: "isTrigger",
            get: function get() {
                return this._isTrigger;
            },
            set: function set(e) {
                this._isTrigger = e;
                var t = x._bullet;
                if (this._btColliderObject) {
                    var r = t.btCollisionObject_getCollisionFlags(this._btColliderObject);
                    e ? 0 == (r & Rr.COLLISIONFLAGS_NO_CONTACT_RESPONSE) && t.btCollisionObject_setCollisionFlags(this._btColliderObject, r | Rr.COLLISIONFLAGS_NO_CONTACT_RESPONSE) : 0 != (r & Rr.COLLISIONFLAGS_NO_CONTACT_RESPONSE) && t.btCollisionObject_setCollisionFlags(this._btColliderObject, r ^ Rr.COLLISIONFLAGS_NO_CONTACT_RESPONSE);
                }
            }
        }]);
        return Jr;
    }(Rr);
    var $r = /* */ function(_Jr) {
        _inherits($r, _Jr);

        function $r() {
            var _this77;
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Xt.COLLISIONFILTERGROUP_DEFAULTFILTER;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Xt.COLLISIONFILTERGROUP_ALLFILTER;
            _classCallCheck(this, $r);
            _this77 = _possibleConstructorReturn(this, _getPrototypeOf($r).call(this, e, t)),
                _this77._enableProcessCollisions = !1;
            return _this77;
        }
        _createClass($r, [{
            key: "_addToSimulation",
            value: function _addToSimulation() {
                this._simulation._addPhysicsCollider(this, this._collisionGroup, this._canCollideWith);
            }
        }, {
            key: "_removeFromSimulation",
            value: function _removeFromSimulation() {
                this._simulation._removePhysicsCollider(this);
            }
        }, {
            key: "_onTransformChanged",
            value: function _onTransformChanged(e) {
                (e &= De.TRANSFORM_WORLDPOSITION | De.TRANSFORM_WORLDQUATERNION | De.TRANSFORM_WORLDSCALE) && (this._transformFlag |= e,
                    this._isValid() && -1 === this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.add(this));
            }
        }, {
            key: "_parse",
            value: function _parse(e) {
                null != e.friction && (this.friction = e.friction), null != e.rollingFriction && (this.rollingFriction = e.rollingFriction),
                    null != e.restitution && (this.restitution = e.restitution), null != e.isTrigger && (this.isTrigger = e.isTrigger),
                    _get(_getPrototypeOf($r.prototype), "_parse", this).call(this, e), this._parseShape(e.shapes);
            }
        }, {
            key: "_onAdded",
            value: function _onAdded() {
                var e = x._bullet,
                    t = e.btCollisionObject_create();
                e.btCollisionObject_setUserIndex(t, this.id), e.btCollisionObject_forceActivationState(t, Rr.ACTIVATIONSTATE_DISABLE_SIMULATION);
                var r = e.btCollisionObject_getCollisionFlags(t);
                this.owner.isStatic ? ((r & Rr.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0 && (r ^= Rr.COLLISIONFLAGS_KINEMATIC_OBJECT),
                        r |= Rr.COLLISIONFLAGS_STATIC_OBJECT) : ((r & Rr.COLLISIONFLAGS_STATIC_OBJECT) > 0 && (r ^= Rr.COLLISIONFLAGS_STATIC_OBJECT),
                        r |= Rr.COLLISIONFLAGS_KINEMATIC_OBJECT), e.btCollisionObject_setCollisionFlags(t, r),
                    this._btColliderObject = t, _get(_getPrototypeOf($r.prototype), "_onAdded", this).call(this);
            }
        }]);
        return $r;
    }(Jr);
    var ei = /* */ function(_Jr2) {
        _inherits(ei, _Jr2);

        function ei() {
            var _this78;
            var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Xt.COLLISIONFILTERGROUP_DEFAULTFILTER;
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Xt.COLLISIONFILTERGROUP_ALLFILTER;
            _classCallCheck(this, ei);
            _this78 = _possibleConstructorReturn(this, _getPrototypeOf(ei).call(this, e, t)),
                _this78._isKinematic = !1, _this78._mass = 1, _this78._gravity = new n(0, -10, 0),
                _this78._angularDamping = 0, _this78._linearDamping = 0, _this78._overrideGravity = !1,
                _this78._totalTorque = new n(0, 0, 0), _this78._totalForce = new n(0, 0, 0), _this78._linearVelocity = new n(),
                _this78._angularVelocity = new n(), _this78._linearFactor = new n(1, 1, 1), _this78._angularFactor = new n(1, 1, 1),
                _this78._detectCollisions = !0;
            return _this78;
        }
        _createClass(ei, [{
            key: "_updateMass",
            value: function _updateMass(e) {
                if (this._btColliderObject && this._colliderShape) {
                    var t = x._bullet;
                    t.btCollisionShape_calculateLocalInertia(this._colliderShape._btShape, e, ei._btInertia),
                        t.btRigidBody_setMassProps(this._btColliderObject, e, ei._btInertia), t.btRigidBody_updateInertiaTensor(this._btColliderObject);
                }
            }
        }, {
            key: "_onScaleChange",
            value: function _onScaleChange(e) {
                _get(_getPrototypeOf(ei.prototype), "_onScaleChange", this).call(this, e), this._updateMass(this._isKinematic ? 0 : this._mass);
            }
        }, {
            key: "_onAdded",
            value: function _onAdded() {
                var e = x._bullet,
                    t = e.layaMotionState_create();
                e.layaMotionState_set_rigidBodyID(t, this._id), this._btLayaMotionState = t;
                var r = e.btRigidBodyConstructionInfo_create(0, t, null, ei._btVector3Zero),
                    i = e.btRigidBody_create(r);
                e.btCollisionObject_setUserIndex(i, this.id), this._btColliderObject = i, _get(_getPrototypeOf(ei.prototype), "_onAdded", this).call(this),
                    this.mass = this._mass, this.linearFactor = this._linearFactor, this.angularFactor = this._angularFactor,
                    this.linearDamping = this._linearDamping, this.angularDamping = this._angularDamping,
                    this.overrideGravity = this._overrideGravity, this.gravity = this._gravity, this.isKinematic = this._isKinematic,
                    e.btRigidBodyConstructionInfo_destroy(r);
            }
        }, {
            key: "_onShapeChange",
            value: function _onShapeChange(e) {
                if (_get(_getPrototypeOf(ei.prototype), "_onShapeChange", this).call(this, e), this._isKinematic) this._updateMass(0);
                else {
                    var t = x._bullet;
                    t.btRigidBody_setCenterOfMassTransform(this._btColliderObject, t.btCollisionObject_getWorldTransform(this._btColliderObject)),
                        this._updateMass(this._mass);
                }
            }
        }, {
            key: "_parse",
            value: function _parse(e) {
                if (null != e.friction && (this.friction = e.friction), null != e.rollingFriction && (this.rollingFriction = e.rollingFriction),
                    null != e.restitution && (this.restitution = e.restitution), null != e.isTrigger && (this.isTrigger = e.isTrigger),
                    null != e.mass && (this.mass = e.mass), null != e.isKinematic && (this.isKinematic = e.isKinematic),
                    null != e.linearDamping && (this.linearDamping = e.linearDamping), null != e.angularDamping && (this.angularDamping = e.angularDamping),
                    null != e.overrideGravity && (this.overrideGravity = e.overrideGravity), null != e.linearFactor) {
                    var t = this.linearFactor;
                    t.fromArray(e.linearFactor), this.linearFactor = t;
                }
                if (null != e.angularFactor) {
                    var r = this.angularFactor;
                    r.fromArray(e.angularFactor), this.angularFactor = r;
                }
                e.gravity && (this.gravity.fromArray(e.gravity), this.gravity = this.gravity), _get(_getPrototypeOf(ei.prototype), "_parse", this).call(this, e),
                    this._parseShape(e.shapes);
            }
        }, {
            key: "_onDestroy",
            value: function _onDestroy() {
                x._bullet.btMotionState_destroy(this._btLayaMotionState), _get(_getPrototypeOf(ei.prototype), "_onDestroy", this).call(this),
                    this._btLayaMotionState = null, this._gravity = null, this._totalTorque = null,
                    this._linearVelocity = null, this._angularVelocity = null, this._linearFactor = null,
                    this._angularFactor = null;
            }
        }, {
            key: "_addToSimulation",
            value: function _addToSimulation() {
                this._simulation._addRigidBody(this, this._collisionGroup, this._detectCollisions ? this._canCollideWith : 0);
            }
        }, {
            key: "_removeFromSimulation",
            value: function _removeFromSimulation() {
                this._simulation._removeRigidBody(this);
            }
        }, {
            key: "_cloneTo",
            value: function _cloneTo(e) {
                _get(_getPrototypeOf(ei.prototype), "_cloneTo", this).call(this, e);
                var t = e;
                t.isKinematic = this._isKinematic, t.mass = this._mass, t.gravity = this._gravity,
                    t.angularDamping = this._angularDamping, t.linearDamping = this._linearDamping,
                    t.overrideGravity = this._overrideGravity, t.linearVelocity = this._linearVelocity,
                    t.angularVelocity = this._angularVelocity, t.linearFactor = this._linearFactor,
                    t.angularFactor = this._angularFactor, t.detectCollisions = this._detectCollisions;
            }
        }, {
            key: "applyForce",
            value: function applyForce(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                if (null == this._btColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var r = x._bullet,
                    i = ei._btTempVector30;
                if (r.btVector3_setValue(i, -e.x, e.y, e.z), t) {
                    var a = ei._btTempVector31;
                    r.btVector3_setValue(a, -t.x, t.y, t.z), r.btRigidBody_applyForce(this._btColliderObject, i, a);
                } else r.btRigidBody_applyCentralForce(this._btColliderObject, i);
            }
        }, {
            key: "applyTorque",
            value: function applyTorque(e) {
                if (null == this._btColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var t = x._bullet,
                    r = ei._btTempVector30;
                t.btVector3_setValue(r, -e.x, e.y, e.z), t.btRigidBody_applyTorque(this._btColliderObject, r);
            }
        }, {
            key: "applyImpulse",
            value: function applyImpulse(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                if (null == this._btColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var r = x._bullet;
                r.btVector3_setValue(ei._btImpulse, -e.x, e.y, e.z), t ? (r.btVector3_setValue(ei._btImpulseOffset, -t.x, t.y, t.z),
                    r.btRigidBody_applyImpulse(this._btColliderObject, ei._btImpulse, ei._btImpulseOffset)) : r.btRigidBody_applyCentralImpulse(this._btColliderObject, ei._btImpulse);
            }
        }, {
            key: "applyTorqueImpulse",
            value: function applyTorqueImpulse(e) {
                if (null == this._btColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var t = x._bullet,
                    r = ei._btTempVector30;
                t.btVector3_setValue(r, -e.x, e.y, e.z), t.btRigidBody_applyTorqueImpulse(this._btColliderObject, r);
            }
        }, {
            key: "wakeUp",
            value: function wakeUp() {
                this._btColliderObject && x._bullet.btCollisionObject_activate(this._btColliderObject, !1);
            }
        }, {
            key: "clearForces",
            value: function clearForces() {
                var e = this._btColliderObject;
                if (null == e) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var t = x._bullet;
                t.btRigidBody_clearForces(e);
                var r = ei._btVector3Zero;
                t.btCollisionObject_setInterpolationLinearVelocity(e, r), t.btRigidBody_setLinearVelocity(e, r),
                    t.btCollisionObject_setInterpolationAngularVelocity(e, r), t.btRigidBody_setAngularVelocity(e, r);
            }
        }, {
            key: "mass",
            get: function get() {
                return this._mass;
            },
            set: function set(e) {
                e = Math.max(e, 1e-7), this._mass = e, this._isKinematic || this._updateMass(e);
            }
        }, {
            key: "isKinematic",
            get: function get() {
                return this._isKinematic;
            },
            set: function set(e) {
                this._isKinematic = e;
                var t = x._bullet,
                    r = !!(this._simulation && this._enabled && this._colliderShape);
                r && this._removeFromSimulation();
                var i = this._btColliderObject,
                    a = t.btCollisionObject_getCollisionFlags(i);
                e ? (a |= Rr.COLLISIONFLAGS_KINEMATIC_OBJECT, t.btCollisionObject_setCollisionFlags(i, a),
                    t.btCollisionObject_forceActivationState(this._btColliderObject, Rr.ACTIVATIONSTATE_DISABLE_DEACTIVATION),
                    this._enableProcessCollisions = !1, this._updateMass(0)) : ((a & Rr.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0 && (a ^= Rr.COLLISIONFLAGS_KINEMATIC_OBJECT),
                    t.btCollisionObject_setCollisionFlags(i, a), t.btCollisionObject_setActivationState(this._btColliderObject, Rr.ACTIVATIONSTATE_ACTIVE_TAG),
                    this._enableProcessCollisions = !0, this._updateMass(this._mass));
                var n = ei._btVector3Zero;
                t.btCollisionObject_setInterpolationLinearVelocity(i, n), t.btRigidBody_setLinearVelocity(i, n),
                    t.btCollisionObject_setInterpolationAngularVelocity(i, n), t.btRigidBody_setAngularVelocity(i, n),
                    r && this._addToSimulation();
            }
        }, {
            key: "linearDamping",
            get: function get() {
                return this._linearDamping;
            },
            set: function set(e) {
                this._linearDamping = e, this._btColliderObject && x._bullet.btRigidBody_setDamping(this._btColliderObject, e, this._angularDamping);
            }
        }, {
            key: "angularDamping",
            get: function get() {
                return this._angularDamping;
            },
            set: function set(e) {
                this._angularDamping = e, this._btColliderObject && x._bullet.btRigidBody_setDamping(this._btColliderObject, this._linearDamping, e);
            }
        }, {
            key: "overrideGravity",
            get: function get() {
                return this._overrideGravity;
            },
            set: function set(e) {
                this._overrideGravity = e;
                var t = x._bullet;
                if (this._btColliderObject) {
                    var r = t.btRigidBody_getFlags(this._btColliderObject);
                    e ? 0 == (r & ei._BT_DISABLE_WORLD_GRAVITY) && t.btRigidBody_setFlags(this._btColliderObject, r | ei._BT_DISABLE_WORLD_GRAVITY) : (r & ei._BT_DISABLE_WORLD_GRAVITY) > 0 && t.btRigidBody_setFlags(this._btColliderObject, r ^ ei._BT_DISABLE_WORLD_GRAVITY);
                }
            }
        }, {
            key: "gravity",
            get: function get() {
                return this._gravity;
            },
            set: function set(e) {
                this._gravity = e;
                var t = x._bullet;
                t.btVector3_setValue(ei._btGravity, -e.x, e.y, e.z), t.btRigidBody_setGravity(this._btColliderObject, ei._btGravity);
            }
        }, {
            key: "totalForce",
            get: function get() {
                if (this._btColliderObject) {
                    var e = x._bullet.btRigidBody_getTotalForce(this._btColliderObject);
                    return I._convertToLayaVec3(e, this._totalForce, !0), this._totalForce;
                }
                return null;
            }
        }, {
            key: "linearFactor",
            get: function get() {
                return this._linearFactor;
            },
            set: function set(e) {
                this._linearFactor = e;
                var t = ei._btTempVector30;
                I._convertToBulletVec3(e, t, !1), x._bullet.btRigidBody_setLinearFactor(this._btColliderObject, t);
            }
        }, {
            key: "linearVelocity",
            get: function get() {
                return this._btColliderObject && I._convertToLayaVec3(x._bullet.btRigidBody_getLinearVelocity(this._btColliderObject), this._linearVelocity, !0),
                    this._linearVelocity;
            },
            set: function set(e) {
                if (this._linearVelocity = e, this._btColliderObject) {
                    var t = ei._btTempVector30;
                    I._convertToBulletVec3(e, t, !0), this.isSleeping && this.wakeUp(), x._bullet.btRigidBody_setLinearVelocity(this._btColliderObject, t);
                }
            }
        }, {
            key: "angularFactor",
            get: function get() {
                return this._angularFactor;
            },
            set: function set(e) {
                this._angularFactor = e;
                var t = ei._btTempVector30;
                I._convertToBulletVec3(e, t, !1), x._bullet.btRigidBody_setAngularFactor(this._btColliderObject, t);
            }
        }, {
            key: "angularVelocity",
            get: function get() {
                return this._btColliderObject && I._convertToLayaVec3(x._bullet.btRigidBody_getAngularVelocity(this._btColliderObject), this._angularVelocity, !0),
                    this._angularVelocity;
            },
            set: function set(e) {
                if (this._angularVelocity = e, this._btColliderObject) {
                    var t = ei._btTempVector30;
                    I._convertToBulletVec3(e, t, !0), this.isSleeping && this.wakeUp(), x._bullet.btRigidBody_setAngularVelocity(this._btColliderObject, t);
                }
            }
        }, {
            key: "totalTorque",
            get: function get() {
                if (this._btColliderObject) {
                    var e = x._bullet.btRigidBody_getTotalTorque(this._btColliderObject);
                    return I._convertToLayaVec3(e, this._totalTorque, !0), this._totalTorque;
                }
                return null;
            }
        }, {
            key: "detectCollisions",
            get: function get() {
                return this._detectCollisions;
            },
            set: function set(e) {
                this._detectCollisions !== e && (this._detectCollisions = e, this._colliderShape && this._enabled && this._simulation && (this._simulation._removeRigidBody(this),
                    this._simulation._addRigidBody(this, this._collisionGroup, e ? this._canCollideWith : 0)));
            }
        }, {
            key: "isSleeping",
            get: function get() {
                return !!this._btColliderObject && x._bullet.btCollisionObject_getActivationState(this._btColliderObject) === Rr.ACTIVATIONSTATE_ISLAND_SLEEPING;
            }
        }, {
            key: "sleepLinearVelocity",
            get: function get() {
                return x._bullet.btRigidBody_getLinearSleepingThreshold(this._btColliderObject);
            },
            set: function set(e) {
                var t = x._bullet;
                t.btRigidBody_setSleepingThresholds(this._btColliderObject, e, t.btRigidBody_getAngularSleepingThreshold(this._btColliderObject));
            }
        }, {
            key: "sleepAngularVelocity",
            get: function get() {
                return x._bullet.btRigidBody_getAngularSleepingThreshold(this._btColliderObject);
            },
            set: function set(e) {
                var t = x._bullet;
                t.btRigidBody_setSleepingThresholds(this._btColliderObject, t.btRigidBody_getLinearSleepingThreshold(this._btColliderObject), e);
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                var e = x._bullet;
                ei._btTempVector30 = e.btVector3_create(0, 0, 0), ei._btTempVector31 = e.btVector3_create(0, 0, 0),
                    ei._btVector3Zero = e.btVector3_create(0, 0, 0), ei._btInertia = e.btVector3_create(0, 0, 0),
                    ei._btImpulse = e.btVector3_create(0, 0, 0), ei._btImpulseOffset = e.btVector3_create(0, 0, 0),
                    ei._btGravity = e.btVector3_create(0, 0, 0);
            }
        }]);
        return ei;
    }(Jr);
    ei.TYPE_STATIC = 0, ei.TYPE_DYNAMIC = 1, ei.TYPE_KINEMATIC = 2, ei._BT_DISABLE_WORLD_GRAVITY = 1,
        ei._BT_ENABLE_GYROPSCOPIC_FORCE = 2;
    var ti = /* */ function(_ur8) {
        _inherits(ti, _ur8);
        _createClass(ti, null, [{
            key: "__init__",
            value: function __init__() {
                ti._btNormal = x._bullet.btVector3_create(0, 0, 0);
            }
        }]);

        function ti(e, t) {
            var _this79;
            _classCallCheck(this, ti);
            _this79 = _possibleConstructorReturn(this, _getPrototypeOf(ti).call(this)), _this79._normal = e,
                _this79._offset = t, _this79._type = ur.SHAPETYPES_STATICPLANE;
            var r = x._bullet;
            r.btVector3_setValue(ti._btNormal, -e.x, e.y, e.z), _this79._btShape = r.btStaticPlaneShape_create(ti._btNormal, t);
            return _this79;
        }
        _createClass(ti, [{
            key: "clone",
            value: function clone() {
                var e = new ti(this._normal, this._offset);
                return this.cloneTo(e), e;
            }
        }]);
        return ti;
    }(ur);
    var ri = /* */ function(_Pe7) {
        _inherits(ri, _Pe7);

        function ri(e) {
            var _this80;
            _classCallCheck(this, ri);
            _this80 = _possibleConstructorReturn(this, _getPrototypeOf(ri).call(this)), _this80._id = ++ri._uniqueIDCounter,
                _this80._mesh = e, _this80._boneIndicesList = [], _this80._subIndexBufferStart = [],
                _this80._subIndexBufferCount = [];
            return _this80;
        }
        _createClass(ri, [{
            key: "_setIndexRange",
            value: function _setIndexRange(e, t) {
                this._indexStart = e, this._indexCount = t, this._indices = new Uint16Array(this._indexBuffer.getData().buffer, 2 * e, t);
            }
        }, {
            key: "_getType",
            value: function _getType() {
                return ri._type;
            }
        }, {
            key: "_prepareRender",
            value: function _prepareRender(e) {
                return this._mesh._uploadVerticesData(), !0;
            }
        }, {
            key: "_render",
            value: function _render(r) {
                var i = this._mesh;
                if (i.indexFormat !== e.IndexFormat.UInt32 || t.LayaGL.layaGPUInstance.supportElementIndexUint32()) {
                    var a, n = t.LayaGL.instance,
                        s = r.renderElement.render._skinnedData;
                    switch (i.indexFormat) {
                        case e.IndexFormat.UInt32:
                            a = n.UNSIGNED_INT;
                            break;

                        case e.IndexFormat.UInt16:
                            a = n.UNSIGNED_SHORT;
                            break;

                        case e.IndexFormat.UInt8:
                            a = n.UNSIGNED_BYTE;
                    }
                    if (i._bufferState.bind(), s)
                        for (var o = s[this._indexInMesh], l = 0, _ = this._boneIndicesList.length; l < _; l++) {
                            r.shader.uploadCustomUniform(zr.BONES, o[l]), n.drawElements(n.TRIANGLES, this._subIndexBufferCount[l], a, 2 * this._subIndexBufferStart[l]);
                        } else n.drawElements(n.TRIANGLES, this._indexCount, a, 2 * this._indexStart);
                    t.Stat.trianglesFaces += this._indexCount / 3, t.Stat.renderBatches++;
                } else console.warn("SubMesh:this device do not support IndexFormat.UInt32.");
            }
        }, {
            key: "getIndices",
            value: function getIndices() {
                if (this._mesh._isReadable) return this._indices.slice();
                throw "SubMesh:can't get indices on subMesh,mesh's isReadable must be true.";
            }
        }, {
            key: "setIndices",
            value: function setIndices(e) {
                this._indexBuffer.setData(e, this._indexStart, 0, this._indexCount);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._destroyed || (_get(_getPrototypeOf(ri.prototype), "destroy", this).call(this),
                    this._indexBuffer.destroy(), this._indexBuffer = null, this._mesh = null, this._boneIndicesList = null,
                    this._subIndexBufferStart = null, this._subIndexBufferCount = null, this._skinAnimationDatas = null);
            }
        }, {
            key: "indexCount",
            get: function get() {
                return this._indexCount;
            }
        }]);
        return ri;
    }(Pe);
    ri._uniqueIDCounter = 0, ri._type = Pe._typeCounter++;
    var ii = function ii(e, t, r) {
        _classCallCheck(this, ii);
        this.subMeshIndex = e, this.batchIndex = t, this.batchBoneIndex = r;
    };
    var ai = /* */ function(_t$Resource7) {
        _inherits(ai, _t$Resource7);

        function ai() {
            var _this81;
            var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
            _classCallCheck(this, ai);
            _this81 = _possibleConstructorReturn(this, _getPrototypeOf(ai).call(this)), _this81._tempVector30 = new n(),
                _this81._tempVector31 = new n(), _this81._tempVector32 = new n(), _this81._minVerticesUpdate = -1,
                _this81._maxVerticesUpdate = -1, _this81._needUpdateBounds = !0, _this81._bounds = new ut(new n(), new n()),
                _this81._bufferState = new Xe(), _this81._instanceBufferState = new Xe(), _this81._vertexBuffer = null,
                _this81._indexBuffer = null, _this81._skinnedMatrixCaches = [], _this81._vertexCount = 0,
                _this81._indexFormat = e.IndexFormat.UInt16, _this81._isReadable = t, _this81._subMeshes = [];
            return _this81;
        }
        _createClass(ai, [{
            key: "_getPositionElement",
            value: function _getPositionElement(e) {
                for (var t = e.vertexDeclaration._vertexElements, r = 0, i = t.length; r < i; r++) {
                    var a = t[r];
                    if (a._elementFormat === le.Vector3 && a._elementUsage === ce.MESH_POSITION0) return a;
                }
                return null;
            }
        }, {
            key: "_getVerticeElementData",
            value: function _getVerticeElementData(e, t) {
                e.length = this._vertexCount;
                var r = this._vertexBuffer.vertexDeclaration,
                    s = r.getVertexElementByUsage(t);
                if (s) {
                    var o = this._vertexBuffer.getUint8Data(),
                        l = this._vertexBuffer.getFloat32Data(),
                        _ = r.vertexStride,
                        h = _ / 4,
                        c = s._offset,
                        d = c / 4;
                    switch (t) {
                        case ce.MESH_TEXTURECOORDINATE0:
                        case ce.MESH_TEXTURECOORDINATE1:
                            for (var u = 0; u < this._vertexCount; u++) {
                                var m = h * u + d;
                                e[u] = new i(l[m], l[m + 1]);
                            }
                            break;

                        case ce.MESH_POSITION0:
                        case ce.MESH_NORMAL0:
                            for (u = 0; u < this._vertexCount; u++) {
                                m = h * u + d;
                                e[u] = new n(l[m], l[m + 1], l[m + 2]);
                            }
                            break;

                        case ce.MESH_TANGENT0:
                        case ce.MESH_BLENDWEIGHT0:
                            for (u = 0; u < this._vertexCount; u++) {
                                m = h * u + d;
                                e[u] = new a(l[m], l[m + 1], l[m + 2], l[m + 3]);
                            }
                            break;

                        case ce.MESH_COLOR0:
                            for (u = 0; u < this._vertexCount; u++) {
                                m = h * u + d;
                                e[u] = new Ae(l[m], l[m + 1], l[m + 2], l[m + 3]);
                            }
                            break;

                        case ce.MESH_BLENDINDICES0:
                            for (u = 0; u < this._vertexCount; u++) {
                                m = _ * u + c;
                                e[u] = new a(o[m], o[m + 1], o[m + 2], o[m + 3]);
                            }
                            break;

                        default:
                            throw "Mesh:Unknown elementUsage.";
                    }
                }
            }
        }, {
            key: "_setVerticeElementData",
            value: function _setVerticeElementData(e, t) {
                var r = this._vertexBuffer.vertexDeclaration,
                    i = r.getVertexElementByUsage(t);
                if (i) {
                    var a = this._vertexBuffer.getUint8Data(),
                        n = this._vertexBuffer.getFloat32Data(),
                        s = r.vertexStride,
                        o = s / 4,
                        l = i._offset,
                        _ = l / 4;
                    switch (t) {
                        case ce.MESH_TEXTURECOORDINATE0:
                        case ce.MESH_TEXTURECOORDINATE1:
                            for (var h = 0, c = e.length; h < c; h++) {
                                var d = o * h + _,
                                    u = e[h];
                                n[d] = u.x, n[d + 1] = u.y;
                            }
                            break;

                        case ce.MESH_POSITION0:
                        case ce.MESH_NORMAL0:
                            for (h = 0, c = e.length; h < c; h++) {
                                d = o * h + _;
                                var m = e[h];
                                n[d] = m.x, n[d + 1] = m.y, n[d + 2] = m.z;
                            }
                            break;

                        case ce.MESH_TANGENT0:
                        case ce.MESH_BLENDWEIGHT0:
                            for (h = 0, c = e.length; h < c; h++) {
                                d = o * h + _;
                                var f = e[h];
                                n[d] = f.x, n[d + 1] = f.y, n[d + 2] = f.z, n[d + 3] = f.w;
                            }
                            break;

                        case ce.MESH_COLOR0:
                            for (h = 0, c = e.length; h < c; h++) {
                                d = o * h + _;
                                var E = e[h];
                                n[d] = E.r, n[d + 1] = E.g, n[d + 2] = E.b, n[d + 3] = E.a;
                            }
                            break;

                        case ce.MESH_BLENDINDICES0:
                            for (h = 0, c = e.length; h < c; h++) {
                                d = s * h + l, f = e[h];
                                a[d] = f.x, a[d + 1] = f.y, a[d + 2] = f.z, a[d + 3] = f.w;
                            }
                            break;

                        default:
                            throw "Mesh:Unknown elementUsage.";
                    }
                    this._minVerticesUpdate = 0, this._maxVerticesUpdate = Number.MAX_SAFE_INTEGER;
                } else console.warn("Mesh: the mesh don't have  this VertexElement.");
            }
        }, {
            key: "_disposeResource",
            value: function _disposeResource() {
                for (var e = 0, t = this._subMeshes.length; e < t; e++) {
                    this._subMeshes[e].destroy();
                }
                this._btTriangleMesh && x._bullet.btStridingMeshInterface_destroy(this._btTriangleMesh),
                    this._vertexBuffer.destroy(), this._indexBuffer.destroy(), this._bufferState.destroy(),
                    this._instanceBufferState.destroy(), this._setCPUMemory(0), this._setGPUMemory(0),
                    this._bufferState = null, this._instanceBufferState = null, this._vertexBuffer = null,
                    this._indexBuffer = null, this._subMeshes = null, this._btTriangleMesh = null, this._indexBuffer = null,
                    this._boneNames = null, this._inverseBindPoses = null;
            }
        }, {
            key: "_setSubMeshes",
            value: function _setSubMeshes(e) {
                this._subMeshes = e;
                for (var t = 0, r = e.length; t < r; t++) {
                    e[t]._indexInMesh = t;
                }
            }
        }, {
            key: "_setBuffer",
            value: function _setBuffer(e, t) {
                var r = this._bufferState;
                r.bind(), r.applyVertexBuffer(e), r.applyIndexBuffer(t), r.unBind();
                var i = this._instanceBufferState;
                i.bind(), i.applyVertexBuffer(e), i.applyInstanceVertexBuffer(Ve.instance.instanceWorldMatrixBuffer),
                    i.applyInstanceVertexBuffer(Ve.instance.instanceMVPMatrixBuffer), i.applyIndexBuffer(t),
                    i.unBind();
            }
        }, {
            key: "_getPhysicMesh",
            value: function _getPhysicMesh() {
                if (!this._btTriangleMesh) {
                    for (var e = x._bullet, t = e.btTriangleMesh_create(), r = ai._nativeTempVector30, i = ai._nativeTempVector31, a = ai._nativeTempVector32, n = this._tempVector30, s = this._tempVector31, o = this._tempVector32, l = this._vertexBuffer, _ = this._getPositionElement(l), h = l.getFloat32Data(), c = l.vertexDeclaration.vertexStride / 4, d = _._offset / 4, u = this._indexBuffer.getData(), m = 0, f = u.length; m < f; m += 3) {
                        var E = u[m] * c + d,
                            T = u[m + 1] * c + d,
                            p = u[m + 2] * c + d;
                        n.setValue(h[E], h[E + 1], h[E + 2]), s.setValue(h[T], h[T + 1], h[T + 2]), o.setValue(h[p], h[p + 1], h[p + 2]),
                            I._convertToBulletVec3(n, r, !0), I._convertToBulletVec3(s, i, !0), I._convertToBulletVec3(o, a, !0),
                            e.btTriangleMesh_addTriangle(t, r, i, a, !0);
                    }
                    this._btTriangleMesh = t;
                }
                return this._btTriangleMesh;
            }
        }, {
            key: "_uploadVerticesData",
            value: function _uploadVerticesData() {
                var e = this._minVerticesUpdate,
                    t = this._maxVerticesUpdate;
                if (-1 !== e && -1 !== t) {
                    var r = e;
                    this._vertexBuffer.setData(this._vertexBuffer.getUint8Data().buffer, r, r, t - e),
                        this._minVerticesUpdate = -1, this._maxVerticesUpdate = -1;
                }
            }
        }, {
            key: "getSubMesh",
            value: function getSubMesh(e) {
                return this._subMeshes[e];
            }
        }, {
            key: "getPositions",
            value: function getPositions(e) {
                if (!this._isReadable) throw "Mesh:can't get positions on mesh,isReadable must be true.";
                this._getVerticeElementData(e, ce.MESH_POSITION0);
            }
        }, {
            key: "setPositions",
            value: function setPositions(e) {
                if (!this._isReadable) throw "Mesh:setPosition() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(e, ce.MESH_POSITION0), this._needUpdateBounds = !0;
            }
        }, {
            key: "getColors",
            value: function getColors(e) {
                if (!this._isReadable) throw "Mesh:can't get colors on mesh,isReadable must be true.";
                this._getVerticeElementData(e, ce.MESH_COLOR0);
            }
        }, {
            key: "setColors",
            value: function setColors(e) {
                if (!this._isReadable) throw "Mesh:setColors() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(e, ce.MESH_COLOR0);
            }
        }, {
            key: "getUVs",
            value: function getUVs(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                if (!this._isReadable) throw "Mesh:can't get uvs on mesh,isReadable must be true.";
                switch (t) {
                    case 0:
                        this._getVerticeElementData(e, ce.MESH_TEXTURECOORDINATE0);
                        break;

                    case 1:
                        this._getVerticeElementData(e, ce.MESH_TEXTURECOORDINATE1);
                        break;

                    default:
                        throw "Mesh:Invalid channel.";
                }
            }
        }, {
            key: "setUVs",
            value: function setUVs(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                if (!this._isReadable) throw "Mesh:setUVs() need isReadable must be true or use setVertices().";
                switch (t) {
                    case 0:
                        this._setVerticeElementData(e, ce.MESH_TEXTURECOORDINATE0);
                        break;

                    case 1:
                        this._setVerticeElementData(e, ce.MESH_TEXTURECOORDINATE1);
                        break;

                    default:
                        throw "Mesh:Invalid channel.";
                }
            }
        }, {
            key: "getNormals",
            value: function getNormals(e) {
                if (!this._isReadable) throw "Mesh:can't get colors on mesh,isReadable must be true.";
                this._getVerticeElementData(e, ce.MESH_NORMAL0);
            }
        }, {
            key: "setNormals",
            value: function setNormals(e) {
                if (!this._isReadable) throw "Mesh:setNormals() need must be true or use setVertices().";
                this._setVerticeElementData(e, ce.MESH_NORMAL0);
            }
        }, {
            key: "getTangents",
            value: function getTangents(e) {
                if (!this._isReadable) throw "Mesh:can't get colors on mesh,isReadable must be true.";
                this._getVerticeElementData(e, ce.MESH_TANGENT0);
            }
        }, {
            key: "setTangents",
            value: function setTangents(e) {
                if (!this._isReadable) throw "Mesh:setTangents() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(e, ce.MESH_TANGENT0);
            }
        }, {
            key: "getBoneWeights",
            value: function getBoneWeights(e) {
                if (!this._isReadable) throw "Mesh:can't get boneWeights on mesh,isReadable must be true.";
                this._getVerticeElementData(e, ce.MESH_BLENDWEIGHT0);
            }
        }, {
            key: "setBoneWeights",
            value: function setBoneWeights(e) {
                if (!this._isReadable) throw "Mesh:setBoneWeights() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(e, ce.MESH_BLENDWEIGHT0);
            }
        }, {
            key: "getBoneIndices",
            value: function getBoneIndices(e) {
                if (!this._isReadable) throw "Mesh:can't get boneIndices on mesh,isReadable must be true.";
                this._getVerticeElementData(e, ce.MESH_BLENDINDICES0);
            }
        }, {
            key: "setBoneIndices",
            value: function setBoneIndices(e) {
                if (!this._isReadable) throw "Mesh:setBoneIndices() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(e, ce.MESH_BLENDINDICES0);
            }
        }, {
            key: "markAsUnreadbale",
            value: function markAsUnreadbale() {
                this._uploadVerticesData(), this._vertexBuffer.markAsUnreadbale(), this._isReadable = !1;
            }
        }, {
            key: "getVertexDeclaration",
            value: function getVertexDeclaration() {
                return this._vertexBuffer._vertexDeclaration;
            }
        }, {
            key: "getVertices",
            value: function getVertices() {
                if (this._isReadable) return this._vertexBuffer.getUint8Data().buffer.slice(0);
                throw "Mesh:can't get vertices on mesh,isReadable must be true.";
            }
        }, {
            key: "setVertices",
            value: function setVertices(e) {
                this._vertexBuffer.setData(e), this._needUpdateBounds = !0;
            }
        }, {
            key: "getIndices",
            value: function getIndices() {
                if (this._isReadable) return this._indexBuffer.getData().slice();
                throw "Mesh:can't get indices on subMesh,mesh's isReadable must be true.";
            }
        }, {
            key: "setIndices",
            value: function setIndices(r) {
                var i;
                r instanceof Uint32Array ? i = e.IndexFormat.UInt32 : r instanceof Uint16Array ? i = e.IndexFormat.UInt16 : r instanceof Uint8Array && (i = e.IndexFormat.UInt8);
                var a = this._indexBuffer;
                this._indexFormat === i && a.indexCount === r.length || (a.destroy(), this._indexBuffer = a = new Ye(i, r.length, t.LayaGL.instance.STATIC_DRAW, this._isReadable)),
                    a.setData(r), this._indexFormat = i;
            }
        }, {
            key: "calculateBounds",
            value: function calculateBounds() {
                if (!this._isReadable) throw "Mesh:can't calculate bounds on subMesh,mesh's isReadable must be true.";
                if (this._needUpdateBounds) {
                    var e = this._tempVector30,
                        t = this._tempVector31;
                    e.x = e.y = e.z = Number.MAX_VALUE, t.x = t.y = t.z = -Number.MAX_VALUE;
                    for (var r = this._vertexBuffer, i = this._getPositionElement(r), a = r.getFloat32Data(), n = r.vertexDeclaration.vertexStride / 4, s = i._offset / 4, o = 0, l = a.length; o < l; o += n) {
                        var _ = o + s,
                            h = a[_],
                            c = a[_ + 1],
                            d = a[_ + 2];
                        e.x = Math.min(e.x, h), e.y = Math.min(e.y, c), e.z = Math.min(e.z, d), t.x = Math.max(t.x, h),
                            t.y = Math.max(t.y, c), t.z = Math.max(t.z, d);
                    }
                    this._bounds.setMin(e), this._bounds.setMax(t), this._needUpdateBounds = !1;
                }
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(t) {
                var r = t,
                    i = this._vertexBuffer,
                    a = new be(i._byteLength, i.bufferUsage, i.canRead);
                a.vertexDeclaration = i.vertexDeclaration, a.setData(i.getUint8Data().slice().buffer),
                    r._vertexBuffer = a, r._vertexCount = this._vertexCount;
                var n, s = this._indexBuffer,
                    o = new Ye(e.IndexFormat.UInt16, s.indexCount, s.bufferUsage, s.canRead);
                o.setData(s.getData().slice()), r._indexBuffer = o, r._setBuffer(r._vertexBuffer, o),
                    r._setCPUMemory(this.cpuMemory), r._setGPUMemory(this.gpuMemory);
                var l = this._boneNames,
                    _ = r._boneNames = [];
                for (n = 0; n < l.length; n++) {
                    _[n] = l[n];
                }
                var h = this._inverseBindPoses,
                    c = r._inverseBindPoses = [];
                for (n = 0; n < h.length; n++) {
                    c[n] = h[n];
                }
                var d = this._skinnedMatrixCaches.length;
                for (r._skinnedMatrixCaches.length = d, n = 0; n < d; n++) {
                    var u = this._skinnedMatrixCaches[n];
                    r._skinnedMatrixCaches[n] = new ii(u.subMeshIndex, u.batchIndex, u.batchBoneIndex);
                }
                for (n = 0; n < this.subMeshCount; n++) {
                    var m = this._subMeshes[n],
                        f = m._subIndexBufferStart,
                        E = m._subIndexBufferCount,
                        T = m._boneIndicesList,
                        p = new ri(r);
                    p._subIndexBufferStart.length = f.length, p._subIndexBufferCount.length = E.length,
                        p._boneIndicesList.length = T.length;
                    for (var g = 0; g < f.length; g++) {
                        p._subIndexBufferStart[g] = f[g];
                    }
                    for (g = 0; g < E.length; g++) {
                        p._subIndexBufferCount[g] = E[g];
                    }
                    for (g = 0; g < T.length; g++) {
                        p._boneIndicesList[g] = new Uint16Array(T[g]);
                    }
                    p._indexBuffer = o, p._indexStart = m._indexStart, p._indexCount = m._indexCount,
                        p._indices = new Uint16Array(o.getData().buffer, 2 * m._indexStart, m._indexCount);
                    var S = r._vertexBuffer;
                    p._vertexBuffer = S, r._subMeshes.push(p);
                }
                r._setSubMeshes(r._subMeshes);
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new ai();
                return this.cloneTo(e), e;
            }
        }, {
            key: "inverseAbsoluteBindPoses",
            get: function get() {
                return this._inverseBindPoses;
            }
        }, {
            key: "vertexCount",
            get: function get() {
                return this._vertexCount;
            }
        }, {
            key: "indexCount",
            get: function get() {
                return this._indexBuffer.indexCount;
            }
        }, {
            key: "subMeshCount",
            get: function get() {
                return this._subMeshes.length;
            }
        }, {
            key: "bounds",
            get: function get() {
                return this._bounds;
            },
            set: function set(e) {
                this._bounds !== e && e.cloneTo(this._bounds);
            }
        }, {
            key: "indexFormat",
            get: function get() {
                return this._indexFormat;
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                var e = x._bullet;
                e && (ai._nativeTempVector30 = e.btVector3_create(0, 0, 0), ai._nativeTempVector31 = e.btVector3_create(0, 0, 0),
                    ai._nativeTempVector32 = e.btVector3_create(0, 0, 0));
            }
        }, {
            key: "load",
            value: function load(e, r) {
                t.ILaya.loader.create(e, r, null, ai.MESH);
            }
        }]);
        return ai;
    }(t.Resource);
    ai.MESH = "MESH";
    var ni = /* */ function() {
        function ni() {
            _classCallCheck(this, ni);
        }
        _createClass(ni, null, [{
            key: "__init__",
            value: function __init__() {}
        }, {
            key: "_createMesh",
            value: function _createMesh(r, i, a) {
                var n = t.LayaGL.instance,
                    s = new ai(),
                    o = new ri(s),
                    l = new be(4 * i.length, n.STATIC_DRAW, !0);
                l.vertexDeclaration = r, l.setData(i.buffer), s._vertexBuffer = l, s._vertexCount = l._byteLength / r.vertexStride;
                var _ = new Ye(e.IndexFormat.UInt16, a.length, n.STATIC_DRAW, !0);
                _.setData(a), s._indexBuffer = _, s._setBuffer(l, _), o._vertexBuffer = l, o._indexBuffer = _,
                    o._setIndexRange(0, _.indexCount);
                var h = o._subIndexBufferStart,
                    c = o._subIndexBufferCount,
                    d = o._boneIndicesList;
                h.length = 1, c.length = 1, d.length = 1, h[0] = 0, c[0] = _.indexCount;
                var u = [];
                u.push(o), s._setSubMeshes(u), s.calculateBounds();
                var m = l._byteLength + _._byteLength;
                return s._setCPUMemory(m), s._setGPUMemory(m), s;
            }
        }, {
            key: "createBox",
            value: function createBox() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
                var i = ce.getVertexDeclaration("POSITION,NORMAL,UV"),
                    a = e / 2,
                    n = t / 2,
                    s = r / 2,
                    o = new Float32Array([-a, n, -s, 0, 1, 0, 0, 0, a, n, -s, 0, 1, 0, 1, 0, a, n, s, 0, 1, 0, 1, 1, -a, n, s, 0, 1, 0, 0, 1, -a, -n, -s, 0, -1, 0, 0, 1, a, -n, -s, 0, -1, 0, 1, 1, a, -n, s, 0, -1, 0, 1, 0, -a, -n, s, 0, -1, 0, 0, 0, -a, n, -s, -1, 0, 0, 0, 0, -a, n, s, -1, 0, 0, 1, 0, -a, -n, s, -1, 0, 0, 1, 1, -a, -n, -s, -1, 0, 0, 0, 1, a, n, -s, 1, 0, 0, 1, 0, a, n, s, 1, 0, 0, 0, 0, a, -n, s, 1, 0, 0, 0, 1, a, -n, -s, 1, 0, 0, 1, 1, -a, n, s, 0, 0, 1, 0, 0, a, n, s, 0, 0, 1, 1, 0, a, -n, s, 0, 0, 1, 1, 1, -a, -n, s, 0, 0, 1, 0, 1, -a, n, -s, 0, 0, -1, 1, 0, a, n, -s, 0, 0, -1, 0, 0, a, -n, -s, 0, 0, -1, 0, 1, -a, -n, -s, 0, 0, -1, 1, 1]),
                    l = new Uint16Array([0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 8, 9, 10, 10, 11, 8, 12, 15, 14, 14, 13, 12, 16, 17, 18, 18, 19, 16, 20, 23, 22, 22, 21, 20]);
                return ni._createMesh(i, o, l);
            }
        }, {
            key: "createCapsule",
            value: function createCapsule() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .5;
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 32;
                var a, n, s = (r + 1) * (i + 1) * 2 + 2 * (i + 1),
                    o = 3 * r * (i + 1) * 2 * 2 + 2 * i * 3,
                    l = ce.getVertexDeclaration("POSITION,NORMAL,UV"),
                    _ = l.vertexStride / 4,
                    h = new Float32Array(s * _),
                    c = new Uint16Array(o),
                    d = Math.PI / 2 / r,
                    u = 2 * Math.PI / i,
                    m = t / 2 - e,
                    f = 0,
                    E = 0,
                    T = 0,
                    p = 0,
                    g = 0,
                    S = 0;
                for (a = 0; a <= r; a++) {
                    for (n = 0; n <= i; n++) {
                        f = e * Math.cos(a * d) * Math.cos(n * u + Math.PI), E = e * Math.sin(a * d), T = e * Math.cos(a * d) * Math.sin(n * u + Math.PI),
                            h[p++] = f, h[p++] = E + m, h[p++] = T, h[p++] = f, h[p++] = E, h[p++] = T, h[p++] = 1 - n / i,
                            h[p++] = (1 - a / r) * (Math.PI * e / 2 / (t + Math.PI * e)), a < r && (c[g++] = a * (i + 1) + n + (i + 1),
                                c[g++] = a * (i + 1) + n, c[g++] = a * (i + 1) + n + 1, c[g++] = a * (i + 1) + n + i,
                                c[g++] = a * (i + 1) + n, c[g++] = a * (i + 1) + n + (i + 1));
                    }
                }
                for (S += (r + 1) * (i + 1), a = 0; a <= r; a++) {
                    for (n = 0; n <= i; n++) {
                        f = e * Math.cos(a * d) * Math.cos(n * u + Math.PI), E = e * Math.sin(-a * d), T = e * Math.cos(a * d) * Math.sin(n * u + Math.PI),
                            h[p++] = f, h[p++] = E - m, h[p++] = T, h[p++] = f, h[p++] = E, h[p++] = T, h[p++] = 1 - n / i,
                            h[p++] = (a / r * (Math.PI * e / 2) + (t + Math.PI * e / 2)) / (t + Math.PI * e),
                            a < r && (c[g++] = S + a * (i + 1) + n, c[g++] = S + a * (i + 1) + n + (i + 1),
                                c[g++] = S + a * (i + 1) + n + 1, c[g++] = S + a * (i + 1) + n, c[g++] = S + a * (i + 1) + n + i,
                                c[g++] = S + a * (i + 1) + n + (i + 1));
                    }
                }
                for (S += (r + 1) * (i + 1), n = 0; n <= i; n++) {
                    f = e * Math.cos(n * u + Math.PI), E = m, T = e * Math.sin(n * u + Math.PI), h[p++] = f,
                        h[p + 8 * (i + 1) - 1] = f, h[p++] = E, h[p + 8 * (i + 1) - 1] = -E, h[p++] = T,
                        h[p + 8 * (i + 1) - 1] = T, h[p++] = f, h[p + 8 * (i + 1) - 1] = f, h[p++] = 0,
                        h[p + 8 * (i + 1) - 1] = 0, h[p++] = T, h[p + 8 * (i + 1) - 1] = T, h[p++] = 1 - 1 * n / i,
                        h[p + 8 * (i + 1) - 1] = 1 - 1 * n / i, h[p++] = Math.PI * e / 2 / (t + Math.PI * e),
                        h[p + 8 * (i + 1) - 1] = (Math.PI * e / 2 + t) / (t + Math.PI * e);
                }
                for (n = 0; n < i; n++) {
                    c[g++] = n + S + (i + 1), c[g++] = n + S + 1, c[g++] = n + S, c[g++] = n + S + (i + 1),
                        c[g++] = n + S + (i + 1) + 1, c[g++] = n + S + 1;
                }
                return S += 2 * (i + 1), ni._createMesh(l, h, c);
            }
        }, {
            key: "createCone",
            value: function createCone() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .5;
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;
                for (var i, a = r + 1 + 1 + 2 * (r + 1), s = 6 * r + 3 * r, o = ce.getVertexDeclaration("POSITION,NORMAL,UV"), l = o.vertexStride / 4, _ = new Float32Array(a * l), h = new Uint16Array(s), c = 2 * Math.PI / r, d = t / 2, u = 0, m = 0, E = 0, T = 0, p = 0, g = new n(), S = new n(0, -1, 0), R = new n(0, d, 0), v = new n(), x = new n(), I = new f(), A = new n(), M = 0, D = 0, L = 0; L <= r; L++) {
                    u = L * c, E = Math.cos(u + Math.PI) * e, T = d, p = Math.sin(u + Math.PI) * e,
                        _[M++] = 0, _[M + 8 * (r + 1) - 1] = E, _[M++] = T, _[M + 8 * (r + 1) - 1] = -T,
                        _[M++] = 0, _[M + 8 * (r + 1) - 1] = p, g.x = E, g.y = 0, g.z = p, v.x = E, v.y = -T,
                        v.z = p, n.subtract(v, R, x), n.normalize(x, x), i = Math.acos(n.dot(S, x)), n.cross(S, x, A),
                        n.normalize(A, A), f.createFromAxisAngle(A, i, I), n.normalize(g, g), n.transformQuat(g, I, g),
                        n.normalize(g, g), _[M++] = g.x, _[M + 8 * (r + 1) - 1] = g.x, _[M++] = g.y, _[M + 8 * (r + 1) - 1] = g.y,
                        _[M++] = g.z, _[M + 8 * (r + 1) - 1] = g.z, _[M++] = 1 - 1 * L / r, _[M + 8 * (r + 1) - 1] = 1 - 1 * L / r,
                        _[M++] = 0, _[M + 8 * (r + 1) - 1] = 1;
                }
                M += 8 * (r + 1);
                for (var y = 0; y < r; y++) {
                    h[D++] = y + m + (r + 1), h[D++] = y + m + 1, h[D++] = y + m, h[D++] = y + m + (r + 1),
                        h[D++] = y + m + (r + 1) + 1, h[D++] = y + m + 1;
                }
                m += 2 * (r + 1);
                for (var C = 0; C <= r; C++) {
                    0 === C && (_[M++] = 0, _[M++] = -d, _[M++] = 0, _[M++] = 0, _[M++] = -1, _[M++] = 0,
                            _[M++] = .5, _[M++] = .5), u = C * c, E = Math.cos(u + Math.PI) * e, T = -d, p = Math.sin(u + Math.PI) * e,
                        _[M++] = E, _[M++] = T, _[M++] = p, _[M++] = 0, _[M++] = -1, _[M++] = 0, _[M++] = .5 + .5 * Math.cos(u),
                        _[M++] = .5 + .5 * Math.sin(u);
                }
                for (var O = 0; O < r; O++) {
                    h[D++] = 0 + m, h[D++] = O + 2 + m, h[D++] = O + 1 + m;
                }
                return m += r + 1 + 1, ni._createMesh(o, _, h);
            }
        }, {
            key: "createCylinder",
            value: function createCylinder() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .5;
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;
                for (var i = r + 1 + 1 + 2 * (r + 1) + (r + 1 + 1), a = 3 * r + 6 * r + 3 * r, n = ce.getVertexDeclaration("POSITION,NORMAL,UV"), s = n.vertexStride / 4, o = new Float32Array(i * s), l = new Uint16Array(a), _ = 2 * Math.PI / r, h = t / 2, c = 0, d = 0, u = 0, m = 0, f = 0, E = 0, T = 0, p = 0; p <= r; p++) {
                    0 === p && (o[E++] = 0, o[E++] = h, o[E++] = 0, o[E++] = 0, o[E++] = 1, o[E++] = 0,
                            o[E++] = .5, o[E++] = .5), c = p * _, u = Math.cos(c) * e, m = h, f = Math.sin(c) * e,
                        o[E++] = u, o[E++] = m, o[E++] = f, o[E++] = 0, o[E++] = 1, o[E++] = 0, o[E++] = .5 + .5 * Math.cos(c),
                        o[E++] = .5 + .5 * Math.sin(c);
                }
                for (var g = 0; g < r; g++) {
                    l[T++] = 0, l[T++] = g + 1, l[T++] = g + 2;
                }
                d += r + 1 + 1;
                for (var S = 0; S <= r; S++) {
                    c = S * _, u = Math.cos(c + Math.PI) * e, m = h, f = Math.sin(c + Math.PI) * e,
                        o[E++] = u, o[E + 8 * (r + 1) - 1] = u, o[E++] = m, o[E + 8 * (r + 1) - 1] = -m,
                        o[E++] = f, o[E + 8 * (r + 1) - 1] = f, o[E++] = u, o[E + 8 * (r + 1) - 1] = u,
                        o[E++] = 0, o[E + 8 * (r + 1) - 1] = 0, o[E++] = f, o[E + 8 * (r + 1) - 1] = f,
                        o[E++] = 1 - 1 * S / r, o[E + 8 * (r + 1) - 1] = 1 - 1 * S / r, o[E++] = 0, o[E + 8 * (r + 1) - 1] = 1;
                }
                E += 8 * (r + 1);
                for (var R = 0; R < r; R++) {
                    l[T++] = R + d + (r + 1), l[T++] = R + d + 1, l[T++] = R + d, l[T++] = R + d + (r + 1),
                        l[T++] = R + d + (r + 1) + 1, l[T++] = R + d + 1;
                }
                d += 2 * (r + 1);
                for (var v = 0; v <= r; v++) {
                    0 === v && (o[E++] = 0, o[E++] = -h, o[E++] = 0, o[E++] = 0, o[E++] = -1, o[E++] = 0,
                            o[E++] = .5, o[E++] = .5), c = v * _, u = Math.cos(c + Math.PI) * e, m = -h, f = Math.sin(c + Math.PI) * e,
                        o[E++] = u, o[E++] = m, o[E++] = f, o[E++] = 0, o[E++] = -1, o[E++] = 0, o[E++] = .5 + .5 * Math.cos(c),
                        o[E++] = .5 + .5 * Math.sin(c);
                }
                for (var x = 0; x < r; x++) {
                    l[T++] = 0 + d, l[T++] = x + 2 + d, l[T++] = x + 1 + d;
                }
                return d += r + 1 + 1, ni._createMesh(n, o, l);
            }
        }, {
            key: "createPlane",
            value: function createPlane() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
                for (var a = (r + 1) * (i + 1), n = new Uint16Array(r * i * 2 * 3), s = ce.getVertexDeclaration("POSITION,NORMAL,UV"), o = s.vertexStride / 4, l = new Float32Array(a * o), _ = e / 2, h = t / 2, c = e / r, d = t / i, u = 0, m = 0; m <= i; m++) {
                    for (var f = 0; f <= r; f++) {
                        l[u++] = f * c - _, l[u++] = 0, l[u++] = m * d - h, l[u++] = 0, l[u++] = 1, l[u++] = 0,
                            l[u++] = 1 * f / r, l[u++] = 1 * m / i;
                    }
                }
                var E = 0;
                for (m = 0; m < i; m++) {
                    for (f = 0; f < r; f++) {
                        n[E++] = (m + 1) * (r + 1) + f, n[E++] = m * (r + 1) + f, n[E++] = (m + 1) * (r + 1) + f + 1,
                            n[E++] = m * (r + 1) + f, n[E++] = m * (r + 1) + f + 1, n[E++] = (m + 1) * (r + 1) + f + 1;
                    }
                }
                return ni._createMesh(s, l, n);
            }
        }, {
            key: "createQuad",
            value: function createQuad() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
                var r = ce.getVertexDeclaration("POSITION,NORMAL,UV"),
                    i = e / 2,
                    a = t / 2,
                    n = new Float32Array([-i, a, 0, 0, 0, 1, 0, 0, i, a, 0, 0, 0, 1, 1, 0, -i, -a, 0, 0, 0, 1, 0, 1, i, -a, 0, 0, 0, 1, 1, 1]),
                    s = new Uint16Array([0, 1, 2, 3, 2, 1]);
                return ni._createMesh(r, n, s);
            }
        }, {
            key: "createSphere",
            value: function createSphere() {
                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .5;
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;
                var i = (t + 1) * (r + 1),
                    a = 3 * t * (r + 1) * 2,
                    n = new Uint16Array(a),
                    s = ce.getVertexDeclaration("POSITION,NORMAL,UV"),
                    o = s.vertexStride / 4,
                    l = new Float32Array(i * o),
                    _ = Math.PI / t,
                    h = 2 * Math.PI / r,
                    c = 0;
                i = 0, a = 0;
                for (var d = 0; d < t + 1; d++) {
                    for (var u = Math.sin(d * _), m = Math.cos(d * _), f = 0; f < r + 1; f++) {
                        var E = u * Math.sin(f * h + 1 * Math.PI / 2),
                            T = u * Math.cos(f * h + 1 * Math.PI / 2);
                        l[i + 0] = E * e, l[i + 1] = m * e, l[i + 2] = T * e, l[i + 3] = E, l[i + 4] = m,
                            l[i + 5] = T, l[i + 6] = f / r, l[i + 7] = d / t, i += o, d != t - 1 && (n[a++] = c + (r + 1),
                                n[a++] = c, n[a++] = c + 1, n[a++] = c + r, n[a++] = c, n[a++] = c + (r + 1), c++);
                    }
                }
                return ni._createMesh(s, l, n);
            }
        }]);
        return ni;
    }();
    var si = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTex;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_FragColor = texture2D(u_MainTex, v_Texcoord0);\r\n}\r\n\r\n",
        oi = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nuniform vec4 u_OffsetScale;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\t\r\n\tgl_Position = vec4(u_OffsetScale.x*2.0-1.0+(a_PositionTexcoord.x+1.0)*u_OffsetScale.z,(1.0-((u_OffsetScale.y*2.0-1.0+(-a_PositionTexcoord.y+1.0)*u_OffsetScale.w)+1.0)/2.0)*2.0-1.0, 0.0, 1.0);\t\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}',
        li = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  2.0 * u_AlbedoColor;\r\n\t#ifdef COLOR\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t#ifdef MAINTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}\r\n\r\n",
        _i = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec4 a_Color;\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\t\t\r\n\t#ifdef COLOR\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
        hi = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_Normal;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n#endif\r\n\r\n#include "ShadowHelper.glsl"\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\nvarying float v_posViewZ;\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\nuniform sampler2D u_SplatAlphaTexture;\r\n\r\nuniform sampler2D u_DiffuseTexture1;\r\nuniform sampler2D u_DiffuseTexture2;\r\nuniform sampler2D u_DiffuseTexture3;\r\nuniform sampler2D u_DiffuseTexture4;\r\nuniform sampler2D u_DiffuseTexture5;\r\n\r\nuniform vec4 u_DiffuseScaleOffset1;\r\nuniform vec4 u_DiffuseScaleOffset2;\r\nuniform vec4 u_DiffuseScaleOffset3;\r\nuniform vec4 u_DiffuseScaleOffset4;\r\nuniform vec4 u_DiffuseScaleOffset5;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform sampler2D u_LightMap;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 splatAlpha = vec4(1.0);\r\n\t#ifdef ExtendTerrain_DETAIL_NUM1\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r;\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM2\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r + color2.xyz * (1.0 - splatAlpha.r);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM3\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * (1.0 - splatAlpha.r - splatAlpha.g);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM4\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM5\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tvec4 color5 = texture2D(u_DiffuseTexture5, v_Texcoord0 * u_DiffuseScaleOffset5.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * splatAlpha.a + color5.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b - splatAlpha.a);\r\n\t#endif\r\n\t\tgl_FragColor.w = splatAlpha.a;\r\n\t\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 normal = v_Normal;\r\n\t\tvec3 dif, spe;\r\n\t#endif\r\n\r\n\tvec3 diffuse = vec3(0.0);\r\n\tvec3 specular= vec3(0.0);\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\t\tvec3 toEye;\r\n\t\t#ifdef FOG\r\n\t\t\ttoEye=u_CameraPos-v_PositionWorld;\r\n\t\t\tfloat toEyeLength=length(toEye);\r\n\t\t\ttoEye/=toEyeLength;\r\n\t\t#else\r\n\t\t\ttoEye=normalize(u_CameraPos-v_PositionWorld);\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tLayaAirBlinnPhongDiectionLight(vec3(0.0),1.0,normal,vec3(1.0),toEye,u_DirectionLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,u_PointLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,u_SpotLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\tLayaAirBlinnPhongDiectionLight(vec3(0.0),1.0,normal,vec3(1.0),toEye,directionLight,dif,spe);\r\n\t\t\t\tdiffuse+=dif;\r\n\t\t\t\tspecular+=spe;\r\n\t\t\t}\r\n\t\t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,pointLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye\t,spotLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\nvec3 globalDiffuse = u_AmbientColor;\r\n#ifdef LIGHTMAP\r\n\tglobalDiffuse += decodeHDR(texture2D(u_LightMap, v_LightMapUV),5.0);\r\n#endif\r\n\r\n#ifdef RECEIVESHADOW\r\n\tfloat shadowValue = 1.0;\r\n\t#ifdef SHADOWMAP_PSSM3\r\n\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM2\r\n\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t#endif \r\n\t#ifdef SHADOWMAP_PSSM1\r\n\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t#endif\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse) * shadowValue, gl_FragColor.a);\r\n#else\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse), gl_FragColor.a);\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef RECEIVESHADOW\r\n\t\tgl_FragColor.rgb += specular * shadowValue;\r\n\t#else\r\n\t\tgl_FragColor.rgb += specular;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef FOG\r\n\tfloat lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\r\n\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n#endif\r\n}\r\n\r\n\r\n\r\n\r\n\r\n',
        ci = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec2 a_Texcoord0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\r\n\tattribute vec3 a_Normal;\r\n\tvarying vec3 v_Normal;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\r\n\tuniform mat4 u_WorldMat;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n#endif\r\n\r\n#ifdef RECEIVESHADOW\r\n\tvarying float v_posViewZ;\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n  \r\n\tv_Texcoord0 = a_Texcoord0;\r\n  \r\n\t#ifdef LIGHTMAP\r\n\t\tv_LightMapUV = vec2(a_Texcoord0.x, 1.0 - a_Texcoord0.y) * u_LightmapScaleOffset.xy + u_LightmapScaleOffset.zw;\r\n\t\tv_LightMapUV.y = 1.0 - v_LightMapUV.y;\r\n\t#endif\r\n  \r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tv_Normal = a_Normal;\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\r\n\t\tv_PositionWorld=(u_WorldMat*a_Position).xyz;\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
        di = 'struct LayaGIInput\r\n{\r\n\tvec2 lightmapUV;\r\n};\r\n\r\n#define LAYA_SPECCUBE_LOD_STEPS 6.0\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\n#if defined(GI_AMBIENT_SH)\r\n\tuniform vec4 u_AmbientSHAr;\r\n\tuniform vec4 u_AmbientSHAg;\r\n\tuniform vec4 u_AmbientSHAb;\r\n\tuniform vec4 u_AmbientSHBr;\r\n\tuniform vec4 u_AmbientSHBg;\r\n\tuniform vec4 u_AmbientSHBb;\r\n\tuniform vec4 u_AmbientSHC;\r\n#endif\r\n\r\nuniform samplerCube u_ReflectTexture;\r\nuniform vec4 u_ReflectCubeHDRParams;\r\n\r\n\r\n#ifdef GI_AMBIENT_SH\r\n\tmediump vec3 shEvalLinearL0L1(mediump vec4 normal)\r\n\t{\r\n\t\tmediump vec3 x;\r\n\t\t// Linear (L1) + constant (L0) polynomial terms\r\n\t\tx.r = dot(u_AmbientSHAr, normal);\r\n\t\tx.g = dot(u_AmbientSHAg, normal);\r\n\t\tx.b = dot(u_AmbientSHAb, normal);\r\n\t\treturn x;\r\n\t}\r\n\r\n\tmediump vec3 shEvalLinearL2(mediump vec4 normal)\r\n\t{\r\n\t\tmediump vec3 x1,x2;\r\n\t\t// 4 of the quadratic (L2) polynomials\r\n\t\tmediump vec4 vB = normal.xyzz * normal.yzzx;\r\n\t\tx1.r = dot(u_AmbientSHBr, vB);\r\n\t\tx1.g = dot(u_AmbientSHBg, vB);\r\n\t\tx1.b = dot(u_AmbientSHBb, vB);\r\n\r\n\t\t// Final (5th) quadratic (L2) polynomial\r\n\t\tmediump float vC = normal.x*normal.x - normal.y*normal.y;\r\n\t\tx2 = u_AmbientSHC.rgb * vC;\r\n\r\n\t\treturn x1 + x2;\r\n\t}\r\n\t\r\n\tmediump vec3 shadeSHPerPixel(mediump vec3 normal)\r\n\t{\r\n\t\tmediump vec3 ambientContrib;\r\n\t\tmediump vec4 normalV4=vec4(-normal.x,normal.yz, 1.0);//Note:SH Data is left-hand,so x need inverse\r\n\t\tambientContrib = shEvalLinearL0L1(normalV4);\r\n\t\tambientContrib += shEvalLinearL2(normalV4);\r\n\t\tmediump vec3 ambient = max(vec3(0.0), ambientContrib);\r\n\t\tambient = layaLinearToGammaSpace(ambient);\r\n\t\treturn ambient;\r\n\t}\r\n#endif\r\n\r\n\r\nvec3 layaGIBase(LayaGIInput giInput,mediump float occlusion, mediump vec3 normalWorld)\r\n{\r\n\tvec3 indirectDiffuse;\r\n\t#ifdef LIGHTMAP\t\r\n\t\tindirectDiffuse =decodeHDR(texture2D(u_LightMap, giInput.lightmapUV),5.0);\r\n\t#else\r\n\t\t#ifdef GI_AMBIENT_SH\r\n\t\t\tindirectDiffuse = shadeSHPerPixel(normalWorld);\r\n\t\t#else\r\n\t\t\tindirectDiffuse = u_AmbientColor;//already in gamma space\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tindirectDiffuse*=occlusion;\r\n\treturn indirectDiffuse;\r\n}\r\n\r\nmediump vec3 layaGlossyEnvironment(mediump vec4 glossIn)\r\n{\r\n\tmediump float perceptualRoughness = glossIn.a;\r\n\r\n\t// use approximation to solve,below is more reasonable,but maybe slow. \r\n\t// float m = perceptualRoughnessToRoughness(perceptualRoughness); // m is the real roughness parameter\r\n    // const float fEps = 1.192092896e-07F;        // smallest such that 1.0+FLT_EPSILON != 1.0  (+1e-4h is NOT good here. is visibly very wrong)\r\n    // float n =  (2.0/max(fEps, m*m))-2.0;        // remap to spec power. See eq. 21 in --\x3e https://dl.dropboxusercontent.com/u/55891920/papers/mm_brdf.pdf\r\n    // n /= 4;                                     // remap from n_dot_h formulatino to n_dot_r. See section "Pre-convolved Cube Maps vs Path Tracers" --\x3e https://s3.amazonaws.com/docs.knaldtech.com/knald/1.0.0/lys_power_drops.html\r\n    // perceptualRoughness = pow( 2/(n+2), 0.25);  // remap back to square root of real roughness (0.25 include both the sqrt root of the conversion and sqrt for going from roughness to perceptualRoughness)\r\n\tperceptualRoughness = perceptualRoughness * (1.7 - 0.7*perceptualRoughness);//just a approximation,but fast.\r\n \r\n\tmediump float mip = perceptualRoughness * LAYA_SPECCUBE_LOD_STEPS;\r\n\tmediump vec3 uvw = glossIn.rgb;\r\n\tuvw.x=-uvw.x;//Note:reflectCube is left-hand,so x need inverse\r\n\tmediump vec4 rgbm=textureCubeLodEXT(u_ReflectTexture,uvw,mip);\r\n\treturn decodeHDR(rgbm,u_ReflectCubeHDRParams.x);\r\n}\r\n\r\nmediump vec3 layaGIIndirectSpecular(LayaGIInput giInput,mediump float occlusion, vec4 glossIn)\r\n{\r\n\tmediump vec3 specular = layaGlossyEnvironment(glossIn);\r\n\treturn specular * occlusion;\r\n}\r\n\r\n\r\nLayaGI layaGlobalIllumination(LayaGIInput giInput,mediump float occlusion, mediump vec3 normalWorld,mediump vec4 uvwRoughness)\r\n{\r\n\tLayaGI gi;\r\n\tgi.diffuse = layaGIBase(giInput,occlusion, normalWorld);\r\n\tgi.specular = layaGIIndirectSpecular(giInput,occlusion, uvwRoughness);\r\n\treturn gi;\r\n}\r\n\r\n\r\n\r\n',
        ui = "struct DirectionLight {\r\n\tvec3 color;\r\n\tvec3 direction;\r\n};\r\n\r\nstruct PointLight {\r\n\tvec3 color;\r\n\tvec3 position;\r\n\tfloat range;\r\n};\r\n\r\nstruct SpotLight {\r\n\tvec3 color;\r\n\tvec3 position;\r\n\tfloat range;\r\n\tvec3 direction;\r\n\tfloat spot;\r\n};\r\n\r\nstruct LayaGI{\r\n\tvec3 diffuse;\r\n\tvec3 specular;\r\n};\r\n\r\nstruct LayaLight{\r\n\tvec3 color;\r\n\tvec3 dir;\r\n};\r\n\r\nconst int c_ClusterBufferWidth = CLUSTER_X_COUNT*CLUSTER_Y_COUNT;\r\nconst int c_ClusterBufferHeight = CLUSTER_Z_COUNT*(1+int(ceil(float(MAX_LIGHT_COUNT_PER_CLUSTER)/4.0)));\r\nconst int c_ClusterBufferFloatWidth = c_ClusterBufferWidth*4;\r\n\r\nivec4 getClusterInfo(sampler2D clusterBuffer,mat4 viewMatrix,vec4 viewport,vec3 position,vec4 fragCoord,vec4 projectParams)\r\n{\r\n\tvec3 viewPos = vec3(viewMatrix*vec4(position, 1.0)); //position in viewspace\r\n\r\n\tint clusterXIndex = int(floor(fragCoord.x/ (float(viewport.z)/float(CLUSTER_X_COUNT))));\r\n    int clusterYIndex = int(floor((viewport.w * (projectParams.z <0.0? 0.0 : 1.0) - fragCoord.y * projectParams.z)/ (float(viewport.w)/float(CLUSTER_Y_COUNT))));//Maybe Flipped ProjectMatrix\r\n\tfloat zSliceParam =float(CLUSTER_Z_COUNT)/log2(projectParams.y / projectParams.x);\r\n \tint clusterZIndex = int(floor(log2(-viewPos.z) * zSliceParam- log2(projectParams.x) * zSliceParam));//projectParams x:cameraNear y:cameraFar\r\n\r\n\tvec2 uv= vec2((float(clusterXIndex + clusterYIndex * CLUSTER_X_COUNT)+0.5)/float(c_ClusterBufferWidth),\r\n\t\t\t\t(float(clusterZIndex)+0.5)/float(c_ClusterBufferHeight));\r\n\tvec4 clusterPixel=texture2D(clusterBuffer, uv);\r\n\treturn ivec4(clusterPixel);//X:Point Count Y:Spot Count Z、W:Light Offset\r\n}\r\n\r\n\r\nint getLightIndex(sampler2D clusterBuffer,int offset,int index) \r\n{\r\n\tint totalOffset=offset+index;\r\n\tint row=totalOffset/c_ClusterBufferFloatWidth;\r\n\tint lastRowFloat=totalOffset-row*c_ClusterBufferFloatWidth;\r\n\tint col=lastRowFloat/4;\r\n\tvec2 uv=vec2((float(col)+0.5)/float(c_ClusterBufferWidth),\r\n\t\t\t\t(float(row)+0.5)/float(c_ClusterBufferHeight));\r\n\tvec4 texel = texture2D(clusterBuffer, uv);\r\n    int pixelComponent = lastRowFloat-col*4;\r\n    if (pixelComponent == 0) \r\n      return int(texel.x);\r\n    else if (pixelComponent == 1) \r\n      return int(texel.y);\r\n    else if (pixelComponent == 2) \r\n      return int(texel.z);\r\n    else if (pixelComponent == 3) \r\n      return int(texel.w);\r\n}\r\n\r\nDirectionLight getDirectionLight(sampler2D lightBuffer,int index) \r\n{\r\n    DirectionLight light;\r\n    float v = (float(index)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tlight.color=p1.rgb;\r\n    light.direction = p2.rgb;\r\n    return light;\r\n}\r\n\r\nPointLight getPointLight(sampler2D lightBuffer,sampler2D clusterBuffer,ivec4 clusterInfo,int index) \r\n{\r\n    PointLight light;\r\n\tint pointIndex=getLightIndex(clusterBuffer,clusterInfo.z*c_ClusterBufferFloatWidth+clusterInfo.w,index);\r\n    float v = (float(pointIndex)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tlight.color=p1.rgb;\r\n\tlight.range = p1.a;\r\n    light.position = p2.rgb;\r\n    return light;\r\n}\r\n\r\nSpotLight getSpotLight(sampler2D lightBuffer,sampler2D clusterBuffer,ivec4 clusterInfo,int index) \r\n{\r\n    SpotLight light;\r\n\tint spoIndex=getLightIndex(clusterBuffer,clusterInfo.z*c_ClusterBufferFloatWidth+clusterInfo.w,clusterInfo.x+index);\r\n    float v = (float(spoIndex)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tvec4 p3 = texture2D(lightBuffer, vec2(0.625,v));\r\n    light.color = p1.rgb;\r\n\tlight.range=p1.a;\r\n    light.position = p2.rgb;\r\n\tlight.spot = p2.a;\r\n\tlight.direction = p3.rgb;\r\n    return light;\r\n}\r\n\r\n// Laya中使用衰减纹理\r\nfloat LayaAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat fRatio = clamp(length(L) * invLightRadius,0.0,1.0);\r\n\tfRatio *= fRatio;\r\n\treturn 1.0 / (1.0 + 25.0 * fRatio)* clamp(4.0*(1.0 - fRatio),0.0,1.0); //fade to black as if 4 pixel texture\r\n}\r\n\r\n// Same as Just Cause 2 and Crysis 2 (you can read GPU Pro 1 book for more information)\r\nfloat BasicAttenuation(in vec3 L,in float invLightRadius) {\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = clamp(1.0 - dot(distance, distance),0.0,1.0); // Equals float attenuation = saturate(1.0f - dot(L, L) / (lightRadius *  lightRadius));\r\n\treturn attenuation * attenuation;\r\n}\r\n\r\n// Inspired on http://fools.slindev.com/viewtopic.php?f=11&t=21&view=unread#unread\r\nfloat NaturalAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat attenuationFactor = 30.0;\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = dot(distance, distance); // Equals float attenuation = dot(L, L) / (lightRadius *  lightRadius);\r\n\tattenuation = 1.0 / (attenuation * attenuationFactor + 1.0);\r\n\t// Second we move down the function therewith it reaches zero at abscissa 1:\r\n\tattenuationFactor = 1.0 / (attenuationFactor + 1.0); //attenuationFactor contains now the value we have to subtract\r\n\tattenuation = max(attenuation - attenuationFactor, 0.0); // The max fixes a bug.\r\n\t// Finally we expand the equation along the y-axis so that it starts with a function value of 1 again.\r\n\tattenuation /= 1.0 - attenuationFactor;\r\n\treturn attenuation;\r\n}\r\n\r\nvoid LayaAirBlinnPhongLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir,in vec3 lightColor, in vec3 lightVec,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tmediump vec3 h = normalize(viewDir-lightVec);\r\n\tlowp float ln = max (0.0, dot (-lightVec,normal));\r\n\tfloat nh = max (0.0, dot (h,normal));\r\n\tdiffuseColor=lightColor * ln;\r\n\tspecularColor=lightColor *specColor*pow (nh, specColorIntensity*128.0) * gloss;\r\n}\r\n\r\nvoid LayaAirBlinnPhongDiectionLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in DirectionLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec=normalize(light.direction);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,lightVec,diffuseColor,specularColor);\r\n}\r\n\r\nvoid LayaAirBlinnPhongPointLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in PointLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.position;\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,lightVec/length(lightVec),diffuseColor,specularColor);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.range);\r\n\tdiffuseColor *= attenuate;\r\n\tspecularColor*= attenuate;\r\n}\r\n\r\nvoid LayaAirBlinnPhongSpotLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in SpotLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.position;\r\n\tvec3 normalLightVec=lightVec/length(lightVec);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,normalLightVec,diffuseColor,specularColor);\r\n\tvec2 cosAngles=cos(vec2(light.spot,light.spot*0.5)*0.5);//ConeAttenuation\r\n\tfloat dl=dot(normalize(light.direction),normalLightVec);\r\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.range)*dl;\r\n\tdiffuseColor *=attenuate;\r\n\tspecularColor *=attenuate;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent,vec3 binormal) {\r\n\tvec3 normalT =vec3(2.0*normalMapSample.x - 1.0,1.0-2.0*normalMapSample.y,2.0*normalMapSample.z - 1.0);\r\n\tmediump vec3 N = unitNormal;\r\n\tmediump vec3 T = tangent;\r\n\tmediump vec3 B = binormal;\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal =normalize(TBN*normalT);\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace1(vec4 normalMapSample, vec3 tangent, vec3 binormal, vec3 unitNormal) {\r\n\tvec3 normalT;\r\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\r\n\tvec3 T = normalize(tangent);\r\n\tvec3 B = normalize(binormal);\r\n\tvec3 N = normalize(unitNormal);\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal = TBN * normalize(normalT);\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 DecodeLightmap(vec4 color) {\r\n\treturn color.rgb*color.a*5.0;\r\n}\r\n\r\nvec3 decodeHDR(vec4 color,float range) {\r\n\treturn color.rgb*color.a*range;\r\n}\r\n\r\nvec2 TransformUV(vec2 texcoord,vec4 tilingOffset) {\r\n\tvec2 transTexcoord=vec2(texcoord.x,texcoord.y-1.0)*tilingOffset.xy+vec2(tilingOffset.z,-tilingOffset.w);\r\n\ttransTexcoord.y+=1.0;\r\n\treturn transTexcoord;\r\n}\r\n\r\nvec4 remapGLPositionZ(vec4 position) {\r\n\tposition.z=position.z * 2.0 - position.w;\r\n\treturn position;\r\n}\r\n\r\nmat3 inverseMat(mat3 m) {\r\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\r\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\r\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\r\n\r\n  float b01 = a22 * a11 - a12 * a21;\r\n  float b11 = -a22 * a10 + a12 * a20;\r\n  float b21 = a21 * a10 - a11 * a20;\r\n\r\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\r\n\r\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\r\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\r\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\r\n}\r\n\r\nmediump vec3 layaLinearToGammaSpace (mediump vec3 linRGB)\r\n{\r\n    linRGB = max(linRGB, vec3(0.0));\r\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\r\n    return max(1.055 * pow(linRGB,vec3(0.416666667)) - 0.055, 0.0);   \r\n}\r\n\r\nLayaLight layaDirectionLightToLight(in DirectionLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\trelight.color = light.color*attenuate;\r\n\trelight.dir = light.direction;\r\n\treturn relight;\r\n}\r\n\r\nLayaLight layaPointLightToLight(in vec3 pos,in vec3 normal, in PointLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\tvec3 lightVec =  pos-light.position;\r\n\tattenuate *= LayaAttenuation(lightVec, 1.0/light.range);\r\n\trelight.color = light.color*attenuate;\r\n\trelight.dir = normalize(lightVec);\r\n\treturn relight;\r\n}\r\n\r\nLayaLight layaSpotLightToLight(in vec3 pos,in vec3 normal, in SpotLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\tvec3 lightVec =  pos-light.position;\r\n\tvec3 normalLightVec=lightVec/length(lightVec);\r\n\tvec2 cosAngles=cos(vec2(light.spot,light.spot*0.5)*0.5);//ConeAttenuation\r\n\tfloat dl=dot(normalize(light.direction),normalLightVec);\r\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\r\n\tattenuate *= LayaAttenuation(lightVec, 1.0/light.range)*dl;\r\n\trelight.dir = lightVec;\r\n\trelight.color = light.color*attenuate;\r\n\treturn relight;\r\n}\r\n\r\n",
        mi = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nuniform vec4 u_Color;\r\n\r\nvoid main()\r\n{\r\n  gl_FragColor = v_Color * u_Color; \r\n}\r\n\r\n",
        fi = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_MvpMatrix;\r\nuniform vec4 u_Color;\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\n\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n\tv_Color=a_Color*u_Color;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
        Ei = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\nuniform vec4 u_DiffuseColor;\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef DIFFUSEMAP\r\n\tuniform sampler2D u_DiffuseTexture;\r\n#endif\r\n\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform sampler2D u_LightMap;\r\n#endif\r\n\r\nvarying vec3 v_Normal;\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tvarying vec3 v_ViewDir; \r\n\r\n\tuniform vec3 u_MaterialSpecular;\r\n\tuniform float u_Shininess;\r\n\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n\r\n\t#ifdef SPECULARMAP \r\n\t\tuniform sampler2D u_SpecularTexture;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef NORMALMAP \r\n\tuniform sampler2D u_NormalTexture;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n\r\n#include "GlobalIllumination.glsl";//"GlobalIllumination.glsl use uniform should at front of this\r\n\r\n#include "ShadowHelper.glsl"\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\n\r\n\r\nvoid main_castShadow()\r\n{\r\n\t//gl_FragColor=vec4(v_posViewZ,0.0,0.0,1.0);\r\n\tgl_FragColor=packDepth(v_posViewZ);\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tfloat alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\r\n\t\tif( alpha < u_AlphaTestValue )\r\n\t\t{\r\n\t\t\tdiscard;\r\n\t\t}\r\n\t#endif\r\n}\r\nvoid main_normal()\r\n{\r\n\tvec3 normal;//light and SH maybe use normal\r\n\t#if defined(NORMALMAP)\r\n\t\tvec3 normalMapSample = texture2D(u_NormalTexture, v_Texcoord0).rgb;\r\n\t\tnormal = normalize(NormalSampleToWorldSpace(normalMapSample, v_Normal, v_Tangent,v_Binormal));\r\n\t#else\r\n\t\tnormal = normalize(v_Normal);\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 viewDir= normalize(v_ViewDir);\r\n\t#endif\r\n\r\n\tLayaGIInput giInput;\r\n\t#ifdef LIGHTMAP\t\r\n\t\tgiInput.lightmapUV=v_LightMapUV;\r\n\t#endif\r\n\tvec3 globalDiffuse=layaGIBase(giInput,1.0,normal);\r\n\t\r\n\tvec4 mainColor=u_DiffuseColor;\r\n\t#ifdef DIFFUSEMAP\r\n\t\tvec4 difTexColor=texture2D(u_DiffuseTexture, v_Texcoord0);\r\n\t\tmainColor=mainColor*difTexColor;\r\n\t#endif \r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tmainColor=mainColor*v_Color;\r\n\t#endif \r\n    \r\n\t#ifdef ALPHATEST\r\n\t\tif(mainColor.a<u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n  \r\n\t\r\n\tvec3 diffuse = vec3(0.0);\r\n\tvec3 specular= vec3(0.0);\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 dif,spe;\r\n\t\t#ifdef SPECULARMAP\r\n\t\t\tvec3 gloss=texture2D(u_SpecularTexture, v_Texcoord0).rgb;\r\n\t\t#else\r\n\t\t\t#ifdef DIFFUSEMAP\r\n\t\t\t\tvec3 gloss=vec3(difTexColor.a);\r\n\t\t\t#else\r\n\t\t\t\tvec3 gloss=vec3(1.0);\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_DirectionLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_PointLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_SpotLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,directionLight,dif,spe);\r\n\t\t\t\tdiffuse+=dif;\r\n\t\t\t\tspecular+=spe;\r\n\t\t\t}\r\n\t\t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,pointLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,spotLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tfloat shadowValue = 1.0;\r\n\t\t#ifdef SHADOWMAP_PSSM3\r\n\t\t\tshadowValue = getShadowPSSM3(u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\t#ifdef SHADOWMAP_PSSM2\r\n\t\t\tshadowValue = getShadowPSSM2(u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif \r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tshadowValue = getShadowPSSM1(u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse*shadowValue),mainColor.a);\r\n\t#else\r\n\t\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse),mainColor.a);\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t#ifdef RECEIVESHADOW\r\n\t\t\tgl_FragColor.rgb+=specular*shadowValue;\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb+=specular;\r\n\t\t#endif\r\n\t#endif\r\n\t  \r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t#endif\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\t\t\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif  \r\n}\r\n\r\n',
        Ti = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#if defined(LIGHTMAP)&&defined(UV1)\r\n\tattribute vec2 a_Texcoord1;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tattribute vec4 a_Color;\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nattribute vec3 a_Normal;\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_ViewDir; \r\n#endif\r\n\r\n#if defined(NORMALMAP)\r\n\tattribute vec4 a_Tangent0;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n  #ifdef SHADOWMAP_PSSM1 \r\n  varying vec4 v_lightMVPPos;\r\n  uniform mat4 u_lightShadowVP[4];\r\n  #endif\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t//TODO没考虑UV动画呢\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n\tv_posViewZ = gl_Position.z;\r\n}\r\n\r\nvoid main_normal()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\tmat4 worldMat;\r\n\t#ifdef GPU_INSTANCE\r\n\t\tworldMat = a_WorldMat;\r\n\t#else\r\n\t\tworldMat = u_WorldMat;\r\n\t#endif\r\n\r\n\tmat3 worldInvMat;\r\n\t#ifdef BONE\r\n\t\tworldInvMat=inverseMat(mat3(worldMat*skinTransform));\r\n\t#else\r\n\t\tworldInvMat=inverseMat(mat3(worldMat));\r\n\t#endif  \r\n\tv_Normal=normalize(a_Normal*worldInvMat);\r\n\t#if defined(NORMALMAP)\r\n\t\tv_Tangent=normalize(a_Tangent0.xyz*worldInvMat);\r\n\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\t\tv_PositionWorld=(worldMat*position).xyz;\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\r\n\t#endif\r\n\r\n\t#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t\t#else\r\n\t\t\tv_Texcoord0=a_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LIGHTMAP\r\n\t\t#ifdef UV1\r\n\t\t\tv_LightMapUV=vec2(a_Texcoord1.x,1.0-a_Texcoord1.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t#else\r\n\t\t\tv_LightMapUV=vec2(a_Texcoord0.x,1.0-a_Texcoord0.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t#endif \r\n\t\tv_LightMapUV.y=1.0-v_LightMapUV.y;\r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color=a_Color;\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1 \r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif\r\n}',
        pi = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nvarying vec2 v_TextureCoordinate;\r\nuniform sampler2D u_texture;\r\nuniform vec4 u_Tintcolor;\r\n\r\n#ifdef RENDERMODE_MESH\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\n\r\nvoid main()\r\n{\t\r\n\t#ifdef RENDERMODE_MESH\r\n\t\tgl_FragColor=v_MeshColor;\r\n\t#else\r\n\t\tgl_FragColor=vec4(1.0);\t\r\n\t#endif\r\n\t\t\r\n\t#ifdef DIFFUSEMAP\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*v_Color;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=v_Color;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}",
        gi = '#include "Lighting.glsl";\r\n\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\tattribute vec4 a_CornerTextureCoordinate;\r\n#endif\r\n#ifdef RENDERMODE_MESH\r\n\tattribute vec3 a_MeshPosition;\r\n\tattribute vec4 a_MeshColor;\r\n\tattribute vec2 a_MeshTextureCoordinate;\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\nattribute vec4 a_ShapePositionStartLifeTime;\r\nattribute vec4 a_DirectionTime;\r\nattribute vec4 a_StartColor;\r\nattribute vec3 a_StartSize;\r\nattribute vec3 a_StartRotation0;\r\nattribute float a_StartSpeed;\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n  attribute vec4 a_Random0;\r\n#endif\r\n#if defined(TEXTURESHEETANIMATIONRANDOMCURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  attribute vec4 a_Random1;\r\n#endif\r\nattribute vec3 a_SimulationWorldPostion;\r\nattribute vec4 a_SimulationWorldRotation;\r\n\r\nvarying vec4 v_Color;\r\n#ifdef DIFFUSEMAP\r\n\tvarying vec2 v_TextureCoordinate;\r\n#endif\r\n\r\nuniform float u_CurrentTime;\r\nuniform vec3 u_Gravity;\r\n\r\nuniform vec3 u_WorldPosition;\r\nuniform vec4 u_WorldRotation;\r\nuniform bool u_ThreeDStartRotation;\r\nuniform int u_ScalingMode;\r\nuniform vec3 u_PositionScale;\r\nuniform vec3 u_SizeScale;\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\n#ifdef STRETCHEDBILLBOARD\r\n\tuniform vec3 u_CameraPos;\r\n#endif\r\nuniform vec3 u_CameraDirection;//TODO:只有几种广告牌模式需要用\r\nuniform vec3 u_CameraUp;\r\n\r\nuniform  float u_StretchedBillboardLengthScale;\r\nuniform  float u_StretchedBillboardSpeedScale;\r\nuniform int u_SimulationSpace;\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  int  u_VOLSpaceType;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)\r\n  uniform  vec3 u_VOLVelocityConst;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  vec2 u_VOLVelocityGradientX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientZ[4];//x为key,y为速度\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n  uniform  vec3 u_VOLVelocityConstMax;\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n  uniform  vec2 u_VOLVelocityGradientMaxX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxZ[4];//x为key,y为速度\r\n#endif\r\n\r\n#ifdef COLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n#ifdef RANDOMCOLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n  uniform  vec4 u_MaxColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_MaxColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n\r\n\r\n#if defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMERANDOMCURVES)\r\n  uniform  vec2 u_SOLSizeGradient[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n  uniform  vec2 u_SOLSizeGradientMax[4];//x为key,y为尺寸\r\n#endif\r\n#if defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\n  uniform  vec2 u_SOLSizeGradientX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientZ[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n  uniform  vec2 u_SOLSizeGradientMaxX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxZ[4];//x为key,y为尺寸\r\n#endif\r\n\r\n\r\n#ifdef ROTATIONOVERLIFETIME\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  float u_ROLAngularVelocityConst;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  float u_ROLAngularVelocityConstMax;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradient[4];//x为key,y为旋转\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMax[4];//x为key,y为旋转\r\n  #endif\r\n#endif\r\n#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  vec3 u_ROLAngularVelocityConstSeprarate;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  vec3 u_ROLAngularVelocityConstMaxSeprarate;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradientX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientZ[4];\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxZ[4];\r\n\tuniform  vec2 u_ROLAngularVelocityGradientMaxW[4];\r\n  #endif\r\n#endif\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\n  uniform  float u_TSACycles;\r\n  uniform  vec2 u_TSASubUVLength;\r\n  uniform  vec2 u_TSAGradientUVs[4];//x为key,y为frame\r\n#endif\r\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n  uniform  vec2 u_TSAMaxGradientUVs[4];//x为key,y为frame\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvec3 rotationByEuler(in vec3 vector,in vec3 rot)\r\n{\r\n\tfloat halfRoll = rot.z * 0.5;\r\n    float halfPitch = rot.x * 0.5;\r\n\tfloat halfYaw = rot.y * 0.5;\r\n\r\n\tfloat sinRoll = sin(halfRoll);\r\n\tfloat cosRoll = cos(halfRoll);\r\n\tfloat sinPitch = sin(halfPitch);\r\n\tfloat cosPitch = cos(halfPitch);\r\n\tfloat sinYaw = sin(halfYaw);\r\n\tfloat cosYaw = cos(halfYaw);\r\n\r\n\tfloat quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\r\n\tfloat quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\r\n\tfloat quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\r\n\tfloat quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\n//假定axis已经归一化\r\nvec3 rotationByAxis(in vec3 vector,in vec3 axis, in float angle)\r\n{\r\n\tfloat halfAngle = angle * 0.5;\r\n\tfloat sin = sin(halfAngle);\r\n\t\r\n\tfloat quaX = axis.x * sin;\r\n\tfloat quaY = axis.y * sin;\r\n\tfloat quaZ = axis.z * sin;\r\n\tfloat quaW = cos(halfAngle);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\nvec3 rotationByQuaternions(in vec3 v,in vec4 q) \r\n{\r\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\r\n}\r\n\r\n \r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\nfloat getCurValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat curValue;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\tcurValue=mix(lastGradientNumber.y,gradientNumber.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn curValue;\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\nfloat getTotalValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat totalValue=0.0;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\tfloat lastValue=lastGradientNumber.y;\r\n\t\t\r\n\t\tif(key>=normalizedAge){\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\ttotalValue+=(lastValue+mix(lastValue,gradientNumber.y,age))/2.0*a_ShapePositionStartLifeTime.w*(normalizedAge-lastKey);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse{\r\n\t\t\ttotalValue+=(lastValue+gradientNumber.y)/2.0*a_ShapePositionStartLifeTime.w*(key-lastGradientNumber.x);\r\n\t\t}\r\n\t}\r\n\treturn totalValue;\r\n}\r\n#endif\r\n\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)\r\nvec4 getColorFromGradient(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float normalizedAge)\r\n{\r\n\tvec4 overTimeColor;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientAlpha=gradientAlphas[i];\r\n\t\tfloat alphaKey=gradientAlpha.x;\r\n\t\tif(alphaKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientAlpha=gradientAlphas[i-1];\r\n\t\t\tfloat lastAlphaKey=lastGradientAlpha.x;\r\n\t\t\tfloat age=(normalizedAge-lastAlphaKey)/(alphaKey-lastAlphaKey);\r\n\t\t\toverTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec4 gradientColor=gradientColors[i];\r\n\t\tfloat colorKey=gradientColor.x;\r\n\t\tif(colorKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec4 lastGradientColor=gradientColors[i-1];\r\n\t\t\tfloat lastColorKey=lastGradientColor.x;\r\n\t\t\tfloat age=(normalizedAge-lastColorKey)/(colorKey-lastColorKey);\r\n\t\t\toverTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn overTimeColor;\r\n}\r\n#endif\r\n\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\nfloat getFrameFromGradient(in vec2 gradientFrames[4],in float normalizedAge)\r\n{\r\n\tfloat overTimeFrame;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientFrame=gradientFrames[i];\r\n\t\tfloat key=gradientFrame.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientFrame=gradientFrames[i-1];\r\n\t\t\tfloat lastKey=lastGradientFrame.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\toverTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn floor(overTimeFrame);\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\nvec3 computeParticleLifeVelocity(in float normalizedAge)\r\n{\r\n  vec3 outLifeVelocity;\r\n  #ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t outLifeVelocity=u_VOLVelocityConst; \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMECURVE\r\n     outLifeVelocity= vec3(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t outLifeVelocity=mix(u_VOLVelocityConst,u_VOLVelocityConstMax,vec3(a_Random1.y,a_Random1.z,a_Random1.w)); \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n     outLifeVelocity=vec3(mix(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y),\r\n\t                 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z),\r\n\t\t\t\t\t mix(getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n  #endif\r\n\t\t\t\t\t\r\n  return outLifeVelocity;\r\n} \r\n#endif\r\n\r\nvec3 computeParticlePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float normalizedAge,vec3 gravityVelocity,vec4 worldRotation)\r\n{\r\n   vec3 startPosition;\r\n   vec3 lifePosition;\r\n   #if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t#ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMECURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n\t#endif\r\n\t\r\n\tvec3 finalPosition;\r\n\tif(u_VOLSpaceType==0){\r\n\t  if(u_ScalingMode!=2)\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition),worldRotation);\r\n\t  else\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition,worldRotation);\r\n\t}\r\n\telse{\r\n\t  if(u_ScalingMode!=2)\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation)+lifePosition;\r\n\t  else\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation)+lifePosition;\r\n\t}\r\n  #else\r\n\t startPosition=startVelocity*age;\r\n\t vec3 finalPosition;\r\n\t if(u_ScalingMode!=2)\r\n\t\t\tfinalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation);\r\n\t else\r\n\t   \tfinalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation);\r\n  #endif\r\n  \r\n  if(u_SimulationSpace==0)\r\n    finalPosition=finalPosition+a_SimulationWorldPostion;\r\n  else if(u_SimulationSpace==1) \r\n    finalPosition=finalPosition+u_WorldPosition;\r\n  \r\n  finalPosition+=0.5*gravityVelocity*age;\r\n \r\n  return  finalPosition;\r\n}\r\n\r\n\r\nvec4 computeParticleColor(in vec4 color,in float normalizedAge)\r\n{\r\n\t#ifdef COLOROVERLIFETIME\r\n\t  color*=getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge);\r\n\t#endif\r\n\t\r\n\t#ifdef RANDOMCOLOROVERLIFETIME\r\n\t  color*=mix(getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge),getColorFromGradient(u_MaxColorOverLifeGradientAlphas,u_MaxColorOverLifeGradientColors,normalizedAge),a_Random0.y);\r\n\t#endif\r\n\r\n    return color;\r\n}\r\n\r\nvec2 computeParticleSizeBillbard(in vec2 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec2(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec2(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n\r\n#ifdef RENDERMODE_MESH\r\nvec3 computeParticleSizeMesh(in vec3 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec3(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec3(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z)\r\n\t\t,mix(getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxZ,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n#endif\r\n\r\nfloat computeParticleRotationFloat(in float rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConstSeprarate.z*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConstSeprarate.z,u_ROLAngularVelocityConstMaxSeprarate.z,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n\r\n#if defined(RENDERMODE_MESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE))\r\nvec3 computeParticleRotationVec3(in vec3 rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tvec3 ageRot=u_ROLAngularVelocityConstSeprarate*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge));\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tvec3 ageRot=mix(u_ROLAngularVelocityConstSeprarate,u_ROLAngularVelocityConstMaxSeprarate,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxX,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxY,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n#endif\r\n\r\nvec2 computeParticleUV(in vec2 uv,in float normalizedAge)\r\n{ \r\n\t#ifdef TEXTURESHEETANIMATIONCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat frame=getFrameFromGradient(u_TSAGradientUVs,cycleNormalizedAge-floor(cycleNormalizedAge));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\t#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\r\n\t    float frame=floor(mix(getFrameFromGradient(u_TSAGradientUVs,uvNormalizedAge),getFrameFromGradient(u_TSAMaxGradientUVs,uvNormalizedAge),a_Random1.x));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\treturn uv;\r\n}\r\n\r\nvoid main()\r\n{\r\n\tfloat age = u_CurrentTime - a_DirectionTime.w;\r\n\tfloat normalizedAge = age/a_ShapePositionStartLifeTime.w;\r\n\tvec3 lifeVelocity;\r\n\tif(normalizedAge<1.0)\r\n\t{ \r\n\t\tvec3 startVelocity=a_DirectionTime.xyz*a_StartSpeed;\r\n\t\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t\t\tlifeVelocity= computeParticleLifeVelocity(normalizedAge);//计算粒子生命周期速度\r\n\t\t#endif \r\n\t\tvec3 gravityVelocity=u_Gravity*age;\r\n\t\t\r\n\t\tvec4 worldRotation;\r\n\t\tif(u_SimulationSpace==0)\r\n\t\t\tworldRotation=a_SimulationWorldRotation;\r\n\t\telse\r\n\t\t\tworldRotation=u_WorldRotation;\r\n\t\t\r\n\t\tvec3 center=computeParticlePosition(startVelocity, lifeVelocity, age, normalizedAge,gravityVelocity,worldRotation);//计算粒子位置\r\n\t\r\n\t\r\n\t\t#ifdef SPHERHBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tvec3 cameraUpVector =normalize(u_CameraUp);//TODO:是否外面归一化\r\n\t\t\tvec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n\t\t\tvec3 upVector = normalize(cross(sideVector,u_CameraDirection));\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z,age,normalizedAge));\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,rotation);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\t\tfloat c = cos(rot);\r\n\t\t\t\t\tfloat s = sin(rot);\r\n\t\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t\t}\r\n\t\t\t#else\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,a_StartRotation0);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tfloat c = cos(a_StartRotation0.x);\r\n\t\t\t\t\tfloat s = sin(a_StartRotation0.x);\r\n\t\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef STRETCHEDBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tvec3 velocity;\r\n\t\t\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t\t\t\tif(u_VOLSpaceType==0)\r\n\t\t\t\tvelocity=rotationByQuaternions(u_SizeScale*(startVelocity+lifeVelocity),worldRotation)+gravityVelocity;\r\n\t\t\t\telse\r\n\t\t\t\tvelocity=rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+lifeVelocity+gravityVelocity;\r\n\t\t\t#else\r\n\t\t\t\tvelocity= rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+gravityVelocity;\r\n\t\t\t#endif\t\r\n\t\t\tvec3 cameraUpVector = normalize(velocity);\r\n\t\t\tvec3 direction = normalize(center-u_CameraPos);\r\n\t\t\tvec3 sideVector = normalize(cross(direction,normalize(velocity)));\r\n\t\t\t\r\n\t\t\tsideVector=u_SizeScale.xzy*sideVector;\r\n\t\t\tcameraUpVector=length(vec3(u_SizeScale.x,0.0,0.0))*cameraUpVector;\r\n\t\t\t\r\n\t\t\tvec2 size=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\t\r\n\t\t\tconst mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\r\n\t\t\tcorner=rotaionZHalfPI*corner;\r\n\t\t\tcorner.y=corner.y-abs(corner.y);\r\n\t\t\t\r\n\t\t\tfloat speed=length(velocity);//TODO:\r\n\t\t\tcenter +=sign(u_SizeScale.x)*(sign(u_StretchedBillboardLengthScale)*size.x*corner.x*sideVector+(speed*u_StretchedBillboardSpeedScale+size.y*u_StretchedBillboardLengthScale)*corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef HORIZONTALBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tconst vec3 cameraUpVector=vec3(0.0,0.0,1.0);\r\n\t\t\tconst vec3 sideVector = vec3(-1.0,0.0,0.0);\r\n\t\t\t\r\n\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\tfloat c = cos(rot);\r\n\t\t\tfloat s = sin(rot);\r\n\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\tcorner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\tcenter +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef VERTICALBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tconst vec3 cameraUpVector =vec3(0.0,1.0,0.0);\r\n\t\t\tvec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n\t\t\t\r\n\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\tfloat c = cos(rot);\r\n\t\t\tfloat s = sin(rot);\r\n\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\tcorner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\tcenter +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef RENDERMODE_MESH\r\n\t\t\tvec3 size=computeParticleSizeMesh(a_StartSize,normalizedAge);\r\n\t\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z, age,normalizedAge));\r\n\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,rotation),worldRotation);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t\t\t\t\tfloat angle=computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),angle),worldRotation));//已验证\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\t\t\tcenter+= u_SizeScale.xzy*(rotationByQuaternions(rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\r\n\t\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\t\tcenter+=rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle);//已验证\r\n\t\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\t\tcenter+=rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle),worldRotation);//已验证\r\n\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t#endif\r\n\t\t\t\t\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t\t\t\t\t//TODO:是否应合并if(u_ThreeDStartRotation)分支代码,待测试\r\n\t\t\t\t\t\tvec3 angle=computeParticleRotationVec3(vec3(0.0,0.0,-a_StartRotation0.x), age,normalizedAge);\r\n\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByEuler(u_SizeScale*a_MeshPosition*size,vec3(angle.x,angle.y,angle.z)),worldRotation));//已验证\r\n\t\t\t\t\t#endif\t\t\r\n\t\t\t\t}\r\n\t\t\t#else\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,a_StartRotation0),worldRotation);//已验证\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x);\r\n\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\tcenter+= (rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x),worldRotation));//已验证\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\tcenter+= u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x);\r\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x),worldRotation);\t\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x);\r\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x),worldRotation);//已验证\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\tv_MeshColor=a_MeshColor;\r\n\t\t#endif\r\n\t\r\n\t\tgl_Position=u_Projection*u_View*vec4(center,1.0);\r\n\t\tv_Color = computeParticleColor(a_StartColor, normalizedAge);\r\n\t\t#ifdef DIFFUSEMAP\r\n\t\t\t#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\t\t\t\tv_TextureCoordinate =computeParticleUV(a_CornerTextureCoordinate.zw, normalizedAge);\r\n\t\t\t#endif\r\n\t\t\t#ifdef RENDERMODE_MESH\r\n\t\t\t\tv_TextureCoordinate =computeParticleUV(a_MeshTextureCoordinate, normalizedAge);\r\n\t\t\t#endif\r\n\t\t\t\r\n\t\t\t#ifdef TILINGOFFSET\r\n\t\t\t\tv_TextureCoordinate=TransformUV(v_TextureCoordinate,u_TilingOffset);\r\n\t\t\t#endif\r\n\t\t#endif\r\n   \t}\r\n   \telse\r\n\t{\r\n\t\tgl_Position=vec4(2.0,2.0,2.0,1.0);//Discard use out of X(-1,1),Y(-1,1),Z(0,1)\r\n\t}\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\n',
        Si = '// allow to explicitly override LAYA_BRDF_GI and LAYA_BRDF_LIGHT in custom shader,default is layaBRDFHighGI and layaBRDFHighLight\r\n#if !defined (LAYA_BRDF_GI) \r\n\t#if defined(LAYA_PBR_BRDF_LOW)\r\n\t\t#define LAYA_BRDF_GI layaBRDFLowGI\r\n\t#elif defined(LAYA_PBR_BRDF_HIGH)\r\n\t\t#define LAYA_BRDF_GI layaBRDFHighGI\r\n\t#endif\r\n#endif\r\n#if !defined (LAYA_BRDF_LIGHT)\r\n\t#if defined(LAYA_PBR_BRDF_LOW)\r\n\t\t#define LAYA_BRDF_LIGHT layaBRDFLowLight\r\n\t#elif defined(LAYA_PBR_BRDF_HIGH)\r\n\t\t#define LAYA_BRDF_LIGHT layaBRDFHighLight\r\n\t#endif\r\n#endif\r\n\r\n#define PI 3.14159265359\r\n#define INV_PI 0.31830988618\r\n\r\nmediump float pow4(mediump float x)\r\n{\r\n\treturn x * x * x * x;\r\n}\r\n\r\nmediump float pow5(mediump float x)\r\n{\r\n\treturn x * x * x * x * x;\r\n}\r\n\r\nmediump vec3 fresnelLerp(mediump vec3 F0,mediump vec3 F90,mediump float cosA)\r\n{\r\n\tfloat t = pow5(1.0 - cosA);   // ala Schlick interpoliation\r\n\treturn mix(F0, F90, t);\r\n}\r\n\r\nmediump vec3 fresnelTerm(mediump vec3 F0,mediump float cosA)\r\n{\r\n\tfloat t = pow5(1.0 - cosA);   // ala Schlick interpoliation\r\n\treturn F0 + (vec3(1.0) - F0) * t;\r\n}\r\n\r\n// approximage Schlick with ^4 instead of ^5\r\nmediump vec3 fresnelLerpFast (mediump vec3 F0, mediump vec3 F90,mediump float cosA)\r\n{\r\n    mediump float t = pow4 (1.0 - cosA);\r\n    return mix (F0, F90, t);\r\n}\r\n\r\nfloat smoothnessToPerceptualRoughness(float smoothness)\r\n{\r\n    return 1.0 - smoothness;\r\n}\r\n\r\nfloat perceptualRoughnessToRoughness(float perceptualRoughness)\r\n{\r\n    return perceptualRoughness * perceptualRoughness;\r\n}\r\n\r\nvec3 safeNormalize(vec3 inVec)\r\n{\r\n\tfloat dp3 = max(0.001,dot(inVec,inVec));\r\n\treturn inVec * inversesqrt(dp3);\r\n}\r\n\r\n// Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function.\r\nmediump float disneyDiffuse(mediump float NdotV,mediump float NdotL,mediump float LdotH,mediump float perceptualRoughness)\r\n{\r\n\t//https://www.cnblogs.com/herenzhiming/articles/5790389.html\r\n\tmediump float fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\r\n\t// Two schlick fresnel term\r\n\tmediump float lightScatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotL));\r\n\tmediump float viewScatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotV));\r\n\r\n\treturn lightScatter * viewScatter;\r\n}\r\n\r\n// Ref: http://jcgt.org/published/0003/02/03/paper.pdf\r\nfloat smithJointGGXVisibilityTerm(float NdotL, float NdotV, float roughness)\r\n{\r\n\t// Original formulation:\r\n    // lambda_v    = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;\r\n    // lambda_l    = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;\r\n    // G           = 1 / (1 + lambda_v + lambda_l);\r\n\r\n\t// scientific code implement:\r\n\t// Reorder code to be more optimal\r\n    // half a          = roughness;\r\n    // half a2         = a * a;\r\n\r\n    // half lambdaV    = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\r\n    // half lambdaL    = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\r\n\r\n    // Simplify visibility term: (2.0f * NdotL * NdotV) /  ((4.0f * NdotL * NdotV) * (lambda_v + lambda_l + 1e-5f));\r\n    // return 0.5f / (lambdaV + lambdaL + 1e-5f);  \r\n\t// This function is not intended to be running on Mobile,therefore epsilon is smaller than can be represented by half\r\n\r\n\t// Approximation of the above formulation (simplify the sqrt, not mathematically correct but close enough)\r\n\tfloat a = roughness;\r\n\tfloat lambdaV = NdotL * (NdotV * (1.0 - a) + a);\r\n\tfloat lambdaL = NdotV * (NdotL * (1.0 - a) + a);\r\n\treturn 0.5 / (lambdaV + lambdaL + 1e-5);\r\n}\r\n\r\nfloat ggxTerm(float NdotH, float roughness)\r\n{\r\n\tfloat a2 = roughness * roughness;\r\n\tfloat d = (NdotH * a2 - NdotH) * NdotH + 1.0; // 2 mad\r\n\treturn INV_PI * a2 / (d * d + 1e-7); // This function is not intended to be running on Mobile,therefore epsilon is smaller than what can be represented by half//返回值小用half来返回\r\n}\r\n\r\n// BRDF1-------------------------------------------------------------------------------------\r\n\r\n// Note: BRDF entry points use smoothness and oneMinusReflectivity for optimization purposes,\r\n// mostly for DX9 SM2.0 level. Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.\r\n\r\n// Main Physically Based BRDF\r\n// Derived from Disney work and based on Torrance-Sparrow micro-facet model\r\n//\r\n// BRDF = kD / pi + kS * (D * V * F) / 4\r\n// I = BRDF * NdotL\r\n//\r\n// *NDF GGX:\r\n// *Smith for Visiblity term\r\n// *Schlick approximation for Fresnel\r\nmediump vec4 layaBRDFHighLight(mediump vec3 diffColor, mediump vec3 specColor, mediump float oneMinusReflectivity, float perceptualRoughness,float roughness,mediump float nv,vec3 normal, vec3 viewDir,LayaLight light)\r\n{\r\n\tvec3 halfDir = safeNormalize(viewDir-light.dir);\r\n\r\n\tfloat nl = clamp(dot(normal, -light.dir),0.0,1.0);\r\n\tfloat nh = clamp(dot(normal, halfDir),0.0,1.0);\r\n\tmediump float lv = clamp(dot(light.dir, viewDir),0.0,1.0);\r\n\tmediump float lh = clamp(dot(light.dir, -halfDir),0.0,1.0);\r\n\r\n\t// Diffuse term\r\n\tmediump float diffuseTerm = disneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;\r\n\r\n\t// Specular term\r\n    // HACK: theoretically we should divide diffuseTerm by Pi and not multiply specularTerm!\r\n    // BUT that will make shader look significantly darker than Legacy ones\r\n\r\n\t// GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.\r\n\troughness = max(roughness, 0.002);\r\n\tfloat V = smithJointGGXVisibilityTerm(nl, nv, roughness);\r\n\tfloat D = ggxTerm(nh, roughness);\r\n\r\n\tfloat specularTerm = V * D * PI; // Torrance-Sparrow model, Fresnel is applied later\r\n\r\n\t//#ifdef LAYA_COLORSPACE_GAMMA\r\n\tspecularTerm = sqrt(max(1e-4, specularTerm));\r\n\t//#endif\r\n\tspecularTerm = max(0.0, specularTerm * nl);\r\n\t\t\r\n\tmediump vec3 color = diffColor * light.color * diffuseTerm + specularTerm * light.color * fresnelTerm(specColor, lh);\r\n\treturn vec4(color, 1.0);\r\n}\r\n\r\nvec4 layaBRDFHighGI(mediump vec3 diffColor,mediump vec3 specColor,mediump float oneMinusReflectivity,float smoothness ,float perceptualRoughness,float roughness,mediump float nv,vec3 normal, vec3 viewDir,LayaGI gi)\r\n{\r\n\t// surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(roughness^2+1)\r\n\tfloat surfaceReduction;\r\n\tsurfaceReduction = 1.0 - 0.28*roughness*perceptualRoughness;// 1-0.28*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain [0;1]\r\n\tfloat grazingTerm = clamp(smoothness + (1.0 - oneMinusReflectivity),0.0,1.0);\r\n\tmediump vec3 color =diffColor * gi.diffuse + surfaceReduction * gi.specular * fresnelLerp(specColor,vec3(grazingTerm), nv);\r\n\treturn vec4(color,1.0);\r\n}\r\n// BRDF1-------------------------------------------------------------------------------------\r\n\r\n\r\n// BRDF2-------------------------------------------------------------------------------------\r\n// Based on Minimalist CookTorrance BRDF\r\n// Implementation is slightly different from original derivation: http://www.thetenthplanet.de/archives/255\r\n//\r\n// *NDF [Modified] GGX:\r\n// *Modified Kelemen and Szirmay-​Kalos for Visibility term\r\n// *Fresnel approximated with 1/LdotH\r\nmediump vec4 layaBRDFLowLight (mediump vec3 diffColor, mediump vec3 specColor,mediump float oneMinusReflectivity,float perceptualRoughness,float roughness,mediump float nv,vec3 normal,vec3 viewDir,LayaLight light)\r\n{\r\n    vec3 halfDir = safeNormalize (viewDir-light.dir);\r\n    mediump float nl = clamp(dot(normal, -light.dir),0.0,1.0);\r\n    float nh = clamp(dot(normal, halfDir),0.0,1.0);\r\n    float lh = clamp(dot(-light.dir, halfDir),0.0,1.0);\r\n\r\n    // GGX Distribution multiplied by combined approximation of Visibility and Fresnel\r\n    // See "Optimizing PBR for Mobile" from Siggraph 2015 moving mobile graphics course\r\n    // https://community.arm.com/events/1155\r\n    mediump float a = roughness;\r\n    float a2 = a*a;\r\n\r\n    float d = nh * nh * (a2 - 1.0) + 1.00001;\r\n\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\t// Tighter approximation for Gamma only rendering mode!\r\n\t\t// DVF = sqrt(DVF);\r\n\t\t// DVF = (a * sqrt(.25)) / (max(sqrt(0.1), lh)*sqrt(roughness + .5) * d);\r\n\t\tfloat specularTerm = a / (max(0.32, lh) * (1.5 + roughness) * d);\r\n\t// #else\r\n\t// \tfloat specularTerm = a2 / (max(0.1f, lh*lh) * (roughness + 0.5f) * (d * d) * 4);\r\n\t// #endif\r\n\r\n    // on mobiles (where half actually means something) denominator have risk of overflow\r\n    // clamp below was added specifically to "fix" that, but dx compiler (we convert bytecode to metal/gles)\r\n    // sees that specularTerm have only non-negative terms, so it skips max(0,..) in clamp (leaving only min(100,...))\r\n\r\n\t//#if defined (SHADER_API_MOBILE)\r\n    specularTerm = specularTerm - 1e-4;\r\n\t//#endif\r\n\r\n\t// #else\r\n\t\t// // Legacy\r\n\t\t// half specularPower = PerceptualRoughnessToSpecPower(perceptualRoughness);\r\n\t\t// // Modified with approximate Visibility function that takes roughness into account\r\n\t\t// // Original ((n+1)*N.H^n) / (8*Pi * L.H^3) didn\'t take into account roughness\r\n\t\t// // and produced extremely bright specular at grazing angles\r\n\r\n\t\t// half invV = lh * lh * smoothness + perceptualRoughness * perceptualRoughness; // approx ModifiedKelemenVisibilityTerm(lh, perceptualRoughness);\r\n\t\t// half invF = lh;\r\n\r\n\t\t// half specularTerm = ((specularPower + 1) * pow (nh, specularPower)) / (8 * invV * invF + 1e-4h);\r\n\r\n\t\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\t// \tspecularTerm = sqrt(max(1e-4f, specularTerm));\r\n\t\t// #endif\r\n\t// #endif\r\n\r\n\t// #if defined (SHADER_API_MOBILE)\r\n\t\tspecularTerm = clamp(specularTerm, 0.0, 100.0); // Prevent FP16 overflow on mobiles\r\n\t// #endif\r\n    \r\n    mediump vec3 color = (diffColor + specularTerm * specColor) * light.color * nl;\r\n\r\n    return vec4(color, 1.0);\r\n}\r\n\r\nmediump vec4 layaBRDFLowGI (mediump vec3 diffColor, mediump vec3 specColor,mediump float oneMinusReflectivity,mediump float smoothness,float perceptualRoughness,float roughness,mediump float nv,vec3 normal,vec3 viewDir,LayaGI gi)\r\n{\r\n\t// surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(realRoughness^2+1)\r\n\r\n    // 1-0.28*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain [0;1]\r\n    // 1-x^3*(0.6-0.08*x)   approximation for 1/(x^4+1)\r\n\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\tmediump float surfaceReduction = 0.28;\r\n\t// #else\r\n\t\t// mediump float surfaceReduction = (0.6-0.08*perceptualRoughness);\r\n\t// #endif\r\n\r\n    surfaceReduction = 1.0 - roughness*perceptualRoughness*surfaceReduction;\r\n\r\n\tmediump float grazingTerm = clamp(smoothness + (1.0-oneMinusReflectivity),0.0,1.0);\r\n\tmediump vec3 color =gi.diffuse * diffColor+ surfaceReduction * gi.specular * fresnelLerpFast (specColor, vec3(grazingTerm), nv);\r\n\r\n    return vec4(color, 1.0);\r\n}\r\n// BRDF2-------------------------------------------------------------------------------------',
        Ri = "struct FragmentCommonData{\r\n\tvec3 diffColor;\r\n\tvec3 specColor;\r\n\tfloat oneMinusReflectivity;\r\n\tfloat smoothness;\r\n\t//vec3 eyeVec;TODO:maybe can remove\r\n\t//float alpha;\r\n\t//vec3 reflUVW;\r\n};\r\n\r\n#ifndef SETUP_BRDF_INPUT\r\n    #define SETUP_BRDF_INPUT metallicSetup//default is metallicSetup,also can be other. \r\n#endif\r\n\r\nconst mediump vec4 dielectricSpecularColor = vec4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301);\r\n\r\nmediump vec3 diffuseAndSpecularFromMetallic(mediump vec3 albedo,mediump float metallic, out mediump vec3 specColor, out mediump float oneMinusReflectivity)\r\n{\r\n\tspecColor = mix(dielectricSpecularColor.rgb, albedo, metallic);\r\n\toneMinusReflectivity= dielectricSpecularColor.a*(1.0-metallic);//diffuse proportion\r\n\treturn albedo * oneMinusReflectivity;\r\n}\r\n\r\nmediump float specularStrength(mediump vec3 specular)\r\n{\r\n    return max (max (specular.r, specular.g), specular.b);\r\n}\r\n\r\n// Diffuse/Spec Energy conservation\r\nmediump vec3 energyConservationBetweenDiffuseAndSpecular (mediump vec3 albedo, mediump vec3 specColor, out mediump float oneMinusReflectivity)\r\n{\r\n\toneMinusReflectivity = 1.0 - specularStrength(specColor);\r\n    return albedo * (vec3(1.0) - specColor);\r\n}\r\n\r\n#ifdef TRANSPARENTBLEND\r\n\tmediump vec3 preMultiplyAlpha (mediump vec3 diffColor, mediump float alpha, mediump float oneMinusReflectivity,out mediump float modifiedAlpha)\r\n\t{\r\n\t\t// Transparency 'removes' from Diffuse component\r\n\t\tdiffColor *= alpha;\r\n\t\t// Reflectivity 'removes' from the rest of components, including Transparency\r\n\t\t// modifiedAlpha = 1.0-(1.0-alpha)*(1.0-reflectivity) = 1.0-(oneMinusReflectivity - alpha*oneMinusReflectivity) = 1.0-oneMinusReflectivity + alpha*oneMinusReflectivity\r\n\t\tmodifiedAlpha = 1.0 - oneMinusReflectivity + alpha*oneMinusReflectivity;\r\n\t\treturn diffColor;\r\n\t}\r\n#endif\r\n\r\nFragmentCommonData metallicSetup(vec2 uv)\r\n{\r\n\tmediump vec2 metallicGloss = metallicGloss(uv);\r\n\tmediump float metallic = metallicGloss.x;\r\n\tmediump float smoothness = metallicGloss.y; // this is 1 minus the square root of real roughness m.\r\n\tmediump float oneMinusReflectivity;\r\n\tmediump vec3 specColor;\r\n\tmediump vec3 diffColor = diffuseAndSpecularFromMetallic(albedo(uv), metallic,/*out*/specColor,/*out*/oneMinusReflectivity);\r\n\r\n\tFragmentCommonData o;\r\n\to.diffColor = diffColor;\r\n\to.specColor = specColor;\r\n\to.oneMinusReflectivity = oneMinusReflectivity;\r\n\to.smoothness = smoothness;\r\n\treturn o;\r\n}\r\n\r\nFragmentCommonData specularSetup(vec2 uv)\r\n{\r\n    mediump vec4 specGloss = specularGloss(uv);\r\n    mediump vec3 specColor = specGloss.rgb;\r\n    mediump float smoothness = specGloss.a;\r\n\r\n    mediump float oneMinusReflectivity;\r\n    mediump vec3 diffColor = energyConservationBetweenDiffuseAndSpecular (albedo(uv), specColor, /*out*/ oneMinusReflectivity);\r\n\r\n    FragmentCommonData o;\r\n    o.diffColor = diffColor;\r\n    o.specColor = specColor;\r\n    o.oneMinusReflectivity = oneMinusReflectivity;\r\n    o.smoothness = smoothness;\r\n    return o;\r\n}\r\n\r\nLayaGI fragmentGI(float smoothness,vec3 eyeVec,mediump float occlusion,mediump vec2 lightmapUV,vec3 worldnormal)\r\n{\r\n\tLayaGIInput giInput;\r\n\t#ifdef LIGHTMAP\r\n\t\tgiInput.lightmapUV=lightmapUV;\r\n\t#endif\r\n\r\n\tvec3 worldViewDir = -eyeVec;\r\n\tmediump vec4 uvwRoughness;\r\n\tuvwRoughness.rgb = reflect(worldViewDir, worldnormal);//reflectUVW\r\n\tuvwRoughness.a= smoothnessToPerceptualRoughness(smoothness);//perceptualRoughness\r\n\r\n\treturn layaGlobalIllumination(giInput,occlusion, worldnormal, uvwRoughness);\r\n}\r\n\r\n\r\nvec3 perPixelWorldNormal(vec2 uv,vec3 normal,vec3 binormal,vec3 tangent)\r\n{\r\n\t#ifdef NORMALTEXTURE\r\n\t\tmediump vec3 normalTangent=normalInTangentSpace(uv);\r\n\t\tvec3 normalWorld = normalize(tangent * normalTangent.x + binormal * normalTangent.y + normal * normalTangent.z);\r\n\t#else\r\n\t\tvec3 normalWorld = normalize(normal);\r\n\t#endif\r\n\t\treturn normalWorld;\r\n}\r\n\r\nvoid fragmentForward()\r\n{\r\n\tvec2 uv;\r\n\t#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\t\t#ifdef PARALLAXTEXTURE\r\n\t\t\tuv = parallax(v_Texcoord0,normalize(v_ViewDirForParallax));\r\n\t\t#else\r\n\t\t\tuv = v_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tmediump float alpha = alpha(uv);\r\n\t#ifdef ALPHATEST\r\n\t\tif(alpha<u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\r\n\tFragmentCommonData o = SETUP_BRDF_INPUT(uv);\r\n\t\r\n\tvec3 binormal;\r\n\tvec3 tangent;\r\n\t#ifdef NORMALTEXTURE\r\n\t\ttangent = v_Tangent;\r\n\t\tbinormal = v_Binormal;\r\n\t#endif\r\n\r\n\tvec3 normal = v_Normal;\r\n\tvec3 normalWorld = perPixelWorldNormal(uv,normal,binormal,tangent);//In FS if the normal use mediump before normalize will cause precision prolem in mobile device.\r\n\tvec3 eyeVec = normalize(v_EyeVec);\r\n\tvec3 posworld = v_PositionWorld;\r\n\r\n\t#ifdef TRANSPARENTBLEND\r\n\t\to.diffColor=preMultiplyAlpha(o.diffColor,alpha,o.oneMinusReflectivity,/*out*/alpha);// shader relies on pre-multiply alpha-blend (srcBlend = One, dstBlend = OneMinusSrcAlpha)\r\n\t#endif\r\n\r\n\tmediump float occlusion = occlusion(uv);\r\n\tmediump vec2 lightMapUV;\r\n\t#ifdef LIGHTMAP\r\n\t\tlightMapUV=v_LightMapUV;\r\n\t#endif\r\n\tfloat perceptualRoughness = smoothnessToPerceptualRoughness(o.smoothness);\r\n\tfloat roughness = perceptualRoughnessToRoughness(perceptualRoughness);\r\n\tfloat nv = abs(dot(normalWorld, eyeVec));\r\n\tLayaGI gi =fragmentGI(o.smoothness,eyeVec,occlusion,lightMapUV,normalWorld);\r\n\tvec4 color = LAYA_BRDF_GI(o.diffColor,o.specColor,o.oneMinusReflectivity,o.smoothness,perceptualRoughness,roughness,nv,normalWorld,eyeVec,gi);\r\n\t\r\n\t//Shadow\r\n\tfloat shadowValue = 1.0;\r\n\t#ifdef RECEIVESHADOW\r\n\t\t#ifdef SHADOWMAP_PSSM3\r\n\t\t\tshadowValue = getShadowPSSM3(u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\t#ifdef SHADOWMAP_PSSM2\r\n\t\t\tshadowValue = getShadowPSSM2(u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif \r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tshadowValue = getShadowPSSM1(u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t #ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tLayaLight dirLight = layaDirectionLightToLight(u_DirectionLight,shadowValue);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,dirLight);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tLayaLight poiLight = layaPointLightToLight(posworld,normalWorld,u_PointLight,shadowValue);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,poiLight);\r\n\t\t#endif\r\n\t\t\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t    LayaLight spoLight = layaSpotLightToLight(posworld,normalWorld,u_SpotLight,shadowValue);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,spoLight);\r\n\t\t#endif\r\n\t#else\r\n\t \t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\tLayaLight dirLight = layaDirectionLightToLight(directionLight,shadowValue);\r\n\t\t\t \tcolor+=LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,dirLight);\r\n\t\t\t}\r\n\t \t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaLight poiLight = layaPointLightToLight(posworld,normalWorld,pointLight,shadowValue);\r\n\t\t\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,poiLight);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaLight spoLight = layaSpotLightToLight(posworld,normalWorld,spotLight,shadowValue);\r\n\t\t\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,spoLight);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t #endif\r\n\r\n\t#ifdef EMISSION\r\n\t\tcolor.rgb += emission(uv);\r\n\t#endif\r\n\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\tcolor.rgb=mix(color.rgb,u_FogColor,lerpFact);\r\n\t#endif\r\n\t\r\n\tgl_FragColor=vec4(color.rgb,alpha);\r\n}\r\n\r\n\r\n",
        vi = "attribute vec4 a_Position;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nattribute vec3 a_Normal;\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(NORMALTEXTURE)||defined(PARALLAXTEXTURE)\r\n\tattribute vec4 a_Tangent0;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n    #ifdef PARALLAXTEXTURE\r\n\t    varying vec3 v_ViewDirForParallax;\r\n    #endif\r\n#endif\r\n\r\n#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#if defined(LIGHTMAP)&&defined(UV1)\r\n\tattribute vec2 a_Texcoord1;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\nuniform vec3 u_CameraPos;\r\nvarying vec3 v_EyeVec;\r\nvarying vec3 v_PositionWorld;\r\nvarying float v_posViewZ;\r\n\r\n#ifdef RECEIVESHADOW\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\tvarying vec4 v_lightMVPPos;\r\n\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif",
        xi = "#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n\tuniform float u_NormalScale;\r\n#endif\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n\r\n#ifdef METALLICGLOSSTEXTURE\r\n\tuniform sampler2D u_MetallicGlossTexture;\r\n#endif\r\nuniform float u_Metallic;\r\n\r\n#ifdef SPECULARGLOSSTEXTURE\r\n\tuniform sampler2D u_SpecGlossTexture;\r\n#endif\r\nuniform vec3 u_SpecularColor;\r\n\r\nuniform float u_Smoothness;\r\nuniform float u_SmoothnessScale;\r\n\r\n#ifdef PARALLAXTEXTURE\r\n\tuniform sampler2D u_ParallaxTexture;\r\n\tuniform float u_ParallaxScale;\r\n\tvarying vec3 v_ViewDirForParallax;\r\n#endif\r\n\r\n#ifdef OCCLUSIONTEXTURE\r\n\tuniform sampler2D u_OcclusionTexture;\r\n\tuniform float u_occlusionStrength;\r\n#endif\r\n\r\n#ifdef EMISSION \r\n\t#ifdef EMISSIONTEXTURE\r\n\t\tuniform sampler2D u_EmissionTexture;\r\n\t#endif\r\n\tuniform vec4 u_EmissionColor;\r\n#endif\r\n\r\n#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform sampler2D u_LightMap;\r\n#endif\r\n\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n#endif\r\n\r\nvarying vec3 v_EyeVec;\r\n\r\n#ifdef NORMALTEXTURE\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n\r\n//后面考虑宏TODO\r\nvarying vec3 v_PositionWorld;\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\n\r\n\r\nmediump float lerpOneTo(mediump float b, mediump float t)\r\n{\r\n    mediump float oneMinusT = 1.0 - t;\r\n    return oneMinusT + b * t;\r\n}\r\n\r\n#ifdef EMISSION \r\n\tvec3 emission(vec2 uv)\r\n\t{\r\n\t\t#ifdef EMISSIONTEXTURE\r\n\t\t\treturn texture2D(u_EmissionTexture, uv).rgb * u_EmissionColor.rgb;\r\n\t\t#else\r\n\t\t\treturn u_EmissionColor.rgb;\r\n\t\t#endif\r\n\t}\r\n#endif\r\n\r\nmediump float alpha(vec2 uv)\r\n{\r\n\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\treturn u_AlbedoColor.a;\r\n\t#else\r\n\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\treturn texture2D(u_AlbedoTexture, uv).a * u_AlbedoColor.a;\r\n\t\t#else\r\n\t\t\treturn u_AlbedoColor.a;\r\n\t\t#endif\r\n\t#endif\r\n}\r\n\r\nmediump float occlusion(vec2 uv)\r\n{\r\n\t#ifdef OCCLUSIONTEXTURE\r\n\t\tmediump float occ = texture2D(u_OcclusionTexture, uv).g;\r\n\t\treturn lerpOneTo(occ, u_occlusionStrength);\r\n\t#else\r\n\t\treturn 1.0;\r\n\t#endif\r\n}\r\n\r\nmediump vec3 albedo(vec2 uv)\r\n{\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\treturn u_AlbedoColor.rgb * texture2D(u_AlbedoTexture, uv).rgb;\r\n\t#else\r\n\t\treturn u_AlbedoColor.rgb;\r\n\t#endif\r\n\t//TODO:Detail Texture\r\n}\r\n\r\nmediump vec2 metallicGloss(vec2 uv)\r\n{\r\n\tmediump vec2 ms;//x is metallic,y is smoothness\r\n\t#ifdef METALLICGLOSSTEXTURE\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tms.x = texture2D(u_MetallicGlossTexture, uv).r;\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tms.y = texture2D(u_AlbedoTexture, uv).a*u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tms.y = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tms = texture2D(u_MetallicGlossTexture, uv).ra;\r\n\t\t\tms.y *= u_SmoothnessScale;\r\n\t\t#endif\r\n\t#else\r\n\t\tms.x = u_Metallic;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tms.y = texture2D(u_AlbedoTexture, uv).a * u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tms.y = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tms.y = u_Smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\treturn ms;\r\n}\r\n\r\nmediump vec4 specularGloss(vec2 uv)\r\n{\r\n\tmediump vec4 sg;\r\n\t#ifdef SPECULARGLOSSTEXTURE\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tsg.rgb = texture2D(u_SpecGlossTexture, uv).rgb;\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tsg.a = texture2D(u_AlbedoTexture, uv).a*u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tsg.a = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tsg = texture2D(u_SpecGlossTexture, uv);\r\n\t\t\tsg.a *= u_SmoothnessScale;\r\n\t\t#endif\r\n\t#else\r\n\t\tsg.rgb = u_SpecularColor.rgb;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tsg.a = texture2D(u_AlbedoTexture, uv).a * u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tsg.a = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tsg.a = u_Smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\t\treturn sg;\r\n}\r\n\r\n\r\n#ifdef NORMALTEXTURE\r\n\tmediump vec3 unpackScaleNormal(mediump vec3 packednormal, mediump float bumpScale)\r\n\t{\r\n\t\tmediump vec3 normal = packednormal.xyz * 2.0 - 1.0;\r\n\t\tnormal.y=-normal.y;//NOTE:because unity to LayaAir coordSystem.\r\n\t\tnormal.xy *= bumpScale;\r\n\t\treturn normal;\r\n\t}\r\n\t\r\n\tmediump vec3 normalInTangentSpace(vec2 texcoords)\r\n\t{\r\n\t\tmediump vec3 normalTangent = unpackScaleNormal(texture2D(u_NormalTexture, texcoords).rgb,u_NormalScale);\r\n\t\treturn normalTangent;\r\n\t}\r\n#endif\r\n\r\n#ifdef PARALLAXTEXTURE\r\n\tmediump vec2 parallaxOffset1Step(mediump float h, mediump float height, mediump vec3 viewDir)\r\n\t{\r\n\t\th = h * height - height / 2.0;\r\n\t\tviewDir.z += 0.42;\r\n\t\treturn h * (viewDir.xy / viewDir.z);\r\n\t}\r\n\r\n\tvec2 parallax(vec2 texcoords, mediump vec3 viewDir)\r\n\t{\r\n\t\tmediump float h = texture2D(u_ParallaxTexture, texcoords.xy).g;\r\n\t\tvec2 offset = parallaxOffset1Step(h, u_ParallaxScale, viewDir);\r\n\t\treturn texcoords+offset;\r\n\t}\r\n#endif\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        Ii = "void main_castShadow()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t//TODO没考虑UV动画呢\r\n\t#if defined(ALBEDOTEXTURE)&&defined(ALPHATEST)\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n\tv_posViewZ = gl_Position.z;\r\n}",
        Ai = "void main_castShadow()\r\n{\r\n\t//gl_FragColor=vec4(v_posViewZ,0.0,0.0,1.0);\r\n\tgl_FragColor=packDepth(v_posViewZ);\r\n\t#if defined(ALBEDOTEXTURE)&&defined(ALPHATEST)\r\n\t\tfloat alpha = texture2D(u_AlbedoTexture,v_Texcoord0).w;\r\n\t\tif( alpha < u_AlphaTestValue )\r\n\t\t{\r\n\t\t\tdiscard;\r\n\t\t}\r\n\t#endif\r\n}",
        Mi = "vec2 transformLightMapUV(in vec2 texcoord,in vec4 lightmapScaleOffset)\r\n{\r\n\tvec2 lightMapUV=vec2(texcoord.x,1.0-texcoord.y)*lightmapScaleOffset.xy+lightmapScaleOffset.zw;\r\n\tlightMapUV.y=1.0-lightMapUV.y;\r\n\treturn lightMapUV; \r\n}\r\n\r\nvoid vertexForward()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\r\n\tmat4 worldMat;\r\n\t#ifdef GPU_INSTANCE\r\n\t\tworldMat = a_WorldMat;\r\n\t#else\r\n\t\tworldMat = u_WorldMat;\r\n\t#endif\r\n\r\n\tv_PositionWorld=(worldMat*position).xyz;\r\n\r\n\t#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t\t#else\r\n\t\t\tv_Texcoord0=a_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tv_EyeVec =u_CameraPos-v_PositionWorld;//will normalize per-pixel\r\n\r\n\t#ifdef LIGHTMAP\r\n\t\tvec2 texcoord;\r\n\t\t#ifdef UV1\r\n\t\t\ttexcoord=a_Texcoord1;\r\n\t\t#else\r\n\t\t\ttexcoord=a_Texcoord0;\r\n\t\t#endif\r\n\t\tv_LightMapUV=transformLightMapUV(texcoord,u_LightmapScaleOffset);\r\n\t#endif\r\n\r\n\tmat3 worldInvMat;\r\n\t#ifdef BONE\r\n\t\tworldInvMat=inverseMat(mat3(worldMat*skinTransform));\r\n\t#else\r\n\t\tworldInvMat=inverseMat(mat3(worldMat));\r\n\t#endif\r\n\r\n\tv_Normal=normalize(a_Normal*worldInvMat);//if no normalize will cause precision problem.\r\n\r\n\t#ifdef NORMALTEXTURE\r\n\t\tv_Tangent=normalize(a_Tangent0.xyz*worldInvMat);\r\n\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t#endif\r\n\r\n\t#ifdef PARALLAXTEXTURE\r\n\t\tvec3 binormal = cross(a_Normal, a_Tangent0.xyz)*a_Tangent0.w;\r\n\t\tmat3 objectTBN = mat3(a_Tangent0.xyz, binormal, a_Normal);\r\n\t\tv_ViewDirForParallax=(worldInvMat*u_CameraPos-position.xyz)*objectTBN;\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1 \r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n}",
        Di = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}',
        Li = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample13();\r\n}',
        yi = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample4();\r\n}',
        Ci = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter13();\r\n}',
        Oi = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter4();\r\n}',
        Ni = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleBox() {\r\n\tmediump vec4 bloom = upsampleBox(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleBox();\r\n}',
        Pi = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleTent() {\r\n\tmediump vec4 bloom = upsampleTent(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleTent();\r\n}',
        bi = '#include "StdLib.glsl";\r\n\r\n#define EPSILON 1.0e-4\r\n\r\n// Quadratic color thresholding\r\n// curve = (threshold - knee, knee * 2, 0.25 / knee)\r\nmediump vec4 quadraticThreshold(mediump vec4 color, mediump float threshold, mediump vec3 curve) {\r\n\t// Pixel brightness\r\n\tmediump float br = max3(color.r, color.g, color.b);\r\n\r\n\t// Under-threshold part: quadratic curve\r\n\tmediump float rq = clamp(br - curve.x, 0.0, curve.y);\r\n\trq = curve.z * rq * rq;\r\n\r\n\t// Combine and apply the brightness response curve.\r\n\tcolor *= max(rq, br - threshold) / max(br, EPSILON);\r\n\r\n\treturn color;\r\n}\r\n\r\n\r\n\r\n//\r\n// sRGB transfer functions\r\n// Fast path ref: http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\r\n//\r\nmediump vec3 sRGBToLinear(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn c * c;\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);\r\n\t#else\r\n\t\tmediump vec3 linearRGBLo = c / 12.92;\r\n\t\tmediump vec3 power=vec3(2.4, 2.4, 2.4);\r\n\t\tmediump vec3 linearRGBHi = positivePow((c + 0.055) / 1.055, power);\r\n\t\tmediump vec3 linearRGB =vec3((c.r<=0.04045) ? linearRGBLo.r : linearRGBHi.r,(c.g<=0.04045) ? linearRGBLo.g : linearRGBHi.g,(c.b<=0.04045) ? linearRGBLo.b : linearRGBHi.b);\r\n\t\treturn linearRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 sRGBToLinear(mediump vec4 c){\r\n    return vec4(sRGBToLinear(c.rgb), c.a);\r\n}\r\n\r\n\r\n\r\nmediump vec3 linearToSRGB(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn sqrt(c);\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn max(1.055 * PositivePow(c, 0.416666667) - 0.055, 0.0);\r\n\t#else\r\n\t\tmediump vec3 sRGBLo = c * 12.92;\r\n\t\tmediump vec3 power=vec3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4);\r\n\t\tmediump vec3 sRGBHi = (positivePow(c, power) * 1.055) - 0.055;\r\n\t\tmediump vec3 sRGB =vec3((c.r<=0.0031308) ? sRGBLo.r : sRGBHi.r,(c.g<=0.0031308) ? sRGBLo.g : sRGBHi.g,(c.b<=0.0031308) ? sRGBLo.b : sRGBHi.b);\r\n\t\treturn sRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 linearToSRGB(mediump vec4 c){\r\n    return vec4(linearToSRGB(c.rgb), c.a);\r\n}',
        Vi = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform sampler2D u_Bloom_DirtTex;\r\nuniform vec4 u_BloomTex_TexelSize;\r\nuniform vec4 u_Bloom_DirtTileOffset; // xy: tiling, zw: offset\r\nuniform mediump vec3 u_Bloom_Settings;// x: sampleScale, y: intensity, z: dirt intensity\r\nuniform mediump vec3 u_Bloom_Color;\r\n\r\nvoid main() {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, v_Texcoord0).r;\r\n\tmediump vec4 color=vec4(0.0);\r\n\tcolor = texture2D(u_MainTex, v_Texcoord0);\r\n\t\r\n\tcolor = sRGBToLinear(color);\r\n\tcolor.rgb *= autoExposure;\r\n\t\r\n\t#if defined(BLOOM)||defined(BLOOM_LOW)\r\n\t\t#ifdef BLOOM\r\n\t\t\tmediump vec4 bloom = upsampleTent(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#else\r\n\t\t\tmediump vec4 bloom = upsampleBox(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#endif\r\n\r\n\t\t// UVs should be Distort(uv * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw)\r\n\t\t// but considering we use a cover-style scale on the dirt texture the difference\r\n\t\t// isn\'t massive so we chose to save a few ALUs here instead in case lens distortion\r\n\t\t// is active\r\n\t\tmediump vec4 dirt =vec4(texture2D(u_Bloom_DirtTex, v_Texcoord0 * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw).rgb, 0.0);\r\n\r\n\t\t// Additive bloom (artist friendly)\r\n\t\tbloom *= u_Bloom_Settings.y;\r\n\t\tdirt *= u_Bloom_Settings.z;\r\n\t\tmediump vec4 bloomColor=vec4(u_Bloom_Color, 1.0);\r\n\t\tcolor += bloom * bloomColor;\r\n\t\tcolor += dirt * bloom;\r\n\t#endif\r\n\t\r\n\tmediump vec4 finalColor = color;\r\n\tfinalColor = linearToSRGB(finalColor);\r\n\t//finalColor.rgb = Dither(finalColor.rgb, v_Texcoord0);//TODO:抖动\r\n\tgl_FragColor = finalColor;\r\n}',
        wi = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}',
        Fi = "// Better, temporally stable box filtering\r\n// [Jimenez14] http://goo.gl/eomGso\r\n// . . . . . . .\r\n// . A . B . C .\r\n// . . D . E . .\r\n// . F . G . H .\r\n// . . I . J . .\r\n// . K . L . M .\r\n// . . . . . . .\r\nmediump vec4 downsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    mediump vec4 A = texture2D(tex, uv + texelSize * vec2(-1.0, -1.0));\r\n    mediump vec4 B = texture2D(tex, uv + texelSize * vec2( 0.0, -1.0));\r\n    mediump vec4 C = texture2D(tex, uv + texelSize * vec2( 1.0, -1.0));\r\n    mediump vec4 D = texture2D(tex, uv + texelSize * vec2(-0.5, -0.5));\r\n    mediump vec4 E = texture2D(tex, uv + texelSize * vec2( 0.5, -0.5));\r\n    mediump vec4 F = texture2D(tex, uv + texelSize * vec2(-1.0,  0.0));\r\n    mediump vec4 G = texture2D(tex, uv);\r\n    mediump vec4 H = texture2D(tex, uv + texelSize * vec2( 1.0,  0.0));\r\n    mediump vec4 I = texture2D(tex, uv + texelSize * vec2(-0.5,  0.5));\r\n    mediump vec4 J = texture2D(tex, uv + texelSize * vec2( 0.5,  0.5));\r\n    mediump vec4 K = texture2D(tex, uv + texelSize * vec2(-1.0,  1.0));\r\n    mediump vec4 L = texture2D(tex, uv + texelSize * vec2( 0.0,  1.0));\r\n    mediump vec4 M = texture2D(tex, uv + texelSize * vec2( 1.0,  1.0));\r\n\r\n\tmediump vec2 scale= vec2(0.5, 0.125);\r\n    mediump vec2 div = (1.0 / 4.0) * scale;\r\n\r\n    mediump vec4 o = (D + E + I + J) * div.x;\r\n    o += (A + B + G + F) * div.y;\r\n    o += (B + C + H + G) * div.y;\r\n    o += (F + G + L + K) * div.y;\r\n    o += (G + H + M + L) * div.y;\r\n\r\n    return o;\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 downsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}\r\n\r\n// 9-tap bilinear upsampler (tent filter)\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\n// . 2 . 4 . 2 .\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\nmediump vec4 upsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv - d.xy);\r\n    s += texture2D(tex, uv - d.wy) * 2.0;\r\n    s += texture2D(tex, uv - d.zy);\r\n\r\n    s += texture2D(tex, uv + d.zw) * 2.0;\r\n    s += texture2D(tex, uv) * 4.0;\r\n    s += texture2D(tex,\tuv + d.xw) * 2.0;\r\n\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.wy) * 2.0;\r\n    s += texture2D(tex, uv + d.xy);\r\n\r\n    return s * (1.0 / 16.0);\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 upsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * 0.5 * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}",
        Bi = "#define HALF_MAX       65504.0 // (2 - 2^-10) * 2^15\r\n\r\n#define FLT_EPSILON    1.192092896e-07 // Smallest positive number, such that 1.0 + FLT_EPSILON != 1.0\r\n\r\nmediump vec4 safeHDR(mediump vec4 c)\r\n{\r\n    return min(c, HALF_MAX);\r\n}\r\n\r\nfloat max3(float a, float b, float c)\r\n{\r\n    return max(max(a, b), c);\r\n}\r\n\r\nvec3 positivePow(vec3 base, vec3 power)\r\n{\r\n    return pow(max(abs(base), vec3(FLT_EPSILON, FLT_EPSILON, FLT_EPSILON)), power);\r\n}",
        Ui = "uniform sampler2D u_shadowMap1;\r\nuniform sampler2D u_shadowMap2;\r\nuniform sampler2D u_shadowMap3;\r\nuniform vec2\t  u_shadowPCFoffset;\r\nuniform vec4     u_shadowPSSMDistance;\r\nvec4 packDepth(const in float depth)\r\n{\r\n\tconst vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\r\n\tconst vec4 bitMask\t= vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\r\n\tvec4 res = mod(depth*bitShift*vec4(255), vec4(256))/vec4(255);\r\n\tres -= res.xxyz * bitMask;\r\n\treturn res;\r\n}\r\nfloat unpackDepth(const in vec4 rgbaDepth)\r\n{\r\n\tconst vec4 bitShift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\r\n\tfloat depth = dot(rgbaDepth, bitShift);\r\n\treturn depth;\r\n}\r\nfloat tex2DPCF( sampler2D shadowMap,vec2 texcoord,vec2 invsize,float zRef )\r\n{\r\n\tvec2 texelpos =texcoord / invsize;\r\n\tvec2 lerps = fract( texelpos );\r\n\tfloat sourcevals[4];\r\n\tsourcevals[0] = float( unpackDepth(texture2D(shadowMap,texcoord)) > zRef );\r\n\tsourcevals[1] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x,0))) > zRef );\r\n\tsourcevals[2] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(0,invsize.y))) > zRef );\r\n\tsourcevals[3] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x, invsize.y) )) > zRef );\r\n\treturn mix( mix(sourcevals[0],sourcevals[2],lerps.y),mix(sourcevals[1],sourcevals[3],lerps.y),lerps.x );\r\n}\r\nfloat getShadowPSSM3( sampler2D shadowMap1,sampler2D shadowMap2,sampler2D shadowMap3,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\r\n{\r\n\tfloat value = 1.0;\r\n\tint nPSNum = int(posViewZ>pssmDistance.x);\r\n\tnPSNum += int(posViewZ>pssmDistance.y);\r\n\tnPSNum += int(posViewZ>pssmDistance.z);\r\n\t//真SB,webgl不支持在PS中直接访问数组\r\n\tmat4 lightVP;\r\n\tif( nPSNum == 0 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[1];\r\n\t}\r\n\telse if( nPSNum == 1 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[2];\r\n\t}\r\n\telse if( nPSNum == 2 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[3];\r\n\t}\r\n\tvec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\r\n\t//为了效率，在CPU计算/2.0 + 0.5\r\n\t//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\r\n\tvec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\r\n\tfloat fMyZ = vText.z - zBias;\r\n\t/*\r\n\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\r\n\tbool bInFrustum = all( bInFrustumVec );\r\n\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\r\n\tbool bFrustumTest = all( bFrustumTestVec );\r\n\tif ( bFrustumTest ) \r\n\t*/\r\n\tif( fMyZ <= 1.0 )\r\n\t{\r\n\t\tfloat zdepth=0.0;\r\n#ifdef SHADOWMAP_PCF3\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue = value/4.0;\r\n\t\t} \r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF2\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n\r\n#endif\r\n#ifdef SHADOWMAP_PCF1\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap2,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF_NO\r\n\t\tvec4 color;\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap1,vText.xy );\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap2,vText.xy );\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap3,vText.xy );\r\n\t\t}\r\n\t\tzdepth = unpackDepth(color);\r\n\t\tvalue = float(fMyZ < zdepth);\r\n#endif\r\n\t}\r\n\treturn value;\r\n}\r\nfloat getShadowPSSM2( sampler2D shadowMap1,sampler2D shadowMap2,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\r\n{\r\n\tfloat value = 1.0;\r\n\tint nPSNum = int(posViewZ>pssmDistance.x);\r\n\tnPSNum += int(posViewZ>pssmDistance.y);\r\n\t//真SB,webgl不支持在PS中直接访问数组\r\n\tmat4 lightVP;\r\n\tif( nPSNum == 0 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[1];\r\n\t}\r\n\telse if( nPSNum == 1 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[2];\r\n\t}\r\n\tvec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\r\n\t//为了效率，在CPU计算/2.0 + 0.5\r\n\t//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\r\n\tvec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\r\n\tfloat fMyZ = vText.z - zBias;\r\n\t/*\r\n\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\r\n\tbool bInFrustum = all( bInFrustumVec );\r\n\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\r\n\tbool bFrustumTest = all( bFrustumTestVec );\r\n\tif ( bFrustumTest ) \r\n\t*/\r\n\tif( fMyZ <= 1.0 )\r\n\t{\r\n\t\tfloat zdepth=0.0;\r\n#ifdef SHADOWMAP_PCF3\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue = value/4.0;\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF2\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF1\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap2,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF_NO\r\n\t\tvec4 color;\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap1,vText.xy );\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap2,vText.xy );\r\n\t\t}\r\n\t\tzdepth = unpackDepth(color);\r\n\t\tvalue = float(fMyZ < zdepth);\r\n#endif\r\n\t}\r\n\treturn value;\r\n}\r\nfloat getShadowPSSM1( sampler2D shadowMap1,vec4 lightMVPPos,vec4 pssmDistance,vec2 shadowPCFOffset,float posViewZ,float zBias )\r\n{\r\n\tfloat value = 1.0;\r\n\tif( posViewZ < pssmDistance.x )\r\n\t{\r\n\t\tvec3 vText = lightMVPPos.xyz / lightMVPPos.w;\r\n\t\tfloat fMyZ = vText.z - zBias;\r\n\t\t/*\r\n\t\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\r\n\t\tbool bInFrustum = all( bInFrustumVec );\r\n\t\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\r\n\t\tbool bFrustumTest = all( bFrustumTestVec );\r\n\t\t*/\r\n\t\tif ( fMyZ <= 1.0 ) \r\n\t\t{\r\n\t\t\tfloat zdepth=0.0;\r\n#ifdef SHADOWMAP_PCF3\r\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,fMyZ );\r\n\t\t\tvalue = value/4.0;\r\n#endif\r\n#ifdef SHADOWMAP_PCF2\t\t\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n#endif\r\n#ifdef SHADOWMAP_PCF1\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n#endif\r\n#ifdef SHADOWMAP_PCF_NO\t\t\r\n\t\t\tvec4 color = texture2D( shadowMap1,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n#endif\r\n\t\t}\r\n\t}\r\n\treturn value;\r\n}",
        Gi = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec3 v_Texcoord;\r\n\r\nuniform samplerCube u_CubeTexture;\r\nuniform float u_Exposure;\r\nuniform vec4 u_TintColor;\r\n\r\n\r\nvoid main()\r\n{\t\r\n\tvec3 color=textureCube(u_CubeTexture, v_Texcoord).rgb*u_TintColor.rgb*u_Exposure*2.0;\r\n\tgl_FragColor=vec4(color,1.0);\r\n}\r\n\r\n",
        zi = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_ViewProjection;\r\nuniform float u_Rotation;\r\nvarying vec3 v_Texcoord;\r\n\r\n\r\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\r\n{\r\n\tfloat angle = degrees * 3.141593 / 180.0;\r\n\tfloat sina=sin(angle);\r\n\tfloat cosa=cos(angle);\r\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\r\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\r\n}\r\n\t\t\r\nvoid main()\r\n{\r\n\tvec4 position=rotateAroundYInDegrees(a_Position,u_Rotation);\r\n\tgl_Position = u_ViewProjection*position;\r\n\tv_Texcoord=vec3(-a_Position.x,a_Position.yz);//转换坐标系\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n',
        Hi = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\nconst float MIE_G = -0.990;\r\nconst float MIE_G2 = 0.9801;\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\n\r\nuniform float u_SunSize;\r\nuniform float u_SunSizeConvergence;\r\nuniform DirectionLight u_SunLight;\r\n\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Mie phase function\r\nfloat getMiePhase(float eyeCos, float eyeCos2) {\r\n\tfloat temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;\r\n\ttemp = pow(temp, pow(u_SunSize,0.65) * 10.0);\r\n\ttemp = max(temp,1.0e-4); // prevent division by zero, esp. in half precision\r\n\ttemp = 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;\r\n\treturn temp;\r\n}\r\n\r\n// Calculates the sun shape\r\nfloat calcSunAttenuation(vec3 lightPos, vec3 ray) {\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tfloat focusedEyeCos = pow(clamp(dot(lightPos, ray),0.0,1.0), u_SunSizeConvergence);\r\n\t\treturn getMiePhase(-focusedEyeCos, focusedEyeCos * focusedEyeCos);\r\n\t#else //SUN_SIMPLE\r\n\t\tvec3 delta = lightPos - ray;\r\n\t\tfloat dist = length(delta);\r\n\t\tfloat spot = 1.0 - smoothstep(0.0, u_SunSize, dist);\r\n\t\treturn spot * spot;\r\n\t#endif\r\n}\r\n\r\nvoid main() {\r\n\t// if y > 1 [eyeRay.y < -SKY_GROUND_THRESHOLD] - ground\r\n\t// if y >= 0 and < 1 [eyeRay.y <= 0 and > -SKY_GROUND_THRESHOLD] - horizon\r\n\t// if y < 0 [eyeRay.y > 0] - sky\r\n\tvec3 col = vec3(0.0, 0.0, 0.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tvec3 ray = normalize(v_Vertex);\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tvec3 ray = v_RayDir;\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\t\r\n\t#else\r\n\t\tfloat y = v_SkyGroundFactor;\r\n\t#endif\r\n\r\n\t// if we did precalculate color in vprog: just do lerp between them\r\n\tcol = mix(v_SkyColor, v_GroundColor, clamp(y,0.0,1.0));\r\n\r\n\t#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\t\tif (y < 0.0)\r\n\t\t\tcol += v_SunColor * calcSunAttenuation(-u_SunLight.direction, -ray);\r\n\t#endif\r\n\r\n\tcol = sqrt(col);//linear space convert to gamma space\r\n\tgl_FragColor=vec4(col,1.0);\r\n}\r\n\r\n',
        ki = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Lighting.glsl\";\r\n\r\n#define OUTER_RADIUS 1.025\r\n#define RAYLEIGH (mix(0.0, 0.0025, pow(u_AtmosphereThickness,2.5)))// Rayleigh constant Rayleigh为夜空光和极光亮度单位\r\n#define MIE 0.0010             // Mie constant 米氏散射\r\n#define SUN_BRIGHTNESS 20.0    // Sun brightness\r\n#define MAX_SCATTER 50.0 // Maximum scattering value, to prevent math overflows on Adrenos\r\n\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\nconst float outerRadius = OUTER_RADIUS;\r\nconst float outerRadius2 = OUTER_RADIUS*OUTER_RADIUS;\r\nconst float innerRadius = 1.0;\r\nconst float innerRadius2 = 1.0;\r\nconst float cameraHeight = 0.0001;\r\n\r\nconst float HDSundiskIntensityFactor = 15.0;\r\nconst float simpleSundiskIntensityFactor = 27.0;\r\n\r\nconst float sunScale = 400.0 * SUN_BRIGHTNESS;\r\nconst float kmESun = MIE * SUN_BRIGHTNESS;\r\nconst float km4PI = MIE * 4.0 * 3.14159265;\r\nconst float scale = 1.0 / (OUTER_RADIUS - 1.0);\r\nconst float scaleDepth = 0.25;\r\nconst float scaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;\r\nconst float samples = 2.0; // THIS IS UNROLLED MANUALLY, DON'T TOUCH\r\n\r\n// RGB wavelengths        .35 (.62=158), .43 (.68=174), .525 (.75=190)\r\nconst vec3 c_DefaultScatteringWavelength = vec3(0.65, 0.57, 0.475);//默认散射波长\r\nconst vec3 c_VariableRangeForScatteringWavelength = vec3(0.15, 0.15, 0.15);//散射播放的可变范围\r\n\r\nattribute vec4 a_Position;\r\n\r\nuniform mat4 u_ViewProjection;\r\nuniform vec3 u_SkyTint;\r\nuniform vec3 u_GroundTint;\r\nuniform float u_Exposure;\r\nuniform float u_AtmosphereThickness;\r\nuniform DirectionLight u_SunLight;\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Rayleigh phase function\r\nfloat getRayleighPhase(vec3 light, vec3 ray) \r\n{\r\n\tfloat eyeCos = dot(light, ray);\r\n\treturn 0.75 + 0.75*eyeCos*eyeCos;\r\n}\r\n\r\nfloat scaleAngle(float inCos)\r\n{\r\n\tfloat x = 1.0 - inCos;\r\n\treturn 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\r\n}\r\n\r\n\r\nvoid main () {\r\n\tgl_Position = u_ViewProjection*a_Position;\r\n\r\n\tvec3 skyTintInGammaSpace = u_SkyTint;//支持非GAMMA空间后要调整\r\n\tvec3 scatteringWavelength = mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0) - skyTintInGammaSpace); // using Tint in sRGB+ gamma allows for more visually linear interpolation and to keep (0.5) at (128, gray in sRGB) point\r\n\tvec3 invWavelength = 1.0 / pow(scatteringWavelength, vec3(4.0));\r\n\r\n\tfloat krESun = RAYLEIGH * SUN_BRIGHTNESS;\r\n\tfloat kr4PI = RAYLEIGH * 4.0 * 3.14159265;\r\n\r\n\tvec3 cameraPos = vec3(0.0,innerRadius + cameraHeight,0.0); // The camera's current position\r\n\r\n\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\r\n\tvec3 eyeRay = normalize(a_Position.xyz);\r\n\r\n\tfloat far = 0.0;\r\n\tvec3 cIn, cOut;\r\n\tif (eyeRay.y >= 0.0) {// Sky\r\n\t\t// Calculate the length of the \"atmosphere\"\r\n\t\tfar = sqrt(outerRadius2 + innerRadius2 * eyeRay.y * eyeRay.y - innerRadius2) - innerRadius * eyeRay.y;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat height = innerRadius + cameraHeight;\r\n\t\tfloat depth = exp(scaleOverScaleDepth * -cameraHeight);\r\n\t\tfloat startAngle = dot(eyeRay, cameraPos) / height;\r\n\t\tfloat startOffset = depth*scaleAngle(startAngle);\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\tvec3 frontColor = vec3(0.0);\r\n\t\t//unrolling this manually to avoid some platform for loop slow\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_SunLight.direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_SunLight.direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\t// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\r\n\t\tcIn = frontColor * (invWavelength * krESun);\r\n\t\tcOut = frontColor * kmESun;\r\n\t} else {// Ground\r\n\t\tfar = (-cameraHeight) / (min(-0.001, eyeRay.y));\r\n\t\tvec3 pos = cameraPos + far * eyeRay;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat depth = exp((-cameraHeight) * (1.0/scaleDepth));\r\n\t\tfloat cameraAngle = dot(-eyeRay, pos);\r\n\t\tfloat lightAngle = dot(-u_SunLight.direction, pos);\r\n\t\tfloat cameraScale = scaleAngle(cameraAngle);\r\n\t\tfloat lightScale = scaleAngle(lightAngle);\r\n\t\tfloat cameraOffset = depth*cameraScale;\r\n\t\tfloat temp = lightScale + cameraScale;\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\t// Now loop through the sample rays\r\n\t\tvec3 frontColor = vec3(0.0, 0.0, 0.0);\r\n\t\tvec3 attenuate;\r\n\r\n\t\t// Loop removed because we kept hitting SM2.0 temp variable limits. Doesn't affect the image too much.\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat scatter = depth*temp - cameraOffset;\r\n\t\t\tattenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\tcIn = frontColor * (invWavelength * krESun + kmESun);\r\n\t\tcOut = clamp(attenuate, 0.0, 1.0);\r\n\t}\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tv_Vertex = -a_Position.xyz;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_RayDir = -eyeRay;\r\n\t#else\r\n\t\tv_SkyGroundFactor = -eyeRay.y / SKY_GROUND_THRESHOLD;\r\n\t#endif\r\n\r\n\t// if we want to calculate color in vprog:\r\n\t// in case of linear: multiply by _Exposure in here (even in case of lerp it will be common multiplier, so we can skip mul in fshader)\r\n\tv_GroundColor = u_Exposure * (cIn + u_GroundTint*u_GroundTint * cOut);//u_GroundColor*u_GroundColor is gamma space convert to linear space\r\n\tv_SkyColor    = u_Exposure * (cIn * getRayleighPhase(-u_SunLight.direction, -eyeRay));\r\n\r\n\t\r\n\t// The sun should have a stable intensity in its course in the sky. Moreover it should match the highlight of a purely specular material.\r\n\t// This matching was done using the Unity3D standard shader BRDF1 on the 5/31/2017\r\n\t// Finally we want the sun to be always bright even in LDR thus the normalization of the lightColor for low intensity.\r\n\tfloat lightColorIntensity = clamp(length(u_SunLight.color), 0.25, 1.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY \r\n\t\tv_SunColor = HDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * u_SunLight.color / lightColorIntensity;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_SunColor = simpleSundiskIntensityFactor * clamp(cOut * sunScale,0.0,1.0) * u_SunLight.color / lightColorIntensity;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n",
        Wi = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTexture;\r\nuniform vec4 u_MainColor;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nvoid main()\r\n{\r\n\tvec4 color = 2.0 * u_MainColor * v_Color;\r\n\t#ifdef MAINTEXTURE\r\n\t\tvec4 mainTextureColor = texture2D(u_MainTexture, v_Texcoord0);\r\n\t\tcolor *= mainTextureColor;\r\n\t#endif\r\n\tgl_FragColor = color;\r\n}\r\n\r\n     ",
        Xi = '#include "Lighting.glsl";\r\n\r\nattribute vec3 a_Position;\r\nattribute vec3 a_OffsetVector;\r\nattribute vec4 a_Color;\r\nattribute float a_Texcoord0X;\r\nattribute float a_Texcoord0Y;\r\nattribute float a_BirthTime;\r\n\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\nuniform vec4 u_TilingOffset;\r\n\r\nuniform float u_CurTime;\r\nuniform float u_LifeTime;\r\nuniform vec4 u_WidthCurve[10];\r\nuniform int u_WidthCurveKeyLength;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nfloat hermiteInterpolate(float t, float outTangent, float inTangent, float duration, float value1, float value2)\r\n{\r\n\tfloat t2 = t * t;\r\n\tfloat t3 = t2 * t;\r\n\tfloat a = 2.0 * t3 - 3.0 * t2 + 1.0;\r\n\tfloat b = t3 - 2.0 * t2 + t;\r\n\tfloat c = t3 - t2;\r\n\tfloat d = -2.0 * t3 + 3.0 * t2;\r\n\treturn a * value1 + b * outTangent * duration + c * inTangent * duration + d * value2;\r\n}\r\n\r\nfloat getCurWidth(in float normalizeTime)\r\n{\r\n\tfloat width;\r\n\tif(normalizeTime == 0.0){\r\n\t\twidth=u_WidthCurve[0].w;\r\n\t}\r\n\telse if(normalizeTime >= 1.0){\r\n\t\twidth=u_WidthCurve[u_WidthCurveKeyLength - 1].w;\r\n\t}\r\n\telse{\r\n\t\tfor(int i = 0; i < 10; i ++ )\r\n\t\t{\r\n\t\t\tif(normalizeTime == u_WidthCurve[i].x){\r\n\t\t\t\twidth=u_WidthCurve[i].w;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvec4 lastFrame = u_WidthCurve[i];\r\n\t\t\tvec4 nextFrame = u_WidthCurve[i + 1];\r\n\t\t\tif(normalizeTime > lastFrame.x && normalizeTime < nextFrame.x)\r\n\t\t\t{\r\n\t\t\t\tfloat duration = nextFrame.x - lastFrame.x;\r\n\t\t\t\tfloat t = (normalizeTime - lastFrame.x) / duration;\r\n\t\t\t\tfloat outTangent = lastFrame.z;\r\n\t\t\t\tfloat inTangent = nextFrame.y;\r\n\t\t\t\tfloat value1 = lastFrame.w;\r\n\t\t\t\tfloat value2 = nextFrame.w;\r\n\t\t\t\twidth=hermiteInterpolate(t, outTangent, inTangent, duration, value1, value2);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn width;\r\n}\t\r\n\r\nvoid main()\r\n{\r\n\tfloat normalizeTime = (u_CurTime - a_BirthTime) / u_LifeTime;\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, 1.0 - a_Texcoord0Y) * u_TilingOffset.xy + u_TilingOffset.zw;\r\n\t#else\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, a_Texcoord0Y);\r\n\t#endif\r\n\t\r\n\tv_Color = a_Color;\r\n\t\r\n\tgl_Position = u_Projection * u_View * vec4(a_Position + a_OffsetVector * getCurWidth(normalizeTime),1.0);\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n',
        Yi = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  u_AlbedoColor;\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t\r\n\t#ifdef ALPHATEST\r\n\t\tif(color.a < u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n}\r\n\r\n",
        Zi = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\n\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main() {\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
        ji = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_MainTexture;\r\n#endif\r\n\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n#endif\r\n\r\nuniform vec4 u_HorizonColor;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\n\r\n#include "Lighting.glsl"\r\n\r\n\r\n\r\nvec3 NormalSampleToWorldSpace(vec4 normalMapSample) {\r\n\tvec3 normalT;\r\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\r\n\tvec3 bumpedNormal = normalize(normalT);\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\n\tvec4 bumpColor1 = texture2D(u_NormalTexture, v_Texcoord0);\r\n\tvec4 bumpColor2 = texture2D(u_NormalTexture, v_Texcoord1);\r\n\r\n\tvec3 normal1 = NormalSampleToWorldSpace(bumpColor1);\r\n\tvec3 normal2 = NormalSampleToWorldSpace(bumpColor2);\r\n\t\r\n\tvec3 normal = normalize((normal1 + normal2) * 0.5);\r\n\tvec3 viewDir = normalize(v_ViewDir);\r\n\tfloat fresnel = dot(viewDir, normal);\r\n\t\r\n\tvec4 waterColor = texture2D(u_MainTexture, vec2(fresnel, fresnel));\r\n\t\r\n\tvec4 color;\r\n\tcolor.rgb = mix(waterColor.rgb, u_HorizonColor.rgb, vec3(waterColor.a));\r\n\tcolor.a = u_HorizonColor.a;\r\n\t\r\n\tgl_FragColor = color;\r\n}\r\n\r\n\r\n',
        qi = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\nattribute vec4 a_Tangent0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\nuniform mat4 u_WorldMat;\r\nuniform vec3 u_CameraPos;\r\nuniform float u_WaveScale;\r\nuniform vec4 u_WaveSpeed;\r\nuniform float u_Time;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionWorld = u_WorldMat * a_Position;\r\n\tvec4 position = u_MvpMatrix * a_Position;\r\n\t\r\n\tvec4 temp = vec4(positionWorld.x, positionWorld.z, positionWorld.x, positionWorld.z) * u_WaveScale + u_WaveSpeed * u_WaveScale * u_Time;\r\n\t\r\n\tv_Texcoord0 = temp.xy * vec2(0.4, 0.45);\r\n\tv_Texcoord1 = temp.wz;\r\n\t\r\n\tmat3 worldMat = mat3(u_WorldMat);\r\n\tv_Normal = worldMat * a_Normal;\r\n\tv_Tangent = worldMat * a_Tangent0.xyz;\r\n\tv_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\r\n\t\r\n\tv_ViewDir = u_CameraPos - positionWorld.xyz;\r\n\tgl_Position = position;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}';
    var Qi = /* */ function() {
        function Qi() {
            _classCallCheck(this, Qi);
        }
        _createClass(Qi, null, [{
            key: "__init__",
            value: function __init__() {
                H.SHADERDEFINE_LEGACYSINGALLIGHTING = H.getDefineByName("LEGACYSINGLELIGHTING"),
                    H.addInclude("Lighting.glsl", ui), H.addInclude("GlobalIllumination.glsl", di),
                    H.addInclude("ShadowHelper.glsl", Ui), H.addInclude("Colors.glsl", bi), H.addInclude("Sampling.glsl", Fi),
                    H.addInclude("StdLib.glsl", Bi), H.addInclude("PBRVSInput.glsl", vi), H.addInclude("PBRFSInput.glsl", xi),
                    H.addInclude("PBRVSShadow.glsl", Ii), H.addInclude("PBRFSShadow.glsl", Ai), H.addInclude("LayaPBRBRDF.glsl", Si),
                    H.addInclude("PBRCore.glsl", Ri), H.addInclude("PBRVertex.glsl", Mi);
                var e = {
                        a_Position: ce.MESH_POSITION0,
                        a_Color: ce.MESH_COLOR0,
                        a_Normal: ce.MESH_NORMAL0,
                        a_Texcoord0: ce.MESH_TEXTURECOORDINATE0,
                        a_Texcoord1: ce.MESH_TEXTURECOORDINATE1,
                        a_BoneWeights: ce.MESH_BLENDWEIGHT0,
                        a_BoneIndices: ce.MESH_BLENDINDICES0,
                        a_Tangent0: ce.MESH_TANGENT0,
                        a_MvpMatrix: ce.MESH_MVPMATRIX_ROW0,
                        a_WorldMat: ce.MESH_WORLDMATRIX_ROW0
                    },
                    t = {
                        u_Bones: H.PERIOD_CUSTOM,
                        u_DiffuseTexture: H.PERIOD_MATERIAL,
                        u_SpecularTexture: H.PERIOD_MATERIAL,
                        u_NormalTexture: H.PERIOD_MATERIAL,
                        u_AlphaTestValue: H.PERIOD_MATERIAL,
                        u_DiffuseColor: H.PERIOD_MATERIAL,
                        u_MaterialSpecular: H.PERIOD_MATERIAL,
                        u_Shininess: H.PERIOD_MATERIAL,
                        u_TilingOffset: H.PERIOD_MATERIAL,
                        u_WorldMat: H.PERIOD_SPRITE,
                        u_MvpMatrix: H.PERIOD_SPRITE,
                        u_LightmapScaleOffset: H.PERIOD_SPRITE,
                        u_LightMap: H.PERIOD_SPRITE,
                        u_CameraPos: H.PERIOD_CAMERA,
                        u_Viewport: H.PERIOD_CAMERA,
                        u_ProjectionParams: H.PERIOD_CAMERA,
                        u_View: H.PERIOD_CAMERA,
                        u_ReflectTexture: H.PERIOD_SCENE,
                        u_ReflectIntensity: H.PERIOD_SCENE,
                        u_FogStart: H.PERIOD_SCENE,
                        u_FogRange: H.PERIOD_SCENE,
                        u_FogColor: H.PERIOD_SCENE,
                        u_DirationLightCount: H.PERIOD_SCENE,
                        u_LightBuffer: H.PERIOD_SCENE,
                        u_LightClusterBuffer: H.PERIOD_SCENE,
                        u_AmbientColor: H.PERIOD_SCENE,
                        u_shadowMap1: H.PERIOD_SCENE,
                        u_shadowMap2: H.PERIOD_SCENE,
                        u_shadowMap3: H.PERIOD_SCENE,
                        u_shadowPSSMDistance: H.PERIOD_SCENE,
                        u_lightShadowVP: H.PERIOD_SCENE,
                        u_shadowPCFoffset: H.PERIOD_SCENE,
                        u_AmbientSHAr: H.PERIOD_SCENE,
                        u_AmbientSHAg: H.PERIOD_SCENE,
                        u_AmbientSHAb: H.PERIOD_SCENE,
                        u_AmbientSHBr: H.PERIOD_SCENE,
                        u_AmbientSHBg: H.PERIOD_SCENE,
                        u_AmbientSHBb: H.PERIOD_SCENE,
                        u_AmbientSHC: H.PERIOD_SCENE,
                        "u_DirectionLight.color": H.PERIOD_SCENE,
                        "u_DirectionLight.direction": H.PERIOD_SCENE,
                        "u_PointLight.position": H.PERIOD_SCENE,
                        "u_PointLight.range": H.PERIOD_SCENE,
                        "u_PointLight.color": H.PERIOD_SCENE,
                        "u_SpotLight.position": H.PERIOD_SCENE,
                        "u_SpotLight.direction": H.PERIOD_SCENE,
                        "u_SpotLight.range": H.PERIOD_SCENE,
                        "u_SpotLight.spot": H.PERIOD_SCENE,
                        "u_SpotLight.color": H.PERIOD_SCENE
                    },
                    r = {
                        s_Cull: H.RENDER_STATE_CULL,
                        s_Blend: H.RENDER_STATE_BLEND,
                        s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                        s_BlendDst: H.RENDER_STATE_BLEND_DST,
                        s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                        s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
                    },
                    i = H.add("BLINNPHONG", null, null, !0),
                    a = new oe(e, t);
                i.addSubShader(a), a.addShaderPass(Ti, Ei, r), e = {
                        a_Position: ce.MESH_POSITION0,
                        a_Color: ce.MESH_COLOR0
                    }, t = {
                        u_MvpMatrix: H.PERIOD_SPRITE,
                        u_Color: H.PERIOD_MATERIAL
                    }, r = {
                        s_Cull: H.RENDER_STATE_CULL,
                        s_Blend: H.RENDER_STATE_BLEND,
                        s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                        s_BlendDst: H.RENDER_STATE_BLEND_DST,
                        s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                        s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
                    }, i = H.add("LineShader"), a = new oe(e, t), i.addSubShader(a), a.addShaderPass(fi, mi, r),
                    e = {
                        a_Position: ce.MESH_POSITION0,
                        a_Color: ce.MESH_COLOR0,
                        a_Texcoord0: ce.MESH_TEXTURECOORDINATE0,
                        a_BoneWeights: ce.MESH_BLENDWEIGHT0,
                        a_BoneIndices: ce.MESH_BLENDINDICES0,
                        a_MvpMatrix: ce.MESH_MVPMATRIX_ROW0
                    }, t = {
                        u_Bones: H.PERIOD_CUSTOM,
                        u_AlbedoTexture: H.PERIOD_MATERIAL,
                        u_AlbedoColor: H.PERIOD_MATERIAL,
                        u_TilingOffset: H.PERIOD_MATERIAL,
                        u_AlphaTestValue: H.PERIOD_MATERIAL,
                        u_MvpMatrix: H.PERIOD_SPRITE,
                        u_FogStart: H.PERIOD_SCENE,
                        u_FogRange: H.PERIOD_SCENE,
                        u_FogColor: H.PERIOD_SCENE
                    }, r = {
                        s_Cull: H.RENDER_STATE_CULL,
                        s_Blend: H.RENDER_STATE_BLEND,
                        s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                        s_BlendDst: H.RENDER_STATE_BLEND_DST,
                        s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                        s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
                    }, i = H.add("Unlit", null, null, !0), a = new oe(e, t), i.addSubShader(a), a.addShaderPass(Zi, Yi, r),
                    e = {
                        a_Position: ce.MESH_POSITION0,
                        a_Texcoord0: ce.MESH_TEXTURECOORDINATE0,
                        a_BoneWeights: ce.MESH_BLENDWEIGHT0,
                        a_BoneIndices: ce.MESH_BLENDINDICES0,
                        a_MvpMatrix: ce.MESH_MVPMATRIX_ROW0
                    }, t = {
                        u_Bones: H.PERIOD_CUSTOM,
                        u_AlbedoTexture: H.PERIOD_MATERIAL,
                        u_AlbedoColor: H.PERIOD_MATERIAL,
                        u_TilingOffset: H.PERIOD_MATERIAL,
                        u_AlphaTestValue: H.PERIOD_MATERIAL,
                        u_MvpMatrix: H.PERIOD_SPRITE,
                        u_FogStart: H.PERIOD_SCENE,
                        u_FogRange: H.PERIOD_SCENE,
                        u_FogColor: H.PERIOD_SCENE
                    }, r = {
                        s_Cull: H.RENDER_STATE_CULL,
                        s_Blend: H.RENDER_STATE_BLEND,
                        s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                        s_BlendDst: H.RENDER_STATE_BLEND_DST,
                        s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                        s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
                    }, i = H.add("Effect", null, null, !0), a = new oe(e, t), i.addSubShader(a), a.addShaderPass(_i, li, r),
                    e = {
                        a_CornerTextureCoordinate: Zt.PARTICLE_CORNERTEXTURECOORDINATE0,
                        a_MeshPosition: Zt.PARTICLE_POSITION0,
                        a_MeshColor: Zt.PARTICLE_COLOR0,
                        a_MeshTextureCoordinate: Zt.PARTICLE_TEXTURECOORDINATE0,
                        a_ShapePositionStartLifeTime: Zt.PARTICLE_SHAPEPOSITIONSTARTLIFETIME,
                        a_DirectionTime: Zt.PARTICLE_DIRECTIONTIME,
                        a_StartColor: Zt.PARTICLE_STARTCOLOR0,
                        a_EndColor: Zt.PARTICLE_ENDCOLOR0,
                        a_StartSize: Zt.PARTICLE_STARTSIZE,
                        a_StartRotation0: Zt.PARTICLE_STARTROTATION,
                        a_StartSpeed: Zt.PARTICLE_STARTSPEED,
                        a_Random0: Zt.PARTICLE_RANDOM0,
                        a_Random1: Zt.PARTICLE_RANDOM1,
                        a_SimulationWorldPostion: Zt.PARTICLE_SIMULATIONWORLDPOSTION,
                        a_SimulationWorldRotation: Zt.PARTICLE_SIMULATIONWORLDROTATION
                    }, t = {
                        u_Tintcolor: H.PERIOD_MATERIAL,
                        u_TilingOffset: H.PERIOD_MATERIAL,
                        u_texture: H.PERIOD_MATERIAL,
                        u_WorldPosition: H.PERIOD_SPRITE,
                        u_WorldRotation: H.PERIOD_SPRITE,
                        u_PositionScale: H.PERIOD_SPRITE,
                        u_SizeScale: H.PERIOD_SPRITE,
                        u_ScalingMode: H.PERIOD_SPRITE,
                        u_Gravity: H.PERIOD_SPRITE,
                        u_ThreeDStartRotation: H.PERIOD_SPRITE,
                        u_StretchedBillboardLengthScale: H.PERIOD_SPRITE,
                        u_StretchedBillboardSpeedScale: H.PERIOD_SPRITE,
                        u_SimulationSpace: H.PERIOD_SPRITE,
                        u_CurrentTime: H.PERIOD_SPRITE,
                        u_ColorOverLifeGradientAlphas: H.PERIOD_SPRITE,
                        u_ColorOverLifeGradientColors: H.PERIOD_SPRITE,
                        u_MaxColorOverLifeGradientAlphas: H.PERIOD_SPRITE,
                        u_MaxColorOverLifeGradientColors: H.PERIOD_SPRITE,
                        u_VOLVelocityConst: H.PERIOD_SPRITE,
                        u_VOLVelocityGradientX: H.PERIOD_SPRITE,
                        u_VOLVelocityGradientY: H.PERIOD_SPRITE,
                        u_VOLVelocityGradientZ: H.PERIOD_SPRITE,
                        u_VOLVelocityConstMax: H.PERIOD_SPRITE,
                        u_VOLVelocityGradientMaxX: H.PERIOD_SPRITE,
                        u_VOLVelocityGradientMaxY: H.PERIOD_SPRITE,
                        u_VOLVelocityGradientMaxZ: H.PERIOD_SPRITE,
                        u_VOLSpaceType: H.PERIOD_SPRITE,
                        u_SOLSizeGradient: H.PERIOD_SPRITE,
                        u_SOLSizeGradientX: H.PERIOD_SPRITE,
                        u_SOLSizeGradientY: H.PERIOD_SPRITE,
                        u_SOLSizeGradientZ: H.PERIOD_SPRITE,
                        u_SOLSizeGradientMax: H.PERIOD_SPRITE,
                        u_SOLSizeGradientMaxX: H.PERIOD_SPRITE,
                        u_SOLSizeGradientMaxY: H.PERIOD_SPRITE,
                        u_SOLSizeGradientMaxZ: H.PERIOD_SPRITE,
                        u_ROLAngularVelocityConst: H.PERIOD_SPRITE,
                        u_ROLAngularVelocityConstSeprarate: H.PERIOD_SPRITE,
                        u_ROLAngularVelocityGradient: H.PERIOD_SPRITE,
                        u_ROLAngularVelocityGradientX: H.PERIOD_SPRITE,
                        u_ROLAngularVelocityGradientY: H.PERIOD_SPRITE,
                        u_ROLAngularVelocityGradientZ: H.PERIOD_SPRITE,
                        u_ROLAngularVelocityConstMax: H.PERIOD_SPRITE,
                        u_ROLAngularVelocityConstMaxSeprarate: H.PERIOD_SPRITE,
                        u_ROLAngularVelocityGradientMax: H.PERIOD_SPRITE,
                        u_ROLAngularVelocityGradientMaxX: H.PERIOD_SPRITE,
                        u_ROLAngularVelocityGradientMaxY: H.PERIOD_SPRITE,
                        u_ROLAngularVelocityGradientMaxZ: H.PERIOD_SPRITE,
                        u_ROLAngularVelocityGradientMaxW: H.PERIOD_SPRITE,
                        u_TSACycles: H.PERIOD_SPRITE,
                        u_TSASubUVLength: H.PERIOD_SPRITE,
                        u_TSAGradientUVs: H.PERIOD_SPRITE,
                        u_TSAMaxGradientUVs: H.PERIOD_SPRITE,
                        u_CameraPos: H.PERIOD_CAMERA,
                        u_CameraDirection: H.PERIOD_CAMERA,
                        u_CameraUp: H.PERIOD_CAMERA,
                        u_View: H.PERIOD_CAMERA,
                        u_Projection: H.PERIOD_CAMERA,
                        u_FogStart: H.PERIOD_SCENE,
                        u_FogRange: H.PERIOD_SCENE,
                        u_FogColor: H.PERIOD_SCENE
                    }, r = {
                        s_Cull: H.RENDER_STATE_CULL,
                        s_Blend: H.RENDER_STATE_BLEND,
                        s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                        s_BlendDst: H.RENDER_STATE_BLEND_DST,
                        s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                        s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
                    }, i = H.add("PARTICLESHURIKEN"), a = new oe(e, t), i.addSubShader(a), a.addShaderPass(gi, pi, r),
                    e = {
                        a_Position: ce.MESH_POSITION0
                    }, t = {
                        u_TintColor: H.PERIOD_MATERIAL,
                        u_Exposure: H.PERIOD_MATERIAL,
                        u_Rotation: H.PERIOD_MATERIAL,
                        u_CubeTexture: H.PERIOD_MATERIAL,
                        u_ViewProjection: H.PERIOD_CAMERA
                    }, i = H.add("SkyBox"), a = new oe(e, t), i.addSubShader(a), a.addShaderPass(zi, Gi),
                    e = {
                        a_Position: ce.MESH_POSITION0
                    }, t = {
                        u_SunSize: H.PERIOD_MATERIAL,
                        u_SunSizeConvergence: H.PERIOD_MATERIAL,
                        u_AtmosphereThickness: H.PERIOD_MATERIAL,
                        u_SkyTint: H.PERIOD_MATERIAL,
                        u_GroundTint: H.PERIOD_MATERIAL,
                        u_Exposure: H.PERIOD_MATERIAL,
                        u_ViewProjection: H.PERIOD_CAMERA,
                        "u_SunLight.direction": H.PERIOD_SCENE,
                        "u_SunLight.color": H.PERIOD_SCENE
                    }, i = H.add("SkyBoxProcedural"), a = new oe(e, t), i.addSubShader(a), a.addShaderPass(ki, Hi),
                    e = {
                        a_Position: ce.MESH_POSITION0,
                        a_Normal: ce.MESH_NORMAL0,
                        a_Texcoord0: ce.MESH_TEXTURECOORDINATE0
                    }, t = {
                        u_MvpMatrix: H.PERIOD_SPRITE,
                        u_WorldMat: H.PERIOD_SPRITE,
                        u_CameraPos: H.PERIOD_CAMERA,
                        u_Viewport: H.PERIOD_CAMERA,
                        u_ProjectionParams: H.PERIOD_CAMERA,
                        u_View: H.PERIOD_CAMERA,
                        u_LightmapScaleOffset: H.PERIOD_SPRITE,
                        u_LightMap: H.PERIOD_SPRITE,
                        u_SplatAlphaTexture: H.PERIOD_MATERIAL,
                        u_DiffuseTexture1: H.PERIOD_MATERIAL,
                        u_DiffuseTexture2: H.PERIOD_MATERIAL,
                        u_DiffuseTexture3: H.PERIOD_MATERIAL,
                        u_DiffuseTexture4: H.PERIOD_MATERIAL,
                        u_DiffuseTexture5: H.PERIOD_MATERIAL,
                        u_DiffuseScaleOffset1: H.PERIOD_MATERIAL,
                        u_DiffuseScaleOffset2: H.PERIOD_MATERIAL,
                        u_DiffuseScaleOffset3: H.PERIOD_MATERIAL,
                        u_DiffuseScaleOffset4: H.PERIOD_MATERIAL,
                        u_DiffuseScaleOffset5: H.PERIOD_MATERIAL,
                        u_FogStart: H.PERIOD_SCENE,
                        u_FogRange: H.PERIOD_SCENE,
                        u_FogColor: H.PERIOD_SCENE,
                        u_DirationLightCount: H.PERIOD_SCENE,
                        u_LightBuffer: H.PERIOD_SCENE,
                        u_LightClusterBuffer: H.PERIOD_SCENE,
                        u_AmbientColor: H.PERIOD_SCENE,
                        u_shadowMap1: H.PERIOD_SCENE,
                        u_shadowMap2: H.PERIOD_SCENE,
                        u_shadowMap3: H.PERIOD_SCENE,
                        u_shadowPSSMDistance: H.PERIOD_SCENE,
                        u_lightShadowVP: H.PERIOD_SCENE,
                        u_shadowPCFoffset: H.PERIOD_SCENE,
                        "u_DirectionLight.color": H.PERIOD_SCENE,
                        "u_DirectionLight.direction": H.PERIOD_SCENE,
                        "u_PointLight.position": H.PERIOD_SCENE,
                        "u_PointLight.range": H.PERIOD_SCENE,
                        "u_PointLight.color": H.PERIOD_SCENE,
                        "u_SpotLight.position": H.PERIOD_SCENE,
                        "u_SpotLight.direction": H.PERIOD_SCENE,
                        "u_SpotLight.range": H.PERIOD_SCENE,
                        "u_SpotLight.spot": H.PERIOD_SCENE,
                        "u_SpotLight.color": H.PERIOD_SCENE
                    }, r = {
                        s_Cull: H.RENDER_STATE_CULL,
                        s_Blend: H.RENDER_STATE_BLEND,
                        s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                        s_BlendDst: H.RENDER_STATE_BLEND_DST,
                        s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                        s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
                    }, i = H.add("ExtendTerrain"), a = new oe(e, t), i.addSubShader(a), a.addShaderPass(ci, hi, r),
                    e = {
                        a_Position: Wr.TRAIL_POSITION0,
                        a_OffsetVector: Wr.TRAIL_OFFSETVECTOR,
                        a_Texcoord0X: Wr.TRAIL_TEXTURECOORDINATE0X,
                        a_Texcoord0Y: Wr.TRAIL_TEXTURECOORDINATE0Y,
                        a_BirthTime: Wr.TRAIL_TIME0,
                        a_Color: Wr.TRAIL_COLOR
                    }, t = {
                        u_MvpMatrix: H.PERIOD_SPRITE,
                        u_View: H.PERIOD_CAMERA,
                        u_Projection: H.PERIOD_CAMERA,
                        u_TilingOffset: H.PERIOD_MATERIAL,
                        u_MainTexture: H.PERIOD_MATERIAL,
                        u_MainColor: H.PERIOD_MATERIAL,
                        u_CurTime: H.PERIOD_SPRITE,
                        u_LifeTime: H.PERIOD_SPRITE,
                        u_WidthCurve: H.PERIOD_SPRITE,
                        u_WidthCurveKeyLength: H.PERIOD_SPRITE,
                        u_GradientColorkey: H.PERIOD_SPRITE,
                        u_GradientAlphakey: H.PERIOD_SPRITE
                    }, r = {
                        s_Cull: H.RENDER_STATE_CULL,
                        s_Blend: H.RENDER_STATE_BLEND,
                        s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                        s_BlendDst: H.RENDER_STATE_BLEND_DST,
                        s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                        s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
                    }, i = H.add("Trail"), a = new oe(e, t), i.addSubShader(a), a.addShaderPass(Xi, Wi, r),
                    e = {
                        a_Position: ce.MESH_POSITION0,
                        a_Normal: ce.MESH_NORMAL0,
                        a_Tangent0: ce.MESH_TANGENT0
                    }, t = {
                        u_MvpMatrix: H.PERIOD_SPRITE,
                        u_WorldMat: H.PERIOD_SPRITE,
                        u_CameraPos: H.PERIOD_CAMERA,
                        u_Time: H.PERIOD_SCENE,
                        u_MainTexture: H.PERIOD_MATERIAL,
                        u_NormalTexture: H.PERIOD_MATERIAL,
                        u_HorizonColor: H.PERIOD_MATERIAL,
                        u_WaveScale: H.PERIOD_MATERIAL,
                        u_WaveSpeed: H.PERIOD_MATERIAL
                    }, i = H.add("WaterPrimary"), a = new oe(e, t), i.addSubShader(a), a.addShaderPass(qi, ji),
                    e = {
                        a_PositionTexcoord: ce.MESH_POSITION0
                    }, t = {
                        u_MainTex: H.PERIOD_MATERIAL,
                        u_OffsetScale: H.PERIOD_MATERIAL
                    }, i = H.add("BlitScreen"), a = new oe(e, t), i.addSubShader(a);
                var n = a.addShaderPass(oi, si),
                    s = n.renderState;
                s.depthTest = Q.DEPTHTEST_ALWAYS, s.depthWrite = !1, s.cull = Q.CULL_NONE, s.blend = Q.BLEND_DISABLE,
                    e = {
                        a_PositionTexcoord: ce.MESH_POSITION0
                    }, t = {
                        u_MainTex: H.PERIOD_MATERIAL,
                        u_BloomTex: H.PERIOD_MATERIAL,
                        u_AutoExposureTex: H.PERIOD_MATERIAL,
                        u_MainTex_TexelSize: H.PERIOD_MATERIAL,
                        u_SampleScale: H.PERIOD_MATERIAL,
                        u_Threshold: H.PERIOD_MATERIAL,
                        u_Params: H.PERIOD_MATERIAL
                    }, i = H.add("PostProcessBloom"), a = new oe(e, t), i.addSubShader(a), (s = (n = a.addShaderPass(Di, Ci)).renderState).depthTest = Q.DEPTHTEST_ALWAYS,
                    s.depthWrite = !1, s.cull = Q.CULL_NONE, s.blend = Q.BLEND_DISABLE, a = new oe(e, t),
                    i.addSubShader(a), (s = (n = a.addShaderPass(Di, Oi)).renderState).depthTest = Q.DEPTHTEST_ALWAYS,
                    s.depthWrite = !1, s.cull = Q.CULL_NONE, s.blend = Q.BLEND_DISABLE, a = new oe(e, t),
                    i.addSubShader(a), (s = (n = a.addShaderPass(Di, Li)).renderState).depthTest = Q.DEPTHTEST_ALWAYS,
                    s.depthWrite = !1, s.cull = Q.CULL_NONE, s.blend = Q.BLEND_DISABLE, a = new oe(e, t),
                    i.addSubShader(a), (s = (n = a.addShaderPass(Di, yi)).renderState).depthTest = Q.DEPTHTEST_ALWAYS,
                    s.depthWrite = !1, s.cull = Q.CULL_NONE, s.blend = Q.BLEND_DISABLE, a = new oe(e, t),
                    i.addSubShader(a), (s = (n = a.addShaderPass(Di, Pi)).renderState).depthTest = Q.DEPTHTEST_ALWAYS,
                    s.depthWrite = !1, s.cull = Q.CULL_NONE, s.blend = Q.BLEND_DISABLE, a = new oe(e, t),
                    i.addSubShader(a), (s = (n = a.addShaderPass(Di, Ni)).renderState).depthTest = Q.DEPTHTEST_ALWAYS,
                    s.depthWrite = !1, s.cull = Q.CULL_NONE, s.blend = Q.BLEND_DISABLE, e = {
                        a_PositionTexcoord: ce.MESH_POSITION0
                    }, t = {
                        u_MainTex: H.PERIOD_MATERIAL,
                        u_BloomTex: H.PERIOD_MATERIAL,
                        u_AutoExposureTex: H.PERIOD_MATERIAL,
                        u_Bloom_DirtTileOffset: H.PERIOD_MATERIAL,
                        u_Bloom_DirtTex: H.PERIOD_MATERIAL,
                        u_BloomTex_TexelSize: H.PERIOD_MATERIAL,
                        u_Bloom_Settings: H.PERIOD_MATERIAL,
                        u_Bloom_Color: H.PERIOD_MATERIAL
                    }, i = H.add("PostProcessComposite"), a = new oe(e, t), i.addSubShader(a), (s = (n = a.addShaderPass(wi, Vi)).renderState).depthTest = Q.DEPTHTEST_ALWAYS,
                    s.depthWrite = !1, s.cull = Q.CULL_NONE, s.blend = Q.BLEND_DISABLE;
            }
        }]);
        return Qi;
    }();
    var Ki = /* */ function() {
        function Ki() {
            _classCallCheck(this, Ki);
            var e;
            for (this._spiltDistance = [], this._currentPSSM = -1, this._shadowMapCount = 3,
                this._maxDistance = 200, this._ratioOfDistance = 1 / this._shadowMapCount, this._globalParallelLightDir = new n(0, -1, 0),
                this._statesDirty = !0, this._shadowMapTextureSize = 1024, this._scene = null, this._boundingSphere = new Array(Ki.MAX_PSSM_COUNT + 1),
                this._boundingBox = new Array(Ki.MAX_PSSM_COUNT + 1), this._frustumPos = new Array(4 * (Ki.MAX_PSSM_COUNT + 1)),
                this._uniformDistance = new Array(Ki.MAX_PSSM_COUNT + 1), this._logDistance = new Array(Ki.MAX_PSSM_COUNT + 1),
                this._dimension = new Array(Ki.MAX_PSSM_COUNT + 1), this._PCFType = 0, this._tempLookAt3 = new n(),
                this._tempLookAt4 = new a(), this._tempValue = new a(), this._tempPos = new n(),
                this._tempLightUp = new n(), this._tempMin = new a(), this._tempMax = new a(), this._tempMatrix44 = new C(),
                this._splitFrustumCulling = new He(C.DEFAULT), this._tempScaleMatrix44 = new C(),
                this._shadowPCFOffset = new i(1 / 1024, 1 / 1024), this._shaderValueDistance = new a(),
                this._shaderValueLightVP = null, this.cameras = [], this._shaderValueVPs = [], e = 0; e < this._spiltDistance.length; e++) {
                this._spiltDistance[e] = 0;
            }
            for (e = 0; e < this._dimension.length; e++) {
                this._dimension[e] = new i();
            }
            for (e = 0; e < this._frustumPos.length; e++) {
                this._frustumPos[e] = new n();
            }
            for (e = 0; e < this._boundingBox.length; e++) {
                this._boundingBox[e] = new dt(new n(), new n());
            }
            for (e = 0; e < this._boundingSphere.length; e++) {
                this._boundingSphere[e] = new Qt(new n(), 0);
            }
            C.createScaling(new n(.5, .5, 1), this._tempScaleMatrix44), this._tempScaleMatrix44.elements[12] = .5,
                this._tempScaleMatrix44.elements[13] = .5;
        }
        _createClass(Ki, [{
            key: "setInfo",
            value: function setInfo(e, t, r, i, a, n) {
                a > Ki.MAX_PSSM_COUNT && (this._shadowMapCount = Ki.MAX_PSSM_COUNT), this._scene = e,
                    this._maxDistance = t, this.shadowMapCount = a, this._globalParallelLightDir = r,
                    this._ratioOfDistance = 1 / this._shadowMapCount;
                for (var s = 0; s < this._spiltDistance.length; s++) {
                    this._spiltDistance[s] = 0;
                }
                this._shadowMapTextureSize = i, this._shadowPCFOffset.x = 1 / this._shadowMapTextureSize,
                    this._shadowPCFOffset.y = 1 / this._shadowMapTextureSize, this.setPCFType(n), this._statesDirty = !0;
            }
        }, {
            key: "setPCFType",
            value: function setPCFType(e) {
                this._PCFType = e;
                var t = this._scene._shaderValues;
                switch (this._PCFType) {
                    case 0:
                        t.addDefine(at.SHADERDEFINE_SHADOW_PCF_NO), t.removeDefine(at.SHADERDEFINE_SHADOW_PCF1),
                            t.removeDefine(at.SHADERDEFINE_SHADOW_PCF2), t.removeDefine(at.SHADERDEFINE_SHADOW_PCF3);
                        break;

                    case 1:
                        t.addDefine(at.SHADERDEFINE_SHADOW_PCF1), t.removeDefine(at.SHADERDEFINE_SHADOW_PCF_NO),
                            t.removeDefine(at.SHADERDEFINE_SHADOW_PCF2), t.removeDefine(at.SHADERDEFINE_SHADOW_PCF3);
                        break;

                    case 2:
                        t.addDefine(at.SHADERDEFINE_SHADOW_PCF2), t.removeDefine(at.SHADERDEFINE_SHADOW_PCF_NO),
                            t.removeDefine(at.SHADERDEFINE_SHADOW_PCF1), t.removeDefine(at.SHADERDEFINE_SHADOW_PCF3);
                        break;

                    case 3:
                        t.addDefine(at.SHADERDEFINE_SHADOW_PCF3), t.removeDefine(at.SHADERDEFINE_SHADOW_PCF_NO),
                            t.removeDefine(at.SHADERDEFINE_SHADOW_PCF1), t.removeDefine(at.SHADERDEFINE_SHADOW_PCF2);
                }
            }
        }, {
            key: "getPCFType",
            value: function getPCFType() {
                return this._PCFType;
            }
        }, {
            key: "setFarDistance",
            value: function setFarDistance(e) {
                this._maxDistance != e && (this._maxDistance = e, this._statesDirty = !0);
            }
        }, {
            key: "getFarDistance",
            value: function getFarDistance() {
                return this._maxDistance;
            }
        }, {
            key: "_beginSampler",
            value: function _beginSampler(e, t) {
                if (e < 0 || e > this._shadowMapCount) throw new Error("ParallelSplitShadowMap: beginSample invalid index");
                this._currentPSSM = e, this._update(t);
            }
        }, {
            key: "endSampler",
            value: function endSampler(e) {
                this._currentPSSM = -1;
            }
        }, {
            key: "_calcAllLightCameraInfo",
            value: function _calcAllLightCameraInfo(e) {
                if (1 === this._shadowMapCount) this._beginSampler(0, e), this.endSampler(e);
                else
                    for (var t = 0, r = this._shadowMapCount + 1; t < r; t++) {
                        this._beginSampler(t, e), this.endSampler(e);
                    }
            }
        }, {
            key: "_recalculate",
            value: function _recalculate(e, t, r) {
                this._calcSplitDistance(e), this._calcBoundingBox(t, r), this._rebuildRenderInfo();
            }
        }, {
            key: "_update",
            value: function _update(e) {
                var t = e.nearPlane,
                    r = e.fieldOfView,
                    i = e.aspectRatio;
                (this._statesDirty || this.lastNearPlane !== t || this.lastFieldOfView !== r || this.lastAspectRatio !== i) && (this._recalculate(t, r, i),
                    this._uploadShaderValue(), this._statesDirty = !1, this.lastNearPlane = t, this.lastFieldOfView = r,
                    this.lastAspectRatio = i), this._calcLightViewProject(e);
            }
        }, {
            key: "_uploadShaderValue",
            value: function _uploadShaderValue() {
                var e = this._scene._shaderValues;
                switch (this._shadowMapCount) {
                    case 1:
                        e.addDefine(at.SHADERDEFINE_SHADOW_PSSM1), e.removeDefine(at.SHADERDEFINE_SHADOW_PSSM2),
                            e.removeDefine(at.SHADERDEFINE_SHADOW_PSSM3);
                        break;

                    case 2:
                        e.addDefine(at.SHADERDEFINE_SHADOW_PSSM2), e.removeDefine(at.SHADERDEFINE_SHADOW_PSSM1),
                            e.removeDefine(at.SHADERDEFINE_SHADOW_PSSM3);
                        break;

                    case 3:
                        e.addDefine(at.SHADERDEFINE_SHADOW_PSSM3), e.removeDefine(at.SHADERDEFINE_SHADOW_PSSM1),
                            e.removeDefine(at.SHADERDEFINE_SHADOW_PSSM2);
                }
                switch (e.setVector(_.Scene3D.SHADOWDISTANCE, this._shaderValueDistance), e.setBuffer(_.Scene3D.SHADOWLIGHTVIEWPROJECT, this._shaderValueLightVP),
                    e.setVector2(_.Scene3D.SHADOWMAPPCFOFFSET, this._shadowPCFOffset), this._shadowMapCount) {
                    case 3:
                        e.setTexture(_.Scene3D.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget), e.setTexture(_.Scene3D.SHADOWMAPTEXTURE2, this.cameras[2].renderTarget),
                            e.setTexture(_.Scene3D.SHADOWMAPTEXTURE3, this.cameras[3].renderTarget);
                        break;

                    case 2:
                        e.setTexture(_.Scene3D.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget), e.setTexture(_.Scene3D.SHADOWMAPTEXTURE2, this.cameras[2].renderTarget);
                        break;

                    case 1:
                        e.setTexture(_.Scene3D.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget);
                }
            }
        }, {
            key: "_calcSplitDistance",
            value: function _calcSplitDistance(e) {
                var t, r = this._maxDistance,
                    i = 1 / this._shadowMapCount;
                for (t = 0; t <= this._shadowMapCount; t++) {
                    this._uniformDistance[t] = e + (r - e) * t * i;
                }
                var a = r / e;
                for (t = 0; t <= this._shadowMapCount; t++) {
                    var n = Math.pow(a, t * i);
                    this._logDistance[t] = e * n;
                }
                for (t = 0; t <= this._shadowMapCount; t++) {
                    this._spiltDistance[t] = this._uniformDistance[t] * this._ratioOfDistance + this._logDistance[t] * (1 - this._ratioOfDistance);
                }
                this._shaderValueDistance.x = null != this._spiltDistance[1] && this._spiltDistance[1],
                    this._shaderValueDistance.y = null != this._spiltDistance[2] && this._spiltDistance[2],
                    this._shaderValueDistance.z = null != this._spiltDistance[3] && this._spiltDistance[3],
                    this._shaderValueDistance.w = null != this._spiltDistance[4] && this._spiltDistance[4];
            }
        }, {
            key: "_calcBoundingBox",
            value: function _calcBoundingBox(e, t) {
                var r, i, a, n, s, o, l, _, h = 3.1415926 * e / 180,
                    c = Math.tan(h / 2);
                for (n = 0; n <= this._shadowMapCount; n++) {
                    i = (r = (a = this._spiltDistance[n]) * c) * t;
                    var d = this._frustumPos[4 * n + 0];
                    d.x = -i, d.y = -r, d.z = -a, (d = this._frustumPos[4 * n + 1]).x = i, d.y = -r,
                        d.z = -a, (d = this._frustumPos[4 * n + 2]).x = -i, d.y = r, d.z = -a, (d = this._frustumPos[4 * n + 3]).x = i,
                        d.y = r, d.z = -a, (d = this._dimension[n]).x = i, d.y = r;
                }
                for (n = 1; n <= this._shadowMapCount; n++) {
                    s = this._dimension[n], (o = this._boundingBox[n].min).x = -s.x, o.y = -s.y, o.z = -this._spiltDistance[n],
                        (l = this._boundingBox[n].max).x = s.x, l.y = s.y, l.z = -this._spiltDistance[n - 1],
                        (_ = this._boundingSphere[n].center).x = .5 * (o.x + l.x), _.y = .5 * (o.y + l.y),
                        _.z = .5 * (o.z + l.z), this._boundingSphere[n].radius = .5 * Math.sqrt(Math.pow(l.x - o.x, 2) + Math.pow(l.y - o.y, 2) + Math.pow(l.z - o.z, 2));
                }
                o = this._boundingBox[0].min, s = this._dimension[this._shadowMapCount], o.x = -s.x,
                    o.y = -s.y, o.z = -this._spiltDistance[this._shadowMapCount], (l = this._boundingBox[0].max).x = s.x,
                    l.y = s.y, l.z = -this._spiltDistance[0], (_ = this._boundingSphere[0].center).x = .5 * (o.x + l.x),
                    _.y = .5 * (o.y + l.y), _.z = .5 * (o.z + l.z), this._boundingSphere[0].radius = .5 * Math.sqrt(Math.pow(l.x - o.x, 2) + Math.pow(l.y - o.y, 2) + Math.pow(l.z - o.z, 2));
            }
        }, {
            key: "calcSplitFrustum",
            value: function calcSplitFrustum(e) {
                this._currentPSSM > 0 ? C.createPerspective(3.1416 * e.fieldOfView / 180, e.aspectRatio, this._spiltDistance[this._currentPSSM - 1], this._spiltDistance[this._currentPSSM], this._tempMatrix44) : C.createPerspective(3.1416 * e.fieldOfView / 180, e.aspectRatio, this._spiltDistance[0], this._spiltDistance[this._shadowMapCount], this._tempMatrix44),
                    C.multiply(this._tempMatrix44, e.viewMatrix, this._tempMatrix44), this._splitFrustumCulling.matrix = this._tempMatrix44;
            }
        }, {
            key: "_rebuildRenderInfo",
            value: function _rebuildRenderInfo() {
                var e, r = this._shadowMapCount + 1;
                for (this.cameras.length = r, e = 0; e < r; e++) {
                    if (!this.cameras[e]) {
                        var i = new nt();
                        i.name = "lightCamera" + e, i.clearColor = new a(1, 1, 1, 1), this.cameras[e] = i;
                    }
                    var n = this.cameras[e].renderTarget;
                    null != n && n.width == this._shadowMapTextureSize && n.height == this._shadowMapTextureSize || (n && n.destroy(),
                        (n = new F(this._shadowMapTextureSize, this._shadowMapTextureSize, t.RenderTextureFormat.R8G8B8A8, t.RenderTextureDepthFormat.DEPTH_16)).filterMode = t.FilterMode.Point,
                        this.cameras[e].renderTarget = n);
                }
            }
        }, {
            key: "_calcLightViewProject",
            value: function _calcLightViewProject(e) {
                var t = this._boundingSphere[this._currentPSSM],
                    r = e.transform.worldMatrix;
                t.radius;
                t.center.cloneTo(this._tempLookAt3), n.transformV3ToV4(this._tempLookAt3, r, this._tempLookAt4);
                var i = this._tempLookAt3,
                    s = this._tempLookAt4;
                i.x = s.x, i.y = s.y, i.z = s.z;
                var o = this._tempLightUp;
                e.transform.worldMatrix.getForward(Ki._tempVector30);
                var l = Ki._tempVector30;
                o.x = l.x, o.y = 1, o.z = l.z, n.normalize(this._tempLightUp, this._tempLightUp),
                    n.scale(this._globalParallelLightDir, 4 * t.radius, this._tempPos), n.subtract(this._tempLookAt3, this._tempPos, this._tempPos);
                var h = this.cameras[this._currentPSSM];
                h.transform.position = this._tempPos, h.transform.lookAt(this._tempLookAt3, this._tempLightUp, !1);
                var c = this._tempMax,
                    d = this._tempMin;
                c.x = c.y = c.z = -1e5, c.w = 1, d.x = d.y = d.z = 1e5, d.w = 1, C.multiply(h.viewMatrix, r, this._tempMatrix44);
                var u = this._tempValue,
                    m = [];
                m.length = 8, this._boundingBox[this._currentPSSM].getCorners(m);
                for (var f = 0; f < 8; f++) {
                    var E = m[f];
                    u.x = E.x, u.y = E.y, u.z = E.z, u.w = 1, a.transformByM4x4(this._tempValue, this._tempMatrix44, this._tempValue),
                        d.x = u.x < d.x ? u.x : d.x, d.y = u.y < d.y ? u.y : d.y, d.z = u.z < d.z ? u.z : d.z,
                        c.x = u.x > c.x ? u.x : c.x, c.y = u.y > c.y ? u.y : c.y, c.z = u.z > c.z ? u.z : c.z;
                }
                a.add(this._tempMax, this._tempMin, this._tempValue), u.x *= .5, u.y *= .5, u.z *= .5,
                    u.w = 1, a.transformByM4x4(this._tempValue, h.transform.worldMatrix, this._tempValue);
                var T = Math.abs(-this._tempMax.z),
                    p = T > this._maxDistance ? T : this._maxDistance;
                n.scale(this._globalParallelLightDir, p, this._tempPos);
                var g = this._tempPos;
                g.x = u.x - g.x, g.y = u.y - g.y, g.z = u.z - g.z, h.transform.position = this._tempPos,
                    h.transform.lookAt(this._tempLookAt3, this._tempLightUp, !1), C.createOrthoOffCenter(d.x, c.x, d.y, c.y, 1, p + .5 * (c.z - d.z), h.projectionMatrix);
                var S = h.projectionViewMatrix;
                Ki.multiplyMatrixOutFloat32Array(this._tempScaleMatrix44, S, this._shaderValueVPs[this._currentPSSM]),
                    this._scene._shaderValues.setBuffer(_.Scene3D.SHADOWLIGHTVIEWPROJECT, this._shaderValueLightVP);
            }
        }, {
            key: "setShadowMapTextureSize",
            value: function setShadowMapTextureSize(e) {
                e !== this._shadowMapTextureSize && (this._shadowMapTextureSize = e, this._shadowPCFOffset.x = 1 / this._shadowMapTextureSize,
                    this._shadowPCFOffset.y = 1 / this._shadowMapTextureSize, this._statesDirty = !0);
            }
        }, {
            key: "disposeAllRenderTarget",
            value: function disposeAllRenderTarget() {
                for (var e = 0, t = this._shadowMapCount + 1; e < t; e++) {
                    this.cameras[e].renderTarget && (this.cameras[e].renderTarget.destroy(), this.cameras[e].renderTarget = null);
                }
            }
        }, {
            key: "shadowMapCount",
            set: function set(e) {
                if (e = (e = e > 0 ? e : 1) <= Ki.MAX_PSSM_COUNT ? e : Ki.MAX_PSSM_COUNT, this._shadowMapCount != e) {
                    this._shadowMapCount = e, this._ratioOfDistance = 1 / this._shadowMapCount, this._statesDirty = !0,
                        this._shaderValueLightVP = new Float32Array(16 * e), this._shaderValueVPs.length = e;
                    for (var t = 0; t < e; t++) {
                        this._shaderValueVPs[t] = new Float32Array(this._shaderValueLightVP.buffer, 64 * t);
                    }
                }
            },
            get: function get() {
                return this._shadowMapCount;
            }
        }], [{
            key: "multiplyMatrixOutFloat32Array",
            value: function multiplyMatrixOutFloat32Array(e, t, r) {
                var i, a, n, s, o, l, _;
                for (a = e.elements, n = t.elements, i = 0; i < 4; i++) {
                    s = a[i], o = a[i + 4], l = a[i + 8], _ = a[i + 12], r[i] = s * n[0] + o * n[1] + l * n[2] + _ * n[3],
                        r[i + 4] = s * n[4] + o * n[5] + l * n[6] + _ * n[7], r[i + 8] = s * n[8] + o * n[9] + l * n[10] + _ * n[11],
                        r[i + 12] = s * n[12] + o * n[13] + l * n[14] + _ * n[15];
                }
            }
        }]);
        return Ki;
    }();
    Ki.MAX_PSSM_COUNT = 3, Ki._tempVector30 = new n();
    var Ji = /* */ function(_Le3) {
        _inherits(Ji, _Le3);

        function Ji() {
            var _this82;
            _classCallCheck(this, Ji);
            _this82 = _possibleConstructorReturn(this, _getPrototypeOf(Ji).call(this)), _this82._isAlternate = !1,
                _this82._intensity = 1, _this82._intensityColor = new n(), _this82.color = new n(1, 1, 1),
                _this82._shadow = !1, _this82._shadowFarPlane = 8, _this82._shadowMapSize = 512,
                _this82._shadowMapCount = 1, _this82._shadowMapPCFType = 0, _this82._lightmapBakedType = Ji.LIGHTMAPBAKEDTYPE_REALTIME;
            return _this82;
        }
        _createClass(Ji, [{
            key: "_parse",
            value: function _parse(e, t) {
                _get(_getPrototypeOf(Ji.prototype), "_parse", this).call(this, e, t);
                var r = e.color;
                this.color.fromArray(r), this.intensity = e.intensity, this.lightmapBakedType = e.lightmapBakedType;
            }
        }, {
            key: "_addToScene",
            value: function _addToScene() {
                var e = this._scene,
                    t = l._config.maxLightCount;
                e._lightCount < t ? (e._lightCount++, this._addToLightQueue(), this._isAlternate = !1) : (e._alternateLights.add(this),
                    this._isAlternate = !0, console.warn("LightSprite:light count has large than maxLightCount,the latest added light will be ignore."));
            }
        }, {
            key: "_removeFromScene",
            value: function _removeFromScene() {
                var e = this._scene;
                if (this._isAlternate) e._alternateLights.remove(this);
                else if (e._lightCount--,
                    this._removeFromLightQueue(), e._alternateLights._length > 0) {
                    var t = e._alternateLights.shift();
                    t._addToLightQueue(), t._isAlternate = !1, e._lightCount++;
                }
            }
        }, {
            key: "_addToLightQueue",
            value: function _addToLightQueue() {}
        }, {
            key: "_removeFromLightQueue",
            value: function _removeFromLightQueue() {}
        }, {
            key: "_onActive",
            value: function _onActive() {
                _get(_getPrototypeOf(Ji.prototype), "_onActive", this).call(this), this.lightmapBakedType !== Ji.LIGHTMAPBAKEDTYPE_BAKED && this._addToScene();
            }
        }, {
            key: "_onInActive",
            value: function _onInActive() {
                _get(_getPrototypeOf(Ji.prototype), "_onInActive", this).call(this), this.lightmapBakedType !== Ji.LIGHTMAPBAKEDTYPE_BAKED && this._removeFromScene();
            }
        }, {
            key: "_create",
            value: function _create() {
                return new Ji();
            }
        }, {
            key: "intensity",
            get: function get() {
                return this._intensity;
            },
            set: function set(e) {
                this._intensity = e;
            }
        }, {
            key: "shadow",
            get: function get() {
                return this._shadow;
            },
            set: function set(e) {
                throw new Error("LightSprite: must override it.");
            }
        }, {
            key: "shadowDistance",
            get: function get() {
                return this._shadowFarPlane;
            },
            set: function set(e) {
                this._shadowFarPlane = e, this._parallelSplitShadowMap && this._parallelSplitShadowMap.setFarDistance(e);
            }
        }, {
            key: "shadowResolution",
            get: function get() {
                return this._shadowMapSize;
            },
            set: function set(e) {
                this._shadowMapSize = e, this._parallelSplitShadowMap && this._parallelSplitShadowMap.setShadowMapTextureSize(e);
            }
        }, {
            key: "shadowPSSMCount",
            get: function get() {
                return this._shadowMapCount;
            },
            set: function set(e) {
                this._shadowMapCount = e, this._parallelSplitShadowMap && (this._parallelSplitShadowMap.shadowMapCount = e);
            }
        }, {
            key: "shadowPCFType",
            get: function get() {
                return this._shadowMapPCFType;
            },
            set: function set(e) {
                this._shadowMapPCFType = e, this._parallelSplitShadowMap && this._parallelSplitShadowMap.setPCFType(e);
            }
        }, {
            key: "lightmapBakedType",
            get: function get() {
                return this._lightmapBakedType;
            },
            set: function set(e) {
                this._lightmapBakedType !== e && (this._lightmapBakedType = e, this.activeInHierarchy && (e !== Ji.LIGHTMAPBAKEDTYPE_BAKED ? this._addToScene() : this._removeFromScene()));
            }
        }, {
            key: "diffuseColor",
            get: function get() {
                return console.log("LightSprite: discard property,please use color property instead."),
                    this.color;
            },
            set: function set(e) {
                console.log("LightSprite: discard property,please use color property instead."),
                    this.color = e;
            }
        }]);
        return Ji;
    }(Le);
    Ji.LIGHTMAPBAKEDTYPE_REALTIME = 0, Ji.LIGHTMAPBAKEDTYPE_MIXED = 1, Ji.LIGHTMAPBAKEDTYPE_BAKED = 2;
    var $i = /* */ function(_Ji) {
        _inherits($i, _Ji);
        _createClass($i, [{
            key: "shadow",
            set: function set(e) {
                this._shadow !== e && (this._shadow = e, this.scene && this._initShadow());
            }
        }]);

        function $i() {
            var _this83;
            _classCallCheck(this, $i);
            _this83 = _possibleConstructorReturn(this, _getPrototypeOf($i).call(this)), _this83._direction = new n();
            return _this83;
        }
        _createClass($i, [{
            key: "_initShadow",
            value: function _initShadow() {
                if (this._shadow) this._parallelSplitShadowMap = new Ki(), this.scene.parallelSplitShadowMaps.push(this._parallelSplitShadowMap),
                    this.transform.worldMatrix.getForward(this._direction), n.normalize(this._direction, this._direction),
                    this._parallelSplitShadowMap.setInfo(this.scene, this._shadowFarPlane, this._direction, this._shadowMapSize, this._shadowMapCount, this._shadowMapPCFType);
                else {
                    var e = this._scene._shaderValues,
                        t = this.scene.parallelSplitShadowMaps;
                    t.splice(t.indexOf(this._parallelSplitShadowMap), 1), this._parallelSplitShadowMap.disposeAllRenderTarget(),
                        this._parallelSplitShadowMap = null, e.removeDefine(at.SHADERDEFINE_SHADOW_PSSM1),
                        e.removeDefine(at.SHADERDEFINE_SHADOW_PSSM2), e.removeDefine(at.SHADERDEFINE_SHADOW_PSSM3);
                }
            }
        }, {
            key: "_addToLightQueue",
            value: function _addToLightQueue() {
                this._scene._directionLights.add(this);
            }
        }, {
            key: "_removeFromLightQueue",
            value: function _removeFromLightQueue() {
                this._scene._directionLights.remove(this);
            }
        }]);
        return $i;
    }(Ji);
    var ea = /* */ function(_Ji2) {
        _inherits(ea, _Ji2);
        _createClass(ea, [{
            key: "range",
            get: function get() {
                return this._range;
            },
            set: function set(e) {
                this._range = e;
            }
        }]);

        function ea() {
            var _this84;
            _classCallCheck(this, ea);
            _this84 = _possibleConstructorReturn(this, _getPrototypeOf(ea).call(this)), _this84._range = 6;
            return _this84;
        }
        _createClass(ea, [{
            key: "_addToLightQueue",
            value: function _addToLightQueue() {
                this._scene._pointLights.add(this);
            }
        }, {
            key: "_removeFromLightQueue",
            value: function _removeFromLightQueue() {
                this._scene._pointLights.remove(this);
            }
        }, {
            key: "_parse",
            value: function _parse(e, t) {
                _get(_getPrototypeOf(ea.prototype), "_parse", this).call(this, e, t), this.range = e.range;
            }
        }]);
        return ea;
    }(Ji);
    var ta = /* */ function(_Ji3) {
        _inherits(ta, _Ji3);
        _createClass(ta, [{
            key: "spotAngle",
            get: function get() {
                return this._spotAngle;
            },
            set: function set(e) {
                this._spotAngle = Math.max(Math.min(e, 179), 0);
            }
        }, {
            key: "range",
            get: function get() {
                return this._range;
            },
            set: function set(e) {
                this._range = e;
            }
        }]);

        function ta() {
            var _this85;
            _classCallCheck(this, ta);
            _this85 = _possibleConstructorReturn(this, _getPrototypeOf(ta).call(this)), _this85._spotAngle = 30,
                _this85._range = 10, _this85._direction = new n();
            return _this85;
        }
        _createClass(ta, [{
            key: "_addToLightQueue",
            value: function _addToLightQueue() {
                this._scene._spotLights.add(this);
            }
        }, {
            key: "_removeFromLightQueue",
            value: function _removeFromLightQueue() {
                this._scene._spotLights.remove(this);
            }
        }, {
            key: "_parse",
            value: function _parse(e, t) {
                _get(_getPrototypeOf(ta.prototype), "_parse", this).call(this, e, t), this.range = e.range,
                    this.spotAngle = e.spotAngle;
            }
        }]);
        return ta;
    }(Ji);
    var ra = /* */ function() {
        function ra() {
            _classCallCheck(this, ra);
        }
        _createClass(ra, null, [{
            key: "_createSprite3DInstance",
            value: function _createSprite3DInstance(e, t, r) {
                var i;
                switch (e.type) {
                    case "Scene3D":
                        i = new Br();
                        break;

                    case "Sprite3D":
                        i = new Le();
                        break;

                    case "MeshSprite3D":
                        i = new gt(), r && e.props.isStatic && r.push(i);
                        break;

                    case "SkinnedMeshSprite3D":
                        i = new zr();
                        break;

                    case "ShuriKenParticle3D":
                        i = new tr();
                        break;

                    case "Camera":
                        i = new nt();
                        break;

                    case "DirectionLight":
                        i = new $i();
                        break;

                    case "PointLight":
                        i = new ea();
                        break;

                    case "SpotLight":
                        i = new ta();
                        break;

                    case "TrailSprite3D":
                        i = new jr();
                        break;

                    default:
                        throw new Error("Utils3D:unidentified class type in (.lh) file.");
                }
                var a = e.child;
                if (a)
                    for (var n = 0, s = a.length; n < s; n++) {
                        var o = ra._createSprite3DInstance(a[n], t, r);
                        i.addChild(o);
                    }
                return t[e.instanceID] = i, i;
            }
        }, {
            key: "_createComponentInstance",
            value: function _createComponentInstance(e, r) {
                var i = r[e.instanceID];
                i._parse(e.props, r);
                var a = e.child;
                if (a)
                    for (var n = 0, s = a.length; n < s; n++) {
                        ra._createComponentInstance(a[n], r);
                    }
                var o = e.components;
                if (o)
                    for (var l = 0, _ = o.length; l < _; l++) {
                        var h = o[l],
                            c = t.ClassUtils.getRegClass(h.type);
                        if (c) i.addComponent(c)._parse(h);
                        else console.warn("Unkown component type.");
                    }
            }
        }, {
            key: "_createNodeByJson02",
            value: function _createNodeByJson02(e, t) {
                var r = {},
                    i = ra._createSprite3DInstance(e, r, t);
                return ra._createComponentInstance(e, r), i;
            }
        }, {
            key: "_parse",
            value: function _parse(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i, a = e.data,
                    n = [];
                switch (e.version) {
                    case "LAYAHIERARCHY:02":
                        i = ra._createNodeByJson02(a, n);
                        break;

                    default:
                        i = ra._createNodeByJson(a, n);
                }
                return Ce.combine(i, n), i;
            }
        }, {
            key: "_parseScene",
            value: function _parseScene(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i, a = e.data,
                    n = [];
                switch (e.version) {
                    case "LAYASCENE3D:02":
                        i = ra._createNodeByJson02(a, n);
                        break;

                    default:
                        i = ra._createNodeByJson(a, n);
                }
                return Ce.combine(null, n), i;
            }
        }, {
            key: "_createNodeByJson",
            value: function _createNodeByJson(e, r) {
                var i;
                switch (e.type) {
                    case "Scene3D":
                        i = new Br();
                        break;

                    case "Sprite3D":
                        i = new Le();
                        break;

                    case "MeshSprite3D":
                        i = new gt(), r && e.props.isStatic && r.push(i);
                        break;

                    case "SkinnedMeshSprite3D":
                        i = new zr();
                        break;

                    case "ShuriKenParticle3D":
                        i = new tr();
                        break;

                    case "Camera":
                        i = new nt();
                        break;

                    case "DirectionLight":
                        i = new $i();
                        break;

                    case "PointLight":
                        i = new ea();
                        break;

                    case "SpotLight":
                        i = new ta();
                        break;

                    case "TrailSprite3D":
                        i = new jr();
                        break;

                    default:
                        throw new Error("Utils3D:unidentified class type in (.lh) file.");
                }
                var a = e.child;
                if (a)
                    for (var n = 0, s = a.length; n < s; n++) {
                        var o = ra._createNodeByJson(a[n], r);
                        i.addChild(o);
                    }
                var l = e.components;
                if (l)
                    for (var _ = 0, h = l.length; _ < h; _++) {
                        var c = l[_],
                            d = t.ClassUtils.getRegClass(c.type);
                        if (d) i.addComponent(d)._parse(c);
                        else console.warn("Unkown component type.");
                    }
                return i._parse(e.props, null), i;
            }
        }]);
        return ra;
    }();
    var ia = /* */ function() {
        function ia() {
            _classCallCheck(this, ia);
        }
        _createClass(ia, null, [{
            key: "parse",
            value: function parse(e, t, r, i) {
                ia._mesh = r, ia._subMeshes = i, ia._version = t, ia._readData = e, ia.READ_DATA(),
                    ia.READ_BLOCK(), ia.READ_STRINGS();
                for (var a = 0, n = ia._BLOCK.count; a < n; a++) {
                    ia._readData.pos = ia._BLOCK.blockStarts[a];
                    var s = ia._readData.getUint16(),
                        o = ia._strings[s],
                        l = ia["READ_" + o];
                    if (null == l) throw new Error("model file err,no this function:" + s + " " + o);
                    l.call(null);
                }
                ia._strings.length = 0, ia._readData = null, ia._version = null, ia._mesh = null,
                    ia._subMeshes = null;
            }
        }, {
            key: "_readString",
            value: function _readString() {
                return ia._strings[ia._readData.getUint16()];
            }
        }, {
            key: "READ_DATA",
            value: function READ_DATA() {
                ia._DATA.offset = ia._readData.getUint32(), ia._DATA.size = ia._readData.getUint32();
            }
        }, {
            key: "READ_BLOCK",
            value: function READ_BLOCK() {
                for (var e = ia._BLOCK.count = ia._readData.getUint16(), t = ia._BLOCK.blockStarts = [], r = ia._BLOCK.blockLengths = [], i = 0; i < e; i++) {
                    t.push(ia._readData.getUint32()), r.push(ia._readData.getUint32());
                }
            }
        }, {
            key: "READ_STRINGS",
            value: function READ_STRINGS() {
                var e = ia._readData.getUint32(),
                    t = ia._readData.getUint16(),
                    r = ia._readData.pos;
                ia._readData.pos = e + ia._DATA.offset;
                for (var i = 0; i < t; i++) {
                    ia._strings[i] = ia._readData.readUTFString();
                }
                ia._readData.pos = r;
            }
        }, {
            key: "READ_MESH",
            value: function READ_MESH() {
                var r, i = t.LayaGL.instance,
                    a = (ia._readString(), ia._readData.__getBuffer()),
                    n = 0,
                    s = ia._readData.getInt16(),
                    o = ia._DATA.offset;
                for (r = 0; r < s; r++) {
                    var l, _ = o + ia._readData.getUint32(),
                        h = ia._readData.getUint32(),
                        c = a.slice(_, _ + h),
                        d = new Float32Array(c),
                        u = ia._readString();
                    switch (ia._version) {
                        case "LAYAMODEL:0301":
                        case "LAYAMODEL:0400":
                            l = ce.getVertexDeclaration(u);
                            break;

                        case "LAYAMODEL:0401":
                            l = ce.getVertexDeclaration(u, !1);
                            break;

                        default:
                            throw new Error("LoadModelV03: unknown version.");
                    }
                    if (!l) throw new Error("LoadModelV03: unknown vertexDeclaration.");
                    var m = new be(4 * d.length, i.STATIC_DRAW, !0);
                    m.vertexDeclaration = l, m.setData(d.buffer), ia._mesh._vertexBuffer = m, ia._mesh._vertexCount += m._byteLength / l.vertexStride,
                        n += 4 * d.length;
                }
                var f = o + ia._readData.getUint32(),
                    E = ia._readData.getUint32(),
                    T = new Uint16Array(a.slice(f, f + E)),
                    p = new Ye(e.IndexFormat.UInt16, E / 2, i.STATIC_DRAW, !0);
                p.setData(T), ia._mesh._indexBuffer = p, n += 2 * p.indexCount, ia._mesh._setBuffer(ia._mesh._vertexBuffer, p),
                    ia._mesh._setCPUMemory(n), ia._mesh._setGPUMemory(n);
                var g = ia._mesh._boneNames = [],
                    S = ia._readData.getUint16();
                for (g.length = S, r = 0; r < S; r++) {
                    g[r] = ia._strings[ia._readData.getUint16()];
                }
                ia._readData.pos += 8;
                var R = ia._readData.getUint32(),
                    v = ia._readData.getUint32(),
                    x = new Float32Array(a.slice(o + R, o + R + v)),
                    I = x.length,
                    A = ia._mesh._inverseBindPosesBuffer = new ArrayBuffer(4 * I);
                for (ia._mesh._inverseBindPoses = [], r = 0; r < I; r += 16) {
                    var M = new C(x[r + 0], x[r + 1], x[r + 2], x[r + 3], x[r + 4], x[r + 5], x[r + 6], x[r + 7], x[r + 8], x[r + 9], x[r + 10], x[r + 11], x[r + 12], x[r + 13], x[r + 14], x[r + 15], new Float32Array(A, 4 * r, 16));
                    ia._mesh._inverseBindPoses[r / 16] = M;
                }
                return !0;
            }
        }, {
            key: "READ_SUBMESH",
            value: function READ_SUBMESH() {
                var e = ia._readData.__getBuffer(),
                    t = new ri(ia._mesh);
                ia._readData.getInt16(), ia._readData.getUint32(), ia._readData.getUint32();
                var r = ia._readData.getUint32(),
                    i = ia._readData.getUint32(),
                    a = ia._mesh._indexBuffer;
                t._indexBuffer = a, t._setIndexRange(r, i);
                var n = ia._mesh._vertexBuffer;
                t._vertexBuffer = n;
                var s = ia._DATA.offset,
                    o = t._subIndexBufferStart,
                    l = t._subIndexBufferCount,
                    _ = t._boneIndicesList,
                    h = ia._readData.getUint16();
                o.length = h, l.length = h, _.length = h;
                var c = ia._mesh._skinnedMatrixCaches,
                    d = ia._subMeshes.length;
                c.length = ia._mesh._inverseBindPoses.length;
                for (var u = 0; u < h; u++) {
                    o[u] = ia._readData.getUint32(), l[u] = ia._readData.getUint32();
                    for (var m = ia._readData.getUint32(), f = ia._readData.getUint32(), E = _[u] = new Uint16Array(e.slice(s + m, s + m + f)), T = E.length, p = 0; p < T; p++) {
                        var g = E[p];
                        c[g] || (c[g] = new ii(d, u, p));
                    }
                }
                return ia._subMeshes.push(t), !0;
            }
        }]);
        return ia;
    }();
    ia._BLOCK = {
        count: 0
    }, ia._DATA = {
        offset: 0,
        size: 0
    }, ia._strings = [];
    var aa = /* */ function() {
        function aa() {
            _classCallCheck(this, aa);
        }
        _createClass(aa, null, [{
            key: "parse",
            value: function parse(e, t, r, i) {
                aa._mesh = r, aa._subMeshes = i, aa._version = t, aa._readData = e, aa.READ_DATA(),
                    aa.READ_BLOCK(), aa.READ_STRINGS();
                for (var a = 0, n = aa._BLOCK.count; a < n; a++) {
                    aa._readData.pos = aa._BLOCK.blockStarts[a];
                    var s = aa._readData.getUint16(),
                        o = aa._strings[s],
                        l = aa["READ_" + o];
                    if (null == l) throw new Error("model file err,no this function:" + s + " " + o);
                    l.call(null);
                }
                aa._strings.length = 0, aa._readData = null, aa._version = null, aa._mesh = null,
                    aa._subMeshes = null;
            }
        }, {
            key: "_readString",
            value: function _readString() {
                return aa._strings[aa._readData.getUint16()];
            }
        }, {
            key: "READ_DATA",
            value: function READ_DATA() {
                aa._DATA.offset = aa._readData.getUint32(), aa._DATA.size = aa._readData.getUint32();
            }
        }, {
            key: "READ_BLOCK",
            value: function READ_BLOCK() {
                for (var e = aa._BLOCK.count = aa._readData.getUint16(), t = aa._BLOCK.blockStarts = [], r = aa._BLOCK.blockLengths = [], i = 0; i < e; i++) {
                    t.push(aa._readData.getUint32()), r.push(aa._readData.getUint32());
                }
            }
        }, {
            key: "READ_STRINGS",
            value: function READ_STRINGS() {
                var e = aa._readData.getUint32(),
                    t = aa._readData.getUint16(),
                    r = aa._readData.pos;
                aa._readData.pos = e + aa._DATA.offset;
                for (var i = 0; i < t; i++) {
                    aa._strings[i] = aa._readData.readUTFString();
                }
                aa._readData.pos = r;
            }
        }, {
            key: "READ_MESH",
            value: function READ_MESH() {
                var r, i = t.LayaGL.instance,
                    a = 0,
                    n = (aa._readString(), aa._readData),
                    s = n.__getBuffer(),
                    o = n.getInt16(),
                    l = aa._DATA.offset;
                for (r = 0; r < o; r++) {
                    var _, h, c, d = l + n.getUint32(),
                        u = n.getUint32(),
                        m = aa._readString(),
                        f = ce.getVertexDeclaration(m, !1),
                        E = f.vertexStride,
                        T = m.split(","),
                        p = T.length,
                        S = aa._mesh;
                    switch (aa._version) {
                        case "LAYAMODEL:05":
                        case "LAYAMODEL:0501":
                            _ = s.slice(d, d + u * E), h = new Float32Array(_), c = new Uint8Array(_);
                            break;

                        case "LAYAMODEL:COMPRESSION_05":
                        case "LAYAMODEL:COMPRESSION_0501":
                            _ = new ArrayBuffer(E * u), h = new Float32Array(_), c = new Uint8Array(_);
                            var R = n.pos;
                            n.pos = d;
                            for (var v = 0; v < u; v++) {
                                for (var x, I = v * E, A = 0; A < p; A++) {
                                    switch (T[A]) {
                                        case "POSITION":
                                            h[x = I / 4] = g.convertToNumber(n.getUint16()), h[x + 1] = g.convertToNumber(n.getUint16()),
                                                h[x + 2] = g.convertToNumber(n.getUint16()), I += 12;
                                            break;

                                        case "NORMAL":
                                            h[x = I / 4] = n.getUint8() / 127.5 - 1, h[x + 1] = n.getUint8() / 127.5 - 1, h[x + 2] = n.getUint8() / 127.5 - 1,
                                                I += 12;
                                            break;

                                        case "COLOR":
                                            h[x = I / 4] = n.getUint8() / 255, h[x + 1] = n.getUint8() / 255, h[x + 2] = n.getUint8() / 255,
                                                h[x + 3] = n.getUint8() / 255, I += 16;
                                            break;

                                        case "UV":
                                        case "UV1":
                                            h[x = I / 4] = g.convertToNumber(n.getUint16()), h[x + 1] = g.convertToNumber(n.getUint16()),
                                                I += 8;
                                            break;

                                        case "BLENDWEIGHT":
                                            h[x = I / 4] = n.getUint8() / 255, h[x + 1] = n.getUint8() / 255, h[x + 2] = n.getUint8() / 255,
                                                h[x + 3] = n.getUint8() / 255, I += 16;
                                            break;

                                        case "BLENDINDICES":
                                            c[I] = n.getUint8(), c[I + 1] = n.getUint8(), c[I + 2] = n.getUint8(), c[I + 3] = n.getUint8(),
                                                I += 4;
                                            break;

                                        case "TANGENT":
                                            h[x = I / 4] = n.getUint8() / 127.5 - 1, h[x + 1] = n.getUint8() / 127.5 - 1, h[x + 2] = n.getUint8() / 127.5 - 1,
                                                h[x + 3] = n.getUint8() / 127.5 - 1, I += 16;
                                    }
                                }
                            }
                            n.pos = R;
                    }
                    var M = new be(_.byteLength, i.STATIC_DRAW, !0);
                    M.vertexDeclaration = f, M.setData(_);
                    u = M._byteLength / f.vertexStride;
                    S._indexFormat = u > 65535 ? e.IndexFormat.UInt32 : e.IndexFormat.UInt16, S._vertexBuffer = M,
                        S._vertexCount += u, a += 4 * h.length;
                }
                var D, L = l + n.getUint32(),
                    y = n.getUint32();
                D = S.indexFormat == e.IndexFormat.UInt32 ? new Uint32Array(s.slice(L, L + y)) : new Uint16Array(s.slice(L, L + y));
                var O = new Ye(S.indexFormat, D.length, i.STATIC_DRAW, !0);
                if (O.setData(D), S._indexBuffer = O, S._setBuffer(S._vertexBuffer, O), a += 2 * O.indexCount,
                    S._setCPUMemory(a), S._setGPUMemory(a), "LAYAMODEL:0501" == aa._version || "LAYAMODEL:COMPRESSION_0501" == aa._version) {
                    var N = S.bounds,
                        P = N.getMin(),
                        b = N.getMax();
                    P.setValue(n.getFloat32(), n.getFloat32(), n.getFloat32()), b.setValue(n.getFloat32(), n.getFloat32(), n.getFloat32()),
                        N.setMin(P), N.setMax(b), S.bounds = N;
                }
                var V = S._boneNames = [],
                    w = n.getUint16();
                for (V.length = w, r = 0; r < w; r++) {
                    V[r] = aa._strings[n.getUint16()];
                }
                var F = n.getUint32(),
                    B = n.getUint32(),
                    U = new Float32Array(s.slice(l + F, l + F + B)),
                    G = U.length,
                    z = S._inverseBindPosesBuffer = new ArrayBuffer(4 * G);
                for (S._inverseBindPoses = [], r = 0; r < G; r += 16) {
                    var H = new C(U[r + 0], U[r + 1], U[r + 2], U[r + 3], U[r + 4], U[r + 5], U[r + 6], U[r + 7], U[r + 8], U[r + 9], U[r + 10], U[r + 11], U[r + 12], U[r + 13], U[r + 14], U[r + 15], new Float32Array(z, 4 * r, 16));
                    S._inverseBindPoses[r / 16] = H;
                }
                return !0;
            }
        }, {
            key: "READ_SUBMESH",
            value: function READ_SUBMESH() {
                var e = aa._readData,
                    t = e.__getBuffer(),
                    r = new ri(aa._mesh);
                e.getInt16();
                var i = e.getUint32(),
                    a = e.getUint32(),
                    n = aa._mesh._indexBuffer;
                r._indexBuffer = n, r._setIndexRange(i, a);
                var s = aa._mesh._vertexBuffer;
                r._vertexBuffer = s;
                var o = aa._DATA.offset,
                    l = r._subIndexBufferStart,
                    _ = r._subIndexBufferCount,
                    h = r._boneIndicesList,
                    c = e.getUint16();
                l.length = c, _.length = c, h.length = c;
                var d = aa._mesh._skinnedMatrixCaches,
                    u = aa._subMeshes.length;
                d.length = aa._mesh._inverseBindPoses.length;
                for (var m = 0; m < c; m++) {
                    l[m] = e.getUint32(), _[m] = e.getUint32();
                    for (var f = e.getUint32(), E = e.getUint32(), T = h[m] = new Uint16Array(t.slice(o + f, o + f + E)), p = 0, g = T.length; p < g; p++) {
                        var S = T[p];
                        d[S] || (d[S] = new ii(u, m, p));
                    }
                }
                return aa._subMeshes.push(r), !0;
            }
        }]);
        return aa;
    }();
    aa._BLOCK = {
        count: 0
    }, aa._DATA = {
        offset: 0,
        size: 0
    }, aa._strings = [];
    var na = /* */ function() {
        function na() {
            _classCallCheck(this, na);
        }
        _createClass(na, null, [{
            key: "_parse",
            value: function _parse(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i = new ai();
                return na.read(e, i, i._subMeshes), i;
            }
        }, {
            key: "read",
            value: function read(e, r, i) {
                var a = new t.Byte(e);
                a.pos = 0;
                var n = a.readUTFString();
                switch (n) {
                    case "LAYAMODEL:0301":
                    case "LAYAMODEL:0400":
                    case "LAYAMODEL:0401":
                        ia.parse(a, n, r, i);
                        break;

                    case "LAYAMODEL:05":
                    case "LAYAMODEL:COMPRESSION_05":
                    case "LAYAMODEL:0501":
                    case "LAYAMODEL:COMPRESSION_0501":
                        aa.parse(a, n, r, i);
                        break;

                    default:
                        throw new Error("MeshReader: unknown mesh version.");
                }
                r._setSubMeshes(i), "LAYAMODEL:0501" != n && "LAYAMODEL:COMPRESSION_0501" != n && r.calculateBounds();
            }
        }]);
        return na;
    }();
    var sa = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#define PI 3.14159265359\r\n#include "Lighting.glsl";\r\n\r\nuniform sampler2D u_Texture;\r\nuniform vec4 u_TextureHDRParams;\r\nuniform vec4 u_TintColor;\r\n\r\nvarying vec3 v_Texcoord;\r\nvarying vec2 v_Image180ScaleAndCutoff;\r\nvarying vec4 v_Layout3DScaleAndOffset;\r\n\r\nvec2 ToRadialCoords(vec3 coords)\r\n{\r\n\tvec3 normalizedCoords = normalize(coords);\r\n\tfloat latitude = acos(normalizedCoords.y);\r\n\tfloat longitude = atan(normalizedCoords.z,normalizedCoords.x);\r\n\tvec2 sphereCoords = vec2(longitude, latitude) * vec2(0.5/PI, 1.0/PI);\r\n\treturn vec2(0.5,1.0) - sphereCoords;\r\n}\r\n\r\n\r\nvoid main()\r\n{\t\r\n\tvec2 tc = ToRadialCoords(v_Texcoord);\r\n\tif (tc.x > v_Image180ScaleAndCutoff.y)\r\n\t\tgl_FragColor=vec4(0,0,0,1);\r\n\ttc.x = mod(tc.x*v_Image180ScaleAndCutoff.x, 1.0);\r\n\ttc = (tc + v_Layout3DScaleAndOffset.xy) * v_Layout3DScaleAndOffset.zw;\r\n\r\n\tmediump vec4 tex = texture2D (u_Texture, tc);\r\n\tmediump vec3 c = decodeHDR (tex, u_TextureHDRParams.x);\r\n\tc = c * u_TintColor.rgb * 2.0;//Gamma Space is 2.0,linear space is 4.59479380\r\n\tgl_FragColor=vec4(c, 1.0);\r\n}\r\n\r\n',
        oa = '#include "Lighting.glsl";\r\n\r\n#define PI 3.14159265359\r\n\r\nattribute vec4 a_Position;\r\n\r\nuniform mat4 u_ViewProjection;\r\nuniform float u_Rotation;\r\n\r\nvarying vec3 v_Texcoord;\r\nvarying vec2 v_Image180ScaleAndCutoff;\r\nvarying vec4 v_Layout3DScaleAndOffset;\r\n\r\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\r\n{\r\n\tfloat angle = degrees * PI / 180.0;\r\n\tfloat sina=sin(angle);\r\n\tfloat cosa=cos(angle);\r\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\r\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\r\n}\r\n\r\n\t\t\r\nvoid main()\r\n{\r\n\tvec4 position = rotateAroundYInDegrees(a_Position, u_Rotation);\r\n\tgl_Position = u_ViewProjection*position;\r\n\r\n\tv_Texcoord=vec3(-a_Position.x,-a_Position.y,a_Position.z);// NOTE: -a_Position.x convert coords system\r\n\r\n\t// Calculate constant horizontal scale and cutoff for 180 (vs 360) image type\r\n\tv_Image180ScaleAndCutoff = vec2(1.0, 1.0);// 360 degree mode\r\n\r\n\t// Calculate constant scale and offset for 3D layouts\r\n\tv_Layout3DScaleAndOffset = vec4(0,0,1,1);\r\n}\r\n';
    var la = /* */ function(_j12) {
        _inherits(la, _j12);

        function la() {
            var _this86;
            _classCallCheck(this, la);
            _this86 = _possibleConstructorReturn(this, _getPrototypeOf(la).call(this)), _this86._exposure = 1,
                _this86._textureDecodeFormat = t.TextureDecodeFormat.Normal, _this86._textureHDRParams = new a(1, 0, 0, 1),
                _this86.setShaderName("SkyPanoramic");
            var e = _this86._shaderValues;
            e.setVector(la.TINTCOLOR, new a(.5, .5, .5, .5)), e.setNumber(la.ROTATION, 0), e.setVector(la.TEXTURE_HDR_PARAMS, _this86._textureHDRParams);
            return _this86;
        }
        _createClass(la, [{
            key: "tintColor",
            get: function get() {
                return this._shaderValues.getVector(la.TINTCOLOR);
            },
            set: function set(e) {
                this._shaderValues.setVector(la.TINTCOLOR, e);
            }
        }, {
            key: "exposure",
            get: function get() {
                return this._exposure;
            },
            set: function set(e) {
                this._exposure !== e && (this._exposure = e, this._textureDecodeFormat == t.TextureDecodeFormat.RGBM ? this._textureHDRParams.x = e * t.BaseTexture._rgbmRange : this._textureHDRParams.x = e);
            }
        }, {
            key: "rotation",
            get: function get() {
                return this._shaderValues.getNumber(la.ROTATION);
            },
            set: function set(e) {
                this._shaderValues.setNumber(la.ROTATION, e);
            }
        }, {
            key: "panoramicTexture",
            get: function get() {
                return this._shaderValues.getTexture(la.TEXTURE);
            },
            set: function set(e) {
                this._shaderValues.setTexture(la.TEXTURE, e);
            }
        }, {
            key: "panoramicTextureDecodeFormat",
            get: function get() {
                return this._textureDecodeFormat;
            },
            set: function set(e) {
                this._textureDecodeFormat !== e && (this._textureDecodeFormat = e, e == t.TextureDecodeFormat.RGBM ? this._textureHDRParams.x = this._exposure * t.BaseTexture._rgbmRange : this._textureHDRParams.x = this._exposure);
            }
        }], [{
            key: "__init__",
            value: function __init__() {
                var e = {
                        a_Position: ce.MESH_POSITION0
                    },
                    t = {
                        u_TintColor: H.PERIOD_MATERIAL,
                        u_TextureHDRParams: H.PERIOD_MATERIAL,
                        u_Rotation: H.PERIOD_MATERIAL,
                        u_Texture: H.PERIOD_MATERIAL,
                        u_ViewProjection: H.PERIOD_CAMERA
                    },
                    r = H.add("SkyPanoramic"),
                    i = new oe(e, t);
                r.addSubShader(i), i.addShaderPass(oa, sa);
            }
        }]);
        return la;
    }(j);
    la.TINTCOLOR = H.propertyNameToID("u_TintColor"), la.EXPOSURE = H.propertyNameToID("u_Exposure"),
        la.ROTATION = H.propertyNameToID("u_Rotation"), la.TEXTURE = H.propertyNameToID("u_Texture"),
        la.TEXTURE_HDR_PARAMS = H.propertyNameToID("u_TextureHDRParams");
    var _a = /* */ function() {
        function _a() {
            _classCallCheck(this, _a);
        }
        _createClass(_a, null, [{
            key: "_cancelLoadByUrl",
            value: function _cancelLoadByUrl(e) {
                t.Laya.loader.cancelLoadByUrl(e), _a._innerFirstLevelLoaderManager.cancelLoadByUrl(e),
                    _a._innerSecondLevelLoaderManager.cancelLoadByUrl(e), _a._innerThirdLevelLoaderManager.cancelLoadByUrl(e),
                    _a._innerFourthLevelLoaderManager.cancelLoadByUrl(e);
            }
        }, {
            key: "_changeWebGLSize",
            value: function _changeWebGLSize(e, r) {
                t.WebGL.onStageResize(e, r), w.clientWidth = e, w.clientHeight = r;
            }
        }, {
            key: "__init__",
            value: function __init__(e, r, i) {
                if (t.Config.isAntialias = i.isAntialias, t.Config.isAlpha = i.isAlpha, t.Config.premultipliedAlpha = i.premultipliedAlpha,
                    t.Config.isStencil = i.isStencil, t.WebGL.enable()) {
                    t.RunDriver.changeWebGLSize = _a._changeWebGLSize, t.Render.is3DMode = !0, t.Laya.init(e, r),
                        t.Render.supportWebGLPlusRendering || (t.LayaGL.instance = t.WebGLContext.mainContext,
                            t.LayaGL.instance.createCommandEncoder = function() {
                                var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 128;
                                var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;
                                var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
                                return new t.CommandEncoder(this, e, r, i);
                            }), i._multiLighting = i.enableMultiLight && t.SystemUtils.supportTextureFormat(t.TextureFormat.R32G32B32A32),
                        _.Shader3D = H, _.Scene3D = Br, _.MeshRenderStaticBatchManager = ht, _.MeshRenderDynamicBatchManager = pt,
                        _.SubMeshDynamicBatch = Tt, _.Laya3D = _a, _.Matrix4x4 = C, _a.enableNative3D(),
                        le.__init__(), ce.__init__(), jt.__init__(), qt.__init__(), Ar.__init__(), Wr.__init__(),
                        qr.__init__(), ir.__init__(), Ve.__init__(), Tt.__init__(), x._bullet = window.Physics3D,
                        x._bullet && (ti.__init__(), ur.__init__(), Er.__init__(), Rr.__init__(), vr.__init__(),
                            mr.__init__(), pr.__init__(), Kr.__init__(), ei.__init__()), Qi.__init__(), ee.__init__(),
                        Se.__init__(), de.__init__(), la.__init__(), ai.__init__(), ni.__init__(), Le.__init__(),
                        ye.__init__(), gt.__init__(), zr.__init__(), tr.__init__(), jr.__init__(), W.__init__(),
                        Br.__init__(), ht.__init__(), j.__initDefine__(), q.__initDefine__(), K.__initDefine__(),
                        ve.__initDefine__(), xe.__initDefine__(), Hr.__initDefine__(), J.__initDefine__(),
                        Ie.__initDefine__(), Wt.__initDefine__(), $.__initDefine__(), rr.__initDefine__(),
                        Re.__initDefine__(), $e.__init__(), t.ClassUtils.regClass("Laya.SkyPanoramicMaterial", la),
                        t.ClassUtils.regClass("Laya.EffectMaterial", J), t.ClassUtils.regClass("Laya.UnlitMaterial", xe),
                        t.ClassUtils.regClass("Laya.BlinnPhongMaterial", K), t.ClassUtils.regClass("Laya.SkyProceduralMaterial", ve),
                        t.ClassUtils.regClass("Laya.PBRStandardMaterial", Se), t.ClassUtils.regClass("Laya.PBRSpecularMaterial", de),
                        t.ClassUtils.regClass("Laya.SkyBoxMaterial", Re), t.ClassUtils.regClass("Laya.WaterPrimaryMaterial", Ie),
                        t.ClassUtils.regClass("Laya.ExtendTerrainMaterial", $), t.ClassUtils.regClass("Laya.ShurikenParticleMaterial", Wt),
                        t.ClassUtils.regClass("Laya.TrailMaterial", Hr), t.ClassUtils.regClass("Laya.PhysicsCollider", $r),
                        t.ClassUtils.regClass("Laya.Rigidbody3D", ei), t.ClassUtils.regClass("Laya.CharacterController", Kr),
                        t.ClassUtils.regClass("Laya.Animator", b), t.ClassUtils.regClass("PhysicsCollider", $r),
                        t.ClassUtils.regClass("CharacterController", Kr), t.ClassUtils.regClass("Animator", b),
                        t.ClassUtils.regClass("Rigidbody3D", ei), rr.defaultMaterial = new rr(), K.defaultMaterial = new K(),
                        J.defaultMaterial = new J(), xe.defaultMaterial = new xe(), Wt.defaultMaterial = new Wt(),
                        Hr.defaultMaterial = new Hr(), ve.defaultMaterial = new ve(), Re.defaultMaterial = new Re(),
                        Ie.defaultMaterial = new Ie(), rr.defaultMaterial.lock = !0, K.defaultMaterial.lock = !0,
                        J.defaultMaterial.lock = !0, xe.defaultMaterial.lock = !0, Wt.defaultMaterial.lock = !0,
                        Hr.defaultMaterial.lock = !0, ve.defaultMaterial.lock = !0, Re.defaultMaterial.lock = !0,
                        Ie.defaultMaterial.lock = !0, t.Texture2D.__init__(), Dr.__init__(), je.__init__(),
                        Mr.__init__(), Ke.__init__(), Je.__init__(), Oe.__init__(), g.__init__();
                    var a = t.LoaderManager.createMap;
                    a.lh = [_a.HIERARCHY, ra._parse], a.ls = [_a.HIERARCHY, ra._parseScene], a.lm = [_a.MESH, na._parse],
                        a.lmat = [_a.MATERIAL, j._parse], a.jpg = [_a.TEXTURE2D, t.Texture2D._parse],
                        a.jpeg = [_a.TEXTURE2D, t.Texture2D._parse], a.bmp = [_a.TEXTURE2D, t.Texture2D._parse],
                        a.gif = [_a.TEXTURE2D, t.Texture2D._parse], a.png = [_a.TEXTURE2D, t.Texture2D._parse],
                        a.dds = [_a.TEXTURE2D, t.Texture2D._parse], a.ktx = [_a.TEXTURE2D, t.Texture2D._parse],
                        a.pvr = [_a.TEXTURE2D, t.Texture2D._parse], a.lani = [_a.ANIMATIONCLIP, A._parse],
                        a.lav = [_a.AVATAR, Z._parse], a.ltc = [_a.TEXTURECUBE, Dr._parse], a.ltcb = [_a.TEXTURECUBEBIN, Dr._parseBin];
                    var n = t.Loader.parserMap;
                    n[_a.HIERARCHY] = _a._loadHierarchy, n[_a.MESH] = _a._loadMesh, n[_a.MATERIAL] = _a._loadMaterial,
                        n[_a.TEXTURECUBE] = _a._loadTextureCube, n[_a.TEXTURECUBEBIN] = _a._loadTextureCubeBin,
                        n[_a.TEXTURE2D] = _a._loadTexture2D, n[_a.ANIMATIONCLIP] = _a._loadAnimationClip,
                        n[_a.AVATAR] = _a._loadAvatar, _a._innerFirstLevelLoaderManager.on(t.Event.ERROR, null, _a._eventLoadManagerError),
                        _a._innerSecondLevelLoaderManager.on(t.Event.ERROR, null, _a._eventLoadManagerError),
                        _a._innerThirdLevelLoaderManager.on(t.Event.ERROR, null, _a._eventLoadManagerError),
                        _a._innerFourthLevelLoaderManager.on(t.Event.ERROR, null, _a._eventLoadManagerError);
                } else alert("Laya3D init error,must support webGL!");
            }
        }, {
            key: "enableNative3D",
            value: function enableNative3D() {
                var e = k,
                    r = ne,
                    i = Gr,
                    a = Z,
                    n = Oe;
                if (t.Render.supportWebGLPlusRendering && (e.prototype._initData = e.prototype._initDataForNative,
                        e.prototype.setBool = e.prototype.setBoolForNative, e.prototype.getBool = e.prototype.getBoolForNative,
                        e.prototype.setInt = e.prototype.setIntForNative, e.prototype.getInt = e.prototype.getIntForNative,
                        e.prototype.setNumber = e.prototype.setNumberForNative, e.prototype.getNumber = e.prototype.getNumberForNative,
                        e.prototype.setVector = e.prototype.setVectorForNative, e.prototype.getVector = e.prototype.getVectorForNative,
                        e.prototype.setVector2 = e.prototype.setVector2ForNative, e.prototype.getVector2 = e.prototype.getVector2ForNative,
                        e.prototype.setVector3 = e.prototype.setVector3ForNative, e.prototype.getVector3 = e.prototype.getVector3ForNative,
                        e.prototype.setQuaternion = e.prototype.setQuaternionForNative, e.prototype.getQuaternion = e.prototype.getQuaternionForNative,
                        e.prototype.setMatrix4x4 = e.prototype.setMatrix4x4ForNative, e.prototype.getMatrix4x4 = e.prototype.getMatrix4x4ForNative,
                        e.prototype.setBuffer = e.prototype.setBufferForNative, e.prototype.getBuffer = e.prototype.getBufferForNative,
                        e.prototype.setTexture = e.prototype.setTextureForNative, e.prototype.getTexture = e.prototype.getTextureForNative,
                        e.prototype.setAttribute = e.prototype.setAttributeForNative, e.prototype.getAttribute = e.prototype.getAttributeForNative,
                        e.prototype.cloneTo = e.prototype.cloneToForNative, e.prototype.getData = e.prototype.getDataForNative,
                        r.prototype._uniformMatrix2fv = r.prototype._uniformMatrix2fvForNative, r.prototype._uniformMatrix3fv = r.prototype._uniformMatrix3fvForNative,
                        r.prototype._uniformMatrix4fv = r.prototype._uniformMatrix4fvForNative, t.LayaGLRunner.uploadShaderUniforms = t.LayaGLRunner.uploadShaderUniformsForNative),
                    t.Render.supportWebGLPlusCulling && (n.renderObjectCulling = Oe.renderObjectCullingNative),
                    t.Render.supportWebGLPlusAnimation) {
                    a.prototype._cloneDatasToAnimator = a.prototype._cloneDatasToAnimatorNative;
                    var s = A;
                    s.prototype._evaluateClipDatasRealTime = s.prototype._evaluateClipDatasRealTimeForNative,
                        i.prototype._computeSkinnedData = i.prototype._computeSkinnedDataForNative;
                }
            }
        }, {
            key: "formatRelativePath",
            value: function formatRelativePath(e, t) {
                var r;
                if (r = e + t, "." === t.charAt(0)) {
                    for (var i = r.split("/"), a = 0, n = i.length; a < n; a++) {
                        if (".." == i[a]) {
                            var s = a - 1;
                            s > 0 && ".." !== i[s] && (i.splice(s, 2), a -= 2);
                        }
                    }
                    r = i.join("/");
                }
                return r;
            }
        }, {
            key: "_endLoad",
            value: function _endLoad(e) {
                var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                if (i)
                    for (var a = 0, n = i.length; a < n; a++) {
                        var s = t.Loader.getRes(i[a]);
                        s && s._removeReference();
                    }
                e.endLoad(r);
            }
        }, {
            key: "_eventLoadManagerError",
            value: function _eventLoadManagerError(e) {
                t.Laya.loader.event(t.Event.ERROR, e);
            }
        }, {
            key: "_addHierarchyInnerUrls",
            value: function _addHierarchyInnerUrls(e, t, r, i, a, n) {
                var s = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
                var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
                var l = _a.formatRelativePath(i, a);
                return r && (l += r), e.push({
                    url: l,
                    type: n,
                    constructParams: s,
                    propertyParams: o
                }), t.push(l), l;
            }
        }, {
            key: "_getSprite3DHierarchyInnerUrls",
            value: function _getSprite3DHierarchyInnerUrls(e, t, r, i, a, n, s, o) {
                var l, _, h = e.props;
                switch (e.type) {
                    case "Scene3D":
                        var c = h.lightmaps;
                        for (l = 0, _ = c.length; l < _; l++) {
                            var d = c[l];
                            d.path = _a._addHierarchyInnerUrls(a, n, s, o, d.path, _a.TEXTURE2D, d.constructParams, d.propertyParams);
                        }
                        var u = h.reflectionTexture;
                        u && (h.reflection = _a._addHierarchyInnerUrls(i, n, s, o, u, _a.TEXTURECUBE));
                        var m = h.reflection;
                        if (m && (h.reflection = _a._addHierarchyInnerUrls(a, n, s, o, m, _a.TEXTURECUBEBIN)),
                            h.sky) {
                            var f = h.sky.material;
                            f && (f.path = _a._addHierarchyInnerUrls(r, n, s, o, f.path, _a.MATERIAL));
                        }
                        break;

                    case "Camera":
                        var E = h.skyboxMaterial;
                        E && (E.path = _a._addHierarchyInnerUrls(r, n, s, o, E.path, _a.MATERIAL));
                        break;

                    case "TrailSprite3D":
                    case "MeshSprite3D":
                    case "SkinnedMeshSprite3D":
                        var T = h.meshPath;
                        T && (h.meshPath = _a._addHierarchyInnerUrls(t, n, s, o, T, _a.MESH));
                        var p = h.materials;
                        if (p)
                            for (l = 0, _ = p.length; l < _; l++) {
                                p[l].path = _a._addHierarchyInnerUrls(r, n, s, o, p[l].path, _a.MATERIAL);
                            }
                        break;

                    case "ShuriKenParticle3D":
                        if (h.main) {
                            var g = h.renderer.resources,
                                S = g.mesh,
                                R = g.material;
                            S && (g.mesh = _a._addHierarchyInnerUrls(t, n, s, o, S, _a.MESH)), R && (g.material = _a._addHierarchyInnerUrls(r, n, s, o, R, _a.MATERIAL));
                        } else {
                            var v = h.meshPath;
                            v && (h.meshPath = _a._addHierarchyInnerUrls(t, n, s, o, v, _a.MESH)), h.material.path = _a._addHierarchyInnerUrls(r, n, s, o, h.material.path, _a.MATERIAL);
                        }
                        break;

                    case "Terrain":
                        _a._addHierarchyInnerUrls(a, n, s, o, h.dataPath, _a.TERRAINRES);
                }
                var x = e.components;
                if (x)
                    for (var I = 0, A = x.length; I < A; I++) {
                        var M = x[I];
                        switch (M.type) {
                            case "Animator":
                                M.avatarPath;
                                var D = M.avatar;
                                D && (D.path = _a._addHierarchyInnerUrls(a, n, s, o, D.path, _a.AVATAR));
                                var L = M.clipPaths;
                                if (L)
                                    for (l = 0, _ = L.length; l < _; l++) {
                                        L[l] = _a._addHierarchyInnerUrls(a, n, s, o, L[l], _a.ANIMATIONCLIP);
                                    } else {
                                        var y = M.layers;
                                        for (l = 0; l < y.length; l++) {
                                            for (var C = y[l].states, O = 0, N = C.length; O < N; O++) {
                                                var P = C[O].clipPath;
                                                P && (C[O].clipPath = _a._addHierarchyInnerUrls(a, n, s, o, P, _a.ANIMATIONCLIP));
                                            }
                                        }
                                    }
                                break;

                            case "PhysicsCollider":
                            case "Rigidbody3D":
                            case "CharacterController":
                                var b = M.shapes;
                                for (l = 0; l < b.length; l++) {
                                    var V = b[l];
                                    if ("MeshColliderShape" === V.type)(S = V.mesh) && (V.mesh = _a._addHierarchyInnerUrls(t, n, s, o, S, _a.MESH));
                                }
                        }
                    }
                var w = e.child;
                for (l = 0, _ = w.length; l < _; l++) {
                    _a._getSprite3DHierarchyInnerUrls(w[l], t, r, i, a, n, s, o);
                }
            }
        }, {
            key: "_loadHierarchy",
            value: function _loadHierarchy(e) {
                e.on(t.Event.LOADED, null, _a._onHierarchylhLoaded, [e]), e.load(e.url, t.Loader.JSON, !1, null, !0);
            }
        }, {
            key: "_onHierarchylhLoaded",
            value: function _onHierarchylhLoaded(e, r) {
                var i = e.url,
                    a = I.getURLVerion(i),
                    n = t.URL.getPath(i),
                    s = [],
                    o = [],
                    l = [],
                    _ = [],
                    h = [];
                _a._getSprite3DHierarchyInnerUrls(r.data, s, o, l, _, h, a, n);
                var c = s.length + o.length + _.length,
                    d = c + 1,
                    u = 1 / d;
                if (_a._onProcessChange(e, 0, u, 1), _.length > 0) {
                    var m = c / d,
                        f = t.Handler.create(null, _a._onProcessChange, [e, u, m], !1);
                    _a._innerFourthLevelLoaderManager._create(_, !1, t.Handler.create(null, _a._onHierarchyInnerForthLevResouLoaded, [e, f, r, h, s, o, l, u + m * _.length, m]), f, null, null, null, 1, !0);
                } else _a._onHierarchyInnerForthLevResouLoaded(e, null, r, h, s, o, l, u, m);
            }
        }, {
            key: "_onHierarchyInnerForthLevResouLoaded",
            value: function _onHierarchyInnerForthLevResouLoaded(e, r, i, a, n, s, o, l, _) {
                if (r && r.recover(), o.length > 0) {
                    var h = t.Handler.create(null, _a._onProcessChange, [e, l, _], !1);
                    _a._innerThirdLevelLoaderManager._create(o, !1, t.Handler.create(null, _a._onHierarchyInnerThirdLevResouLoaded, [e, h, i, a, n, s, l + _ * s.length, _]), r, null, null, null, 1, !0);
                } else _a._onHierarchyInnerThirdLevResouLoaded(e, null, i, a, n, s, l, _);
            }
        }, {
            key: "_onHierarchyInnerThirdLevResouLoaded",
            value: function _onHierarchyInnerThirdLevResouLoaded(e, r, i, a, n, s, o, l) {
                if (r && r.recover(), s.length > 0) {
                    var _ = t.Handler.create(null, _a._onProcessChange, [e, o, l], !1);
                    _a._innerSecondLevelLoaderManager._create(s, !1, t.Handler.create(null, _a._onHierarchyInnerSecondLevResouLoaded, [e, _, i, a, n, o + l * s.length, l]), r, null, null, null, 1, !0);
                } else _a._onHierarchyInnerSecondLevResouLoaded(e, null, i, a, n, o, l);
            }
        }, {
            key: "_onHierarchyInnerSecondLevResouLoaded",
            value: function _onHierarchyInnerSecondLevResouLoaded(e, r, i, a, n, s, o) {
                if (r && r.recover(), n.length > 0) {
                    var l = t.Handler.create(null, _a._onProcessChange, [e, s, o], !1);
                    _a._innerFirstLevelLoaderManager._create(n, !1, t.Handler.create(null, _a._onHierarchyInnerFirstLevResouLoaded, [e, l, i, a]), r, null, null, null, 1, !0);
                } else _a._onHierarchyInnerFirstLevResouLoaded(e, null, i, a);
            }
        }, {
            key: "_onHierarchyInnerFirstLevResouLoaded",
            value: function _onHierarchyInnerFirstLevResouLoaded(e, t, r, i) {
                t && t.recover(), e._cache = e._createCache;
                var a = "Scene3D" === r.data.type ? ra._parseScene(r, e._propertyParams, e._constructParams) : ra._parse(r, e._propertyParams, e._constructParams);
                _a._endLoad(e, a, i);
            }
        }, {
            key: "_loadMesh",
            value: function _loadMesh(e) {
                e.on(t.Event.LOADED, null, _a._onMeshLmLoaded, [e]), e.load(e.url, t.Loader.BUFFER, !1, null, !0);
            }
        }, {
            key: "_onMeshLmLoaded",
            value: function _onMeshLmLoaded(e, t) {
                e._cache = e._createCache;
                var r = na._parse(t, e._propertyParams, e._constructParams);
                _a._endLoad(e, r);
            }
        }, {
            key: "_loadMaterial",
            value: function _loadMaterial(e) {
                e.on(t.Event.LOADED, null, _a._onMaterilLmatLoaded, [e]), e.load(e.url, t.Loader.JSON, !1, null, !0);
            }
        }, {
            key: "_onMaterilLmatLoaded",
            value: function _onMaterilLmatLoaded(e, r) {
                var i, a = e.url,
                    n = I.getURLVerion(a),
                    s = t.URL.getPath(a),
                    o = [],
                    l = [];
                r.customProps;
                switch (r.version) {
                    case "LAYAMATERIAL:01":
                    case "LAYAMATERIAL:02":
                        var _, h, c = r.props.textures;
                        if (c)
                            for (_ = 0, h = c.length; _ < h; _++) {
                                var d = c[_],
                                    u = d.path;
                                u && (i = _a.formatRelativePath(s, u), n && (i += n), o.push({
                                    url: i,
                                    constructParams: d.constructParams,
                                    propertyParams: d.propertyParams
                                }), l.push(i), d.path = i);
                            }
                        break;

                    default:
                        throw new Error("Laya3D:unkonwn version.");
                }
                var m = o.length,
                    f = m + 1,
                    E = 1 / f;
                if (_a._onProcessChange(e, 0, E, 1), m > 0) {
                    var T = t.Handler.create(null, _a._onProcessChange, [e, E, m / f], !1);
                    _a._innerFourthLevelLoaderManager._create(o, !1, t.Handler.create(null, _a._onMateialTexturesLoaded, [e, T, r, l]), T, null, null, null, 1, !0);
                } else _a._onMateialTexturesLoaded(e, null, r, null);
            }
        }, {
            key: "_onMateialTexturesLoaded",
            value: function _onMateialTexturesLoaded(e, t, r, i) {
                e._cache = e._createCache;
                var a = j._parse(r, e._propertyParams, e._constructParams);
                _a._endLoad(e, a, i), t && t.recover();
            }
        }, {
            key: "_loadAvatar",
            value: function _loadAvatar(e) {
                e.on(t.Event.LOADED, null, function(t) {
                    e._cache = e._createCache;
                    var r = Z._parse(t, e._propertyParams, e._constructParams);
                    _a._endLoad(e, r);
                }), e.load(e.url, t.Loader.JSON, !1, null, !0);
            }
        }, {
            key: "_loadAnimationClip",
            value: function _loadAnimationClip(e) {
                e.on(t.Event.LOADED, null, function(t) {
                    e._cache = e._createCache;
                    var r = A._parse(t, e._propertyParams, e._constructParams);
                    _a._endLoad(e, r);
                }), e.load(e.url, t.Loader.BUFFER, !1, null, !0);
            }
        }, {
            key: "_loadTexture2D",
            value: function _loadTexture2D(e) {
                var r, i = e.url,
                    a = i.lastIndexOf(".") + 1,
                    n = i.indexOf("?"),
                    s = -1 == n ? i.length : n;
                switch (i.substr(a, s - a)) {
                    case "jpg":
                    case "jpeg":
                    case "bmp":
                    case "gif":
                    case "png":
                        r = "nativeimage";
                        break;

                    case "dds":
                    case "ktx":
                    case "pvr":
                        r = t.Loader.BUFFER;
                }
                e.on(t.Event.LOADED, null, function(r) {
                    e._cache = e._createCache;
                    var i = t.Texture2D._parse(r, e._propertyParams, e._constructParams);
                    _a._endLoad(e, i);
                }), e.load(e.url, r, !1, null, !0);
            }
        }, {
            key: "_loadTextureCube",
            value: function _loadTextureCube(e) {
                e.on(t.Event.LOADED, null, _a._onTextureCubeLtcLoaded, [e]), e.load(e.url, t.Loader.JSON, !1, null, !0);
            }
        }, {
            key: "_loadTextureCubeBin",
            value: function _loadTextureCubeBin(e) {
                e.on(t.Event.LOADED, null, function(r) {
                    e._cache = e._createCache;
                    var i = new t.Byte(r);
                    if ("LAYATEXTURECUBE:0000" !== i.readUTFString()) throw "Laya3D:unknow version.";
                    var a = i.readUint8(),
                        n = i.getUint8(),
                        s = i.readUint16(),
                        o = i.getUint8(),
                        l = i.getUint8(),
                        _ = i.getUint8(),
                        h = i.getUint8(),
                        c = new Dr(s, a, n > 1);
                    c.filterMode = o, c.wrapModeU = l, c.wrapModeV = _, c.anisoLevel = h;
                    for (var d = i.pos, u = s, m = 0; m < n; m++) {
                        for (var f = new Array(6), E = u * u * c._getFormatByteCount(), T = 0; T < 6; T++) {
                            f[T] = new Uint8Array(r, d, E), d += E;
                        }
                        c.setSixSidePixels(f, m), u /= 2;
                    }
                    _a._endLoad(e, c);
                }), e.load(e.url, t.Loader.BUFFER, !1, null, !0);
            }
        }, {
            key: "_onTextureCubeLtcLoaded",
            value: function _onTextureCubeLtcLoaded(e, r) {
                var i = t.URL.getPath(e.url),
                    a = [_a.formatRelativePath(i, r.front), _a.formatRelativePath(i, r.back), _a.formatRelativePath(i, r.left), _a.formatRelativePath(i, r.right), _a.formatRelativePath(i, r.up), _a.formatRelativePath(i, r.down)];
                _a._onProcessChange(e, 0, 1 / 7, 1);
                var n = t.Handler.create(null, _a._onProcessChange, [e, 1 / 7, 6 / 7], !1);
                _a._innerFourthLevelLoaderManager.load(a, t.Handler.create(null, _a._onTextureCubeImagesLoaded, [e, a, n]), n, "nativeimage");
            }
        }, {
            key: "_onTextureCubeImagesLoaded",
            value: function _onTextureCubeImagesLoaded(e, r, i) {
                for (var a = new Array(6), n = 0; n < 6; n++) {
                    a[n] = t.Loader.getRes(r[n]);
                }
                e._cache = e._createCache;
                var s = Dr._parse(a, e._propertyParams, e._constructParams);
                for (i.recover(), n = 0; n < 6; n++) {
                    t.Loader.clearRes(r[n]);
                }
                _a._endLoad(e, s);
            }
        }, {
            key: "_onProcessChange",
            value: function _onProcessChange(e, r, i, a) {
                (a = r + a * i) < 1 && e.event(t.Event.PROGRESS, a);
            }
        }, {
            key: "init",
            value: function init(e, t) {
                var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                if (_a._isInit) i && i.run();
                else {
                    _a._isInit = !0, r && r.cloneTo(l._config), r = l._config, Oe.debugFrustumCulling = r.debugFrustumCulling,
                        _a._editerEnvironment = r._editerEnvironment, Br.octreeCulling = r.octreeCulling,
                        Br.octreeInitialSize = r.octreeInitialSize, Br.octreeInitialCenter = r.octreeInitialCenter,
                        Br.octreeMinNodeSize = r.octreeMinNodeSize, Br.octreeLooseness = r.octreeLooseness;
                    var a = window.Physics3D;
                    null == a ? (x._enablePhysics = !1, _a.__init__(e, t, r), i && i.run()) : (x._enablePhysics = !0,
                        a(16 * r.defaultPhysicsMemory, Qr._interactive).then(function() {
                            _a.__init__(e, t, r), i && i.run();
                        }));
                }
            }
        }, {
            key: "enablePhysics",
            get: function get() {
                return x._enablePhysics;
            }
        }]);
        return _a;
    }();
    _a.HIERARCHY = "HIERARCHY", _a.MESH = "MESH", _a.MATERIAL = "MATERIAL", _a.TEXTURE2D = "TEXTURE2D",
        _a.TEXTURECUBE = "TEXTURECUBE", _a.TEXTURECUBEBIN = "TEXTURECUBEBIN", _a.ANIMATIONCLIP = "ANIMATIONCLIP",
        _a.AVATAR = "AVATAR", _a.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA", _a.TERRAINRES = "TERRAIN",
        _a._innerFirstLevelLoaderManager = new t.LoaderManager(), _a._innerSecondLevelLoaderManager = new t.LoaderManager(),
        _a._innerThirdLevelLoaderManager = new t.LoaderManager(), _a._innerFourthLevelLoaderManager = new t.LoaderManager(),
        _a._isInit = !1, _a._editerEnvironment = !1, _a.physicsSettings = new Ir(), window.Laya3D = _a;
    var ha = /* */ function(_t$Component3) {
        _inherits(ha, _t$Component3);

        function ha() {
            var _this87;
            _classCallCheck(this, ha);
            _this87 = _possibleConstructorReturn(this, _getPrototypeOf(ha).apply(this, arguments)),
                _this87._indexInPool = -1;
            return _this87;
        }
        _createClass(ha, [{
            key: "_checkProcessTriggers",
            value: function _checkProcessTriggers() {
                var e = ha.prototype;
                return this.onTriggerEnter !== e.onTriggerEnter || this.onTriggerStay !== e.onTriggerStay || this.onTriggerExit !== e.onTriggerExit;
            }
        }, {
            key: "_checkProcessCollisions",
            value: function _checkProcessCollisions() {
                var e = ha.prototype;
                return this.onCollisionEnter !== e.onCollisionEnter || this.onCollisionStay !== e.onCollisionStay || this.onCollisionExit !== e.onCollisionExit;
            }
        }, {
            key: "_onAwake",
            value: function _onAwake() {
                this.onAwake(), this.onStart !== ha.prototype.onStart && t.Laya.startTimer.callLater(this, this.onStart);
            }
        }, {
            key: "_onEnable",
            value: function _onEnable() {
                this.owner._scene._addScript(this), this.onEnable();
            }
        }, {
            key: "_onDisable",
            value: function _onDisable() {
                this.owner._scene._removeScript(this), this.owner.offAllCaller(this), this.onDisable();
            }
        }, {
            key: "_onDestroy",
            value: function _onDestroy() {
                var e = this.owner._scripts;
                e.splice(e.indexOf(this), 1);
                var t = this.owner;
                t._needProcessTriggers = !1;
                for (var r = 0, i = e.length; r < i; r++) {
                    if (e[r]._checkProcessTriggers()) {
                        t._needProcessTriggers = !0;
                        break;
                    }
                }
                for (t._needProcessCollisions = !1, r = 0, i = e.length; r < i; r++) {
                    if (e[r]._checkProcessCollisions()) {
                        t._needProcessCollisions = !0;
                        break;
                    }
                }
                this.onDestroy();
            }
        }, {
            key: "_isScript",
            value: function _isScript() {
                return !0;
            }
        }, {
            key: "_onAdded",
            value: function _onAdded() {
                var e = this.owner,
                    t = e._scripts;
                t || (e._scripts = t = []), t.push(this), e._needProcessCollisions || (e._needProcessCollisions = this._checkProcessCollisions()),
                    e._needProcessTriggers || (e._needProcessTriggers = this._checkProcessTriggers());
            }
        }, {
            key: "onAwake",
            value: function onAwake() {}
        }, {
            key: "onEnable",
            value: function onEnable() {}
        }, {
            key: "onStart",
            value: function onStart() {}
        }, {
            key: "onTriggerEnter",
            value: function onTriggerEnter(e) {}
        }, {
            key: "onTriggerStay",
            value: function onTriggerStay(e) {}
        }, {
            key: "onTriggerExit",
            value: function onTriggerExit(e) {}
        }, {
            key: "onCollisionEnter",
            value: function onCollisionEnter(e) {}
        }, {
            key: "onCollisionStay",
            value: function onCollisionStay(e) {}
        }, {
            key: "onCollisionExit",
            value: function onCollisionExit(e) {}
        }, {
            key: "onMouseDown",
            value: function onMouseDown() {}
        }, {
            key: "onMouseDrag",
            value: function onMouseDrag() {}
        }, {
            key: "onMouseClick",
            value: function onMouseClick() {}
        }, {
            key: "onMouseUp",
            value: function onMouseUp() {}
        }, {
            key: "onMouseEnter",
            value: function onMouseEnter() {}
        }, {
            key: "onMouseOver",
            value: function onMouseOver() {}
        }, {
            key: "onMouseOut",
            value: function onMouseOut() {}
        }, {
            key: "onUpdate",
            value: function onUpdate() {}
        }, {
            key: "onLateUpdate",
            value: function onLateUpdate() {}
        }, {
            key: "onPreRender",
            value: function onPreRender() {}
        }, {
            key: "onPostRender",
            value: function onPostRender() {}
        }, {
            key: "onDisable",
            value: function onDisable() {}
        }, {
            key: "onDestroy",
            value: function onDestroy() {}
        }, {
            key: "isSingleton",
            get: function get() {
                return !1;
            }
        }]);
        return ha;
    }(t.Component);
    var ca = /* */ function() {
        function ca(e, t, r, i) {
            _classCallCheck(this, ca);
            this._datas = [], this._w = e, this._h = t, this._minHeight = r, this._maxHeight = i;
        }
        _createClass(ca, [{
            key: "_inBounds",
            value: function _inBounds(e, t) {
                return e >= 0 && e < this._h && t >= 0 && t < this._w;
            }
        }, {
            key: "getHeight",
            value: function getHeight(e, t) {
                return this._inBounds(e, t) ? this._datas[e][t] : NaN;
            }
        }, {
            key: "width",
            get: function get() {
                return this._w;
            }
        }, {
            key: "height",
            get: function get() {
                return this._h;
            }
        }, {
            key: "maxHeight",
            get: function get() {
                return this._maxHeight;
            }
        }, {
            key: "minHeight",
            get: function get() {
                return this._minHeight;
            }
        }], [{
            key: "creatFromMesh",
            value: function creatFromMesh(e, t, r, i) {
                for (var a = [], s = [], o = e.subMeshCount, l = 0; l < o; l++) {
                    for (var _ = e.getSubMesh(l), h = _._vertexBuffer, c = h.getFloat32Data(), d = [], u = 0; u < c.length; u += h.vertexDeclaration.vertexStride / 4) {
                        var m = new n(c[u + 0], c[u + 1], c[u + 2]);
                        d.push(m);
                    }
                    a.push(d);
                    var f = _._indexBuffer;
                    s.push(f.getData());
                }
                var E = e.bounds,
                    T = E.getMin().x,
                    p = E.getMin().z,
                    g = E.getMax().x,
                    S = E.getMax().z,
                    R = E.getMin().y,
                    v = E.getMax().y,
                    x = g - T,
                    I = S - p,
                    A = i.x = x / (t - 1),
                    M = i.y = I / (r - 1),
                    D = new ca(t, r, R, v),
                    L = ca._tempRay,
                    y = L.direction;
                y.x = 0, y.y = -1, y.z = 0;
                var C = v + .1;
                L.origin.y = C;
                for (var O = 0; O < r; O++) {
                    var N = p + O * M;
                    D._datas[O] = [];
                    for (var P = 0; P < t; P++) {
                        var b = T + P * A,
                            V = L.origin;
                        V.x = b, V.z = N;
                        var w = ca._getPosition(L, a, s);
                        D._datas[O][P] = w === Number.MAX_VALUE ? NaN : C - w;
                    }
                }
                return D;
            }
        }, {
            key: "createFromImage",
            value: function createFromImage(e, t, r) {
                for (var i = e.width, a = e.height, n = new ca(i, a, t, r), s = (r - t) / 254, o = e.getPixels(), l = 0, _ = 0; _ < a; _++) {
                    for (var h = n._datas[_] = [], c = 0; c < i; c++) {
                        var d = o[l++],
                            u = o[l++],
                            m = o[l++],
                            f = o[l++];
                        h[c] = 255 == d && 255 == u && 255 == m && 255 == f ? NaN : (d + u + m) / 3 * s + t;
                    }
                }
                return n;
            }
        }, {
            key: "_getPosition",
            value: function _getPosition(e, t, r) {
                for (var i = Number.MAX_VALUE, a = 0; a < t.length; a++) {
                    for (var n = t[a], s = r[a], o = 0; o < s.length; o += 3) {
                        var l = n[s[o + 0]],
                            _ = n[s[o + 1]],
                            h = n[s[o + 2]],
                            c = We.rayIntersectsTriangle(e, l, _, h);
                        !isNaN(c) && c < i && (i = c);
                    }
                }
                return i;
            }
        }]);
        return ca;
    }();
    ca._tempRay = new Ue(new n(), new n());
    var da = /* */ function(_gt) {
        _inherits(da, _gt);

        function da(e, t) {
            var _this88;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
            _classCallCheck(this, da);
            _this88 = _possibleConstructorReturn(this, _getPrototypeOf(da).call(this, e, r)),
                _this88._heightMap = t, _this88._cellSize = new i();
            return _this88;
        }
        _createClass(da, [{
            key: "_disableRotation",
            value: function _disableRotation() {
                var e = this.transform.rotation;
                e.x = 0, e.y = 0, e.z = 0, e.w = 1, this.transform.rotation = e;
            }
        }, {
            key: "_getScaleX",
            value: function _getScaleX() {
                var e = this.transform.worldMatrix.elements,
                    t = e[0],
                    r = e[1],
                    i = e[2];
                return Math.sqrt(t * t + r * r + i * i);
            }
        }, {
            key: "_getScaleZ",
            value: function _getScaleZ() {
                var e = this.transform.worldMatrix.elements,
                    t = e[8],
                    r = e[9],
                    i = e[10];
                return Math.sqrt(t * t + r * r + i * i);
            }
        }, {
            key: "_initCreateFromMesh",
            value: function _initCreateFromMesh(e, t) {
                this._heightMap = ca.creatFromMesh(this.meshFilter.sharedMesh, e, t, this._cellSize);
                var r = this.meshFilter.sharedMesh.bounds,
                    i = r.getMin();
                r.getMax();
                this._minX = i.x, this._minZ = i.z;
            }
        }, {
            key: "_initCreateFromMeshHeightMap",
            value: function _initCreateFromMeshHeightMap(e, t, r) {
                var i = this.meshFilter.sharedMesh.bounds;
                this._heightMap = ca.createFromImage(e, t, r), this._computeCellSize(i);
                var a = i.getMin();
                i.getMax();
                this._minX = a.x, this._minZ = a.z;
            }
        }, {
            key: "_computeCellSize",
            value: function _computeCellSize(e) {
                var t = e.getMin(),
                    r = e.getMax(),
                    i = t.x,
                    a = t.z,
                    n = r.x - i,
                    s = r.z - a;
                this._cellSize.x = n / (this._heightMap.width - 1), this._cellSize.y = s / (this._heightMap.height - 1);
            }
        }, {
            key: "_update",
            value: function _update(e) {
                this._disableRotation();
            }
        }, {
            key: "getHeight",
            value: function getHeight(e, t) {
                da._tempVector3.x = e, da._tempVector3.y = 0, da._tempVector3.z = t, this._disableRotation();
                var r = this.transform.worldMatrix;
                r.invert(da._tempMatrix4x4), n.transformCoordinate(da._tempVector3, da._tempMatrix4x4, da._tempVector3),
                    e = da._tempVector3.x, t = da._tempVector3.z;
                var i = (e - this._minX) / this._cellSize.x,
                    a = (t - this._minZ) / this._cellSize.y,
                    s = Math.floor(a),
                    o = Math.floor(i),
                    l = i - o,
                    _ = a - s,
                    h = r.elements,
                    c = h[4],
                    d = h[5],
                    u = h[6],
                    m = Math.sqrt(c * c + d * d + u * u),
                    f = h[13],
                    E = this._heightMap.getHeight(s, o + 1),
                    T = this._heightMap.getHeight(s + 1, o);
                if (isNaN(E) || isNaN(T)) return NaN;
                if (l + _ <= 1) {
                    var p = this._heightMap.getHeight(s, o);
                    return isNaN(p) ? NaN : (p + l * (E - p) + _ * (T - p)) * m + f;
                }
                var g = this._heightMap.getHeight(s + 1, o + 1);
                return isNaN(g) ? NaN : (g + (1 - l) * (T - g) + (1 - _) * (E - g)) * m + f;
            }
        }, {
            key: "minX",
            get: function get() {
                var e = this.transform.worldMatrix.elements;
                return this._minX * this._getScaleX() + e[12];
            }
        }, {
            key: "minZ",
            get: function get() {
                var e = this.transform.worldMatrix.elements;
                return this._minZ * this._getScaleZ() + e[14];
            }
        }, {
            key: "width",
            get: function get() {
                return (this._heightMap.width - 1) * this._cellSize.x * this._getScaleX();
            }
        }, {
            key: "depth",
            get: function get() {
                return (this._heightMap.height - 1) * this._cellSize.y * this._getScaleZ();
            }
        }], [{
            key: "createFromMesh",
            value: function createFromMesh(e, t, r) {
                var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                var a = new da(e, null, i);
                return a._initCreateFromMesh(t, r), a;
            }
        }, {
            key: "createFromMeshAndHeightMap",
            value: function createFromMeshAndHeightMap(e, t, r, i) {
                var a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
                var n = new da(e, null, a);
                return n._initCreateFromMeshHeightMap(t, r, i), n;
            }
        }]);
        return da;
    }(gt);
    da._tempVector3 = new n(), da._tempMatrix4x4 = new C();
    var ua = /* */ function() {
        function ua() {
            _classCallCheck(this, ua);
            this._currentLength = 0, this._elements = new Float32Array(12);
        }
        _createClass(ua, [{
            key: "add",
            value: function add(e, t) {
                this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("GradientDataVector2 warning:the forth key is  be force set to 1.")),
                    this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t.x,
                    this._elements[this._currentLength++] = t.y) : console.log("GradientDataVector2 warning:data count must lessEqual than 4");
            }
        }, {
            key: "cloneTo",
            value: function cloneTo(e) {
                var t = e;
                t._currentLength = this._currentLength;
                for (var r = t._elements, i = 0, a = this._elements.length; i < a; i++) {
                    r[i] = this._elements[i];
                }
            }
        }, {
            key: "clone",
            value: function clone() {
                var e = new ua();
                return this.cloneTo(e), e;
            }
        }, {
            key: "gradientCount",
            get: function get() {
                return this._currentLength / 3;
            }
        }]);
        return ua;
    }();
    var ma = /* */ function() {
        function ma() {
            _classCallCheck(this, ma);
        }
        _createClass(ma, [{
            key: "render",
            value: function render(e) {}
        }]);
        return ma;
    }();
    var fa = /* */ function(_ma) {
        _inherits(fa, _ma);

        function fa() {
            var _this89;
            _classCallCheck(this, fa);
            _this89 = _possibleConstructorReturn(this, _getPrototypeOf(fa).call(this)), _this89._shader = null,
                _this89._shaderData = new k(), _this89._linearColor = new Ae(), _this89._bloomTextureTexelSize = new a(),
                _this89._shaderThreshold = new a(), _this89._shaderParams = new a(), _this89._pyramid = null,
                _this89._intensity = 0, _this89._threshold = 1, _this89._softKnee = .5, _this89._diffusion = 7,
                _this89._anamorphicRatio = 0, _this89._dirtIntensity = 0, _this89._shaderSetting = new a(),
                _this89._dirtTileOffset = new a(), _this89.clamp = 65472, _this89.color = new Ae(1, 1, 1, 1),
                _this89.fastMode = !1, _this89.dirtTexture = null, _this89._shader = H.find("PostProcessBloom"),
                _this89._pyramid = new Array(2 * fa.MAXPYRAMIDSIZE);
            return _this89;
        }
        _createClass(fa, [{
            key: "render",
            value: function render(e) {
                var r = e.command,
                    i = e.camera.viewport;
                this._shaderData.setTexture(fa.SHADERVALUE_AUTOEXPOSURETEX, t.Texture2D.whiteTexture);
                var n, s = this._anamorphicRatio,
                    o = s < 0 ? -s : 0,
                    l = s > 0 ? s : 0,
                    _ = Math.floor(i.width / (2 - o)),
                    h = Math.floor(i.height / (2 - l)),
                    c = Math.max(_, h);
                n = Math.log2(c) + this._diffusion - 10;
                var d = Math.floor(n),
                    u = Math.min(Math.max(d, 1), fa.MAXPYRAMIDSIZE),
                    m = .5 + n - d;
                this._shaderData.setNumber(fa.SHADERVALUE_SAMPLESCALE, m);
                var f = Ae.gammaToLinearSpace(this.threshold),
                    E = f * this._softKnee + 1e-5;
                this._shaderThreshold.setValue(f, f - E, 2 * E, .25 / E), this._shaderData.setVector(fa.SHADERVALUE_THRESHOLD, this._shaderThreshold);
                var T = Ae.gammaToLinearSpace(this.clamp);
                this._shaderParams.setValue(T, 0, 0, 0), this._shaderData.setVector(fa.SHADERVALUE_PARAMS, this._shaderParams);
                for (var p = this.fastMode ? 1 : 0, g = e.source, S = 0; S < u; S++) {
                    var R = 2 * S,
                        v = R + 1,
                        x = 0 == S ? fa.SUBSHADER_PREFILTER13 + p : fa.SUBSHADER_DOWNSAMPLE13 + p,
                        I = F.createFromPool(_, h, t.RenderTextureFormat.R8G8B8, t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE, t.FilterMode.Bilinear);
                    if (this._pyramid[R] = I, S !== u - 1) {
                        var A = F.createFromPool(_, h, t.RenderTextureFormat.R8G8B8, t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE, t.FilterMode.Bilinear);
                        this._pyramid[v] = A;
                    }
                    r.blitScreenTriangle(g, I, null, this._shader, this._shaderData, x), g = I, _ = Math.max(Math.floor(_ / 2), 1),
                        h = Math.max(Math.floor(h / 2), 1);
                }
                var M = this._pyramid[2 * (u - 1)];
                for (S = u - 2; S >= 0; S--) {
                    v = (R = 2 * S) + 1, I = this._pyramid[R], A = this._pyramid[v], r.setShaderDataTexture(this._shaderData, fa.SHADERVALUE_BLOOMTEX, I),
                        r.blitScreenTriangle(M, A, null, this._shader, this._shaderData, fa.SUBSHADER_UPSAMPLETENT + p),
                        M = A;
                }
                var D = this._linearColor;
                this.color.toLinear(D);
                var L = Math.pow(2, this._intensity / 10) - 1,
                    y = this._shaderSetting;
                this._shaderSetting.setValue(m, L, this._dirtIntensity, u);
                var C = this.dirtTexture ? this.dirtTexture : t.Texture2D.blackTexture,
                    O = C.width / C.height,
                    N = i.width / i.height,
                    P = this._dirtTileOffset;
                O > N ? P.setValue(N / O, 1, .5 * (1 - P.x), 0) : O < N && P.setValue(1, O / N, 0, .5 * (1 - P.y));
                var b = e.compositeShaderData;
                for (this.fastMode ? b.addDefine(W.SHADERDEFINE_BLOOM_LOW) : b.addDefine(W.SHADERDEFINE_BLOOM),
                    this._bloomTextureTexelSize.setValue(1 / M.width, 1 / M.height, M.width, M.height),
                    b.setVector(W.SHADERVALUE_BLOOM_DIRTTILEOFFSET, P), b.setVector(W.SHADERVALUE_BLOOM_SETTINGS, y),
                    b.setVector(W.SHADERVALUE_BLOOM_COLOR, new a(D.r, D.g, D.b, D.a)), b.setTexture(W.SHADERVALUE_BLOOM_DIRTTEX, C),
                    b.setTexture(W.SHADERVALUE_BLOOMTEX, M), b.setVector(W.SHADERVALUE_BLOOMTEX_TEXELSIZE, this._bloomTextureTexelSize),
                    S = 0; S < u; S++) {
                    v = (R = 2 * S) + 1, F.recoverToPool(this._pyramid[R]), 0 !== S && S !== u - 1 && F.recoverToPool(this._pyramid[v]);
                }
                e.deferredReleaseTextures.push(M);
            }
        }, {
            key: "intensity",
            get: function get() {
                return this._intensity;
            },
            set: function set(e) {
                this._intensity = Math.max(e, 0);
            }
        }, {
            key: "threshold",
            get: function get() {
                return this._threshold;
            },
            set: function set(e) {
                this._threshold = Math.max(e, 0);
            }
        }, {
            key: "softKnee",
            get: function get() {
                return this._softKnee;
            },
            set: function set(e) {
                this._softKnee = Math.min(Math.max(e, 0), 1);
            }
        }, {
            key: "diffusion",
            get: function get() {
                return this._diffusion;
            },
            set: function set(e) {
                this._diffusion = Math.min(Math.max(e, 1), 10);
            }
        }, {
            key: "anamorphicRatio",
            get: function get() {
                return this._anamorphicRatio;
            },
            set: function set(e) {
                this._anamorphicRatio = Math.min(Math.max(e, -1), 1);
            }
        }, {
            key: "dirtIntensity",
            get: function get() {
                return this._dirtIntensity;
            },
            set: function set(e) {
                this._dirtIntensity = Math.max(e, 0);
            }
        }]);
        return fa;
    }(ma);
    fa.SHADERVALUE_MAINTEX = H.propertyNameToID("u_MainTex"), fa.SHADERVALUE_AUTOEXPOSURETEX = H.propertyNameToID("u_AutoExposureTex"),
        fa.SHADERVALUE_SAMPLESCALE = H.propertyNameToID("u_SampleScale"), fa.SHADERVALUE_THRESHOLD = H.propertyNameToID("u_Threshold"),
        fa.SHADERVALUE_PARAMS = H.propertyNameToID("u_Params"), fa.SHADERVALUE_BLOOMTEX = H.propertyNameToID("u_BloomTex"),
        fa.SUBSHADER_PREFILTER13 = 0, fa.SUBSHADER_PREFILTER4 = 1, fa.SUBSHADER_DOWNSAMPLE13 = 2,
        fa.SUBSHADER_DOWNSAMPLE4 = 3, fa.SUBSHADER_UPSAMPLETENT = 4, fa.SUBSHADER_UPSAMPLEBOX = 5,
        fa.MAXPYRAMIDSIZE = 16;
    var Ea = /* */ function() {
        function Ea(e) {
            _classCallCheck(this, Ea);
            if (!(e instanceof Array) || 4 !== e.length) throw new Error("Rand:Seed must be an array with 4 numbers");
            this._state0U = 0 | e[0], this._state0L = 0 | e[1], this._state1U = 0 | e[2], this._state1L = 0 | e[3];
        }
        _createClass(Ea, [{
            key: "randomint",
            value: function randomint() {
                var e = this._state0U,
                    t = this._state0L,
                    r = this._state1U,
                    i = this._state1L,
                    a = (i >>> 0) + (t >>> 0),
                    n = r + e + (a / 2 >>> 31) >>> 0,
                    s = a >>> 0;
                this._state0U = r, this._state0L = i;
                var o = 0,
                    l = 0;
                o = (e ^= o = e << 23 | (-512 & t) >>> 9) ^ r, l = (t ^= l = t << 23) ^ i;
                o ^= e >>> 18, l ^= t >>> 18 | (262143 & e) << 14;
                return o ^= r >>> 5, l ^= i >>> 5 | (31 & r) << 27, this._state1U = o, this._state1L = l, [n, s];
            }
        }, {
            key: "random",
            value: function random() {
                var e = this.randomint(),
                    t = e[0],
                    r = 1023 << 20 | t >>> 12,
                    i = 0 | (e[1] >>> 12 | (4095 & t) << 20);
                return Ea._CONVERTION_BUFFER.setUint32(0, r, !1), Ea._CONVERTION_BUFFER.setUint32(4, i, !1),
                    Ea._CONVERTION_BUFFER.getFloat64(0, !1) - 1;
            }
        }]);
        return Ea;
    }();
    Ea._CONVERTION_BUFFER = new DataView(new ArrayBuffer(8)), Ea.defaultRand = new Ea([0, Date.now() / 65536, 0, Date.now() % 65536]);
    var Ta = /* */ function() {
        function Ta(e, t) {
            _classCallCheck(this, Ta);
            this._width = 0, this._height = 0, this._width = e, this._height = t;
        }
        _createClass(Ta, [{
            key: "width",
            get: function get() {
                return -1 === this._width ? w.clientWidth : this._width;
            }
        }, {
            key: "height",
            get: function get() {
                return -1 === this._height ? w.clientHeight : this._height;
            }
        }], [{
            key: "fullScreen",
            get: function get() {
                return new Ta(-1, -1);
            }
        }]);
        return Ta;
    }();
    e.AlternateLightQueue = Cr, e.AnimationClip = A, e.AnimationClipParser03 = p, e.AnimationClipParser04 = S,
        e.AnimationEvent = c, e.AnimationNode = Y, e.AnimationTransform3D = X, e.Animator = b,
        e.AnimatorControllerLayer = D, e.AnimatorPlayState = M, e.AnimatorState = N, e.AnimatorStateScript = /* */ function() {
            function _class2() {
                _classCallCheck(this, _class2);
            }
            _createClass(_class2, [{
                key: "onStateEnter",
                value: function onStateEnter() {}
            }, {
                key: "onStateUpdate",
                value: function onStateUpdate() {}
            }, {
                key: "onStateExit",
                value: function onStateExit() {}
            }]);
            return _class2;
        }(), e.Avatar = Z, e.BaseCamera = Qe, e.BaseMaterial = q, e.BaseRender = mt, e.BaseShape = Nt,
        e.BatchMark = Ne, e.BlinnPhongMaterial = K, e.BlitScreenQuadCMD = et, e.BloomEffect = fa,
        e.BoundBox = dt, e.BoundFrustum = He, e.BoundSphere = Qt, e.Bounds = ut, e.BoundsOctree = Fr,
        e.BoundsOctreeNode = Vr, e.BoxColliderShape = mr, e.BoxShape = bt, e.BufferState = Xe,
        e.BulletInteractive = Qr, e.Burst = vt, e.Camera = nt, e.CapsuleColliderShape = fr,
        e.CastShadowList = /* */ function(_t5) {
            _inherits(_class3, _t5);

            function _class3() {
                _classCallCheck(this, _class3);
                return _possibleConstructorReturn(this, _getPrototypeOf(_class3).call(this));
            }
            _createClass(_class3, [{
                key: "add",
                value: function add(e) {
                    if (-1 !== e._indexInCastShadowList) throw "CastShadowList:element has  in  CastShadowList.";
                    this._add(e), e._indexInCastShadowList = this.length++;
                }
            }, {
                key: "remove",
                value: function remove(e) {
                    var t = e._indexInCastShadowList;
                    if (this.length--, t !== this.length) {
                        var r = this.elements[this.length];
                        this.elements[t] = r, r._indexInCastShadowList = t;
                    }
                    e._indexInCastShadowList = -1;
                }
            }]);
            return _class3;
        }(_t), e.CharacterController = Kr, e.CircleShape = Vt, e.Cluster = Fe, e.ColliderShape = ur,
        e.Collision = cr, e.CollisionTool = dr, e.CollisionUtils = ze, e.Color = Ae, e.ColorOverLifetime = It,
        e.Command = $e, e.CommandBuffer = it, e.CompoundColliderShape = Er, e.ConchQuaternion = O,
        e.ConchVector3 = y, e.ConchVector4 = L, e.ConeColliderShape = Tr, e.ConeShape = wt,
        e.Config3D = l, e.Constraint3D = /* */ function() {
            function _class4() {
                _classCallCheck(this, _class4);
            }
            return _class4;
        }(), e.ConstraintComponent = /* */ function(_t$Component4) {
            _inherits(_class5, _t$Component4);

            function _class5() {
                var _this90;
                _classCallCheck(this, _class5);
                _this90 = _possibleConstructorReturn(this, _getPrototypeOf(_class5).call(this)),
                    _this90._feedbackEnabled = !1;
                return _this90;
            }
            _createClass(_class5, [{
                key: "_onDestroy",
                value: function _onDestroy() {
                    x._bullet.destroy(this._btConstraint), this._btConstraint = null;
                }
            }, {
                key: "enabled",
                get: function get() {
                    return _get(_getPrototypeOf(_class5.prototype), "enabled", this);
                },
                set: function set(e) {
                    this._btConstraint.IsEnabled = e, _set(_getPrototypeOf(_class5.prototype), "enabled", e, this, true);
                }
            }, {
                key: "breakingImpulseThreshold",
                get: function get() {
                    return this._breakingImpulseThreshold;
                },
                set: function set(e) {
                    this._btConstraint.BreakingImpulseThreshold = e, this._breakingImpulseThreshold = e;
                }
            }, {
                key: "appliedImpulse",
                get: function get() {
                    return this._feedbackEnabled || (this._btConstraint.EnableFeedback(!0), this._feedbackEnabled = !0),
                        this._btConstraint.AppliedImpulse;
                }
            }, {
                key: "connectedBody",
                get: function get() {
                    return this._connectedBody;
                },
                set: function set(e) {
                    this._connectedBody = e;
                }
            }]);
            return _class5;
        }(t.Component), e.ContactPoint = hr, e.ContainmentType = Ge, e.CylinderColliderShape = pr,
        e.DefineDatas = B, e.DirectionLight = $i, e.DirectionLightQueue = yr, e.DynamicBatchManager = Me,
        e.EffectMaterial = J, e.Emission = Jt, e.ExtendTerrainMaterial = $, e.FloatKeyframe = u,
        e.FrameOverTime = At, e.FrustumCulling = Oe, e.GeometryElement = Pe, e.Gradient = Rt,
        e.GradientAngularVelocity = Mt, e.GradientColor = xt, e.GradientDataInt = Dt, e.GradientDataNumber = Lt,
        e.GradientDataVector2 = ua, e.GradientMode = St, e.GradientSize = yt, e.GradientVelocity = Ct,
        e.HalfFloatUtils = g, e.HeightMap = ca, e.HeightfieldColliderShape = /* */ function() {
            function _class6() {
                _classCallCheck(this, _class6);
            }
            return _class6;
        }(), e.HemisphereShape = Ft, e.HitResult = lr, e.ILaya3D = _, e.IndexBuffer3D = Ye,
        e.Input3D = xr, e.Keyframe = d, e.KeyframeNode = h, e.KeyframeNodeList = R, e.KeyframeNodeOwner = P,
        e.Laya3D = _a, e.LightQueue = Lr, e.LightSprite = Ji, e.LoadModelV04 = ia, e.LoadModelV05 = aa,
        e.Material = j, e.MathUtils3D = r, e.Matrix3x3 = m, e.Matrix4x4 = C, e.Mesh = ai,
        e.MeshColliderShape = gr, e.MeshFilter = Et, e.MeshReader = na, e.MeshRenderDynamicBatchManager = pt,
        e.MeshRenderStaticBatchManager = ht, e.MeshRenderer = ft, e.MeshSprite3D = gt, e.MeshSprite3DShaderDeclaration = ct,
        e.MeshTerrainSprite3D = da, e.MouseTouch = sr, e.OctreeMotionList = wr, e.PBRMaterial = ee,
        e.PBRSpecularMaterial = de, e.PBRStandardMaterial = Se, e.ParallelSplitShadowMap = Ki,
        e.Physics3D = x, e.Physics3DUtils = Xt, e.PhysicsCollider = $r, e.PhysicsComponent = Rr,
        e.PhysicsSettings = Ir, e.PhysicsSimulation = vr, e.PhysicsTriggerComponent = Jr,
        e.PhysicsUpdateList = _r, e.Picker = We, e.PixelLineData = /* */ function() {
            function _class7() {
                _classCallCheck(this, _class7);
                this.startPosition = new n(), this.endPosition = new n(), this.startColor = new Ae(),
                    this.endColor = new Ae();
            }
            _createClass(_class7, [{
                key: "cloneTo",
                value: function cloneTo(e) {
                    this.startPosition.cloneTo(e.startPosition), this.endPosition.cloneTo(e.endPosition),
                        this.startColor.cloneTo(e.startColor), this.endColor.cloneTo(e.endColor);
                }
            }]);
            return _class7;
        }(), e.PixelLineFilter = Or, e.PixelLineMaterial = rr, e.PixelLineRenderer = Nr,
        e.PixelLineSprite3D = Pr, e.PixelLineVertex = ir, e.Plane = Be, e.Point2PointConstraint = /* */ function() {
            function _class8() {
                _classCallCheck(this, _class8);
                this._pivotInA = new n(), this._pivotInB = new n();
            }
            _createClass(_class8, [{
                key: "pivotInA",
                get: function get() {
                    return this._pivotInA;
                },
                set: function set(e) {
                    this._pivotInA = e;
                }
            }, {
                key: "pivotInB",
                get: function get() {
                    return this._pivotInB;
                },
                set: function set(e) {
                    this._pivotInB = e;
                }
            }, {
                key: "damping",
                get: function get() {
                    return this._damping;
                },
                set: function set(e) {
                    this._damping = e;
                }
            }, {
                key: "impulseClamp",
                get: function get() {
                    return this._impulseClamp;
                },
                set: function set(e) {
                    this._impulseClamp = e;
                }
            }, {
                key: "tau",
                get: function get() {
                    return this._tau;
                },
                set: function set(e) {
                    this._tau = e;
                }
            }]);
            return _class8;
        }(), e.PointLight = ea, e.PostProcess = W, e.PostProcessEffect = ma, e.PostProcessRenderContext = V,
        e.PrimitiveMesh = ni, e.Quaternion = f, e.QuaternionKeyframe = E, e.Rand = Kt, e.RandX = Ea,
        e.Ray = Ue, e.RenderContext3D = w, e.RenderElement = st, e.RenderQueue = br, e.RenderState = Q,
        e.RenderTexture = F, e.RenderableSprite3D = ye, e.Rigidbody3D = ei, e.RotationOverLifetime = Ot,
        e.Scene3D = Br, e.Scene3DShaderDeclaration = at, e.Scene3DUtils = ra, e.SceneManager = /* */ function() {
            function _class9() {
                _classCallCheck(this, _class9);
            }
            return _class9;
        }(), e.ScreenQuad = Ke, e.ScreenTriangle = Je, e.Script3D = ha, e.SetRenderTargetCMD = tt,
        e.SetShaderDataTextureCMD = rt, e.Shader3D = H, e.ShaderData = k, e.ShaderDefine = U,
        e.ShaderInit3D = Qi, e.ShaderInstance = ne, e.ShaderPass = se, e.ShaderVariable = ae,
        e.ShaderVariant = G, e.ShaderVariantCollection = z, e.ShapeUtils = Pt, e.ShuriKenParticle3D = tr,
        e.ShuriKenParticle3DShaderDeclaration = kt, e.ShurikenParticleData = $t, e.ShurikenParticleMaterial = Wt,
        e.ShurikenParticleRenderer = Yt, e.ShurikenParticleSystem = er, e.SimpleSingletonList = ar,
        e.SingletonList = _t, e.Size = Ta, e.SizeOverLifetime = Ut, e.SkinnedMeshRenderer = Gr,
        e.SkinnedMeshSprite3D = zr, e.SkinnedMeshSprite3DShaderDeclaration = Ur, e.SkyBox = je,
        e.SkyBoxMaterial = Re, e.SkyDome = Mr, e.SkyMesh = Ze, e.SkyPanoramicMaterial = la,
        e.SkyProceduralMaterial = ve, e.SkyRenderer = qe, e.SphereColliderShape = Sr, e.SphereShape = Bt,
        e.SphericalHarmonicsL2 = nr, e.SpotLight = ta, e.Sprite3D = Le, e.StartFrame = Gt,
        e.StaticBatchManager = Ce, e.StaticPlaneColliderShape = ti, e.SubMesh = ri, e.SubMeshDynamicBatch = Tt,
        e.SubMeshInstanceBatch = Ve, e.SubMeshRenderElement = ot, e.SubMeshStaticBatch = lt,
        e.SubShader = oe, e.TextMesh = /* */ function() {
            _createClass(_class10, [{
                key: "text",
                get: function get() {
                    return this._text;
                },
                set: function set(e) {
                    this._text = e;
                }
            }, {
                key: "fontSize",
                get: function get() {
                    return this._fontSize;
                },
                set: function set(e) {
                    this._fontSize = e;
                }
            }, {
                key: "color",
                get: function get() {
                    return this._color;
                },
                set: function set(e) {
                    this._color = e;
                }
            }]);

            function _class10() {
                _classCallCheck(this, _class10);
            }
            _createClass(_class10, [{
                key: "_createVertexBuffer",
                value: function _createVertexBuffer(e) {}
            }, {
                key: "_resizeVertexBuffer",
                value: function _resizeVertexBuffer(e) {}
            }, {
                key: "_addChar",
                value: function _addChar() {}
            }]);
            return _class10;
        }(), e.TextureCube = Dr, e.TextureGenerator = v, e.TextureMode = kr, e.TextureSheetAnimation = zt,
        e.Touch = or, e.TrailFilter = Yr, e.TrailGeometry = Xr, e.TrailMaterial = Hr, e.TrailRenderer = Zr,
        e.TrailSprite3D = jr, e.Transform3D = De, e.UnlitMaterial = xe, e.Utils3D = I, e.Vector2 = i,
        e.Vector3 = n, e.Vector3Keyframe = T, e.Vector4 = a, e.VelocityOverLifetime = Ht,
        e.VertexBuffer3D = be, e.VertexDeclaration = _e, e.VertexElement = he, e.VertexElementFormat = le,
        e.VertexMesh = ce, e.VertexPositionTerrain = qr, e.VertexPositionTexture0 = Ar,
        e.VertexShuriKenParticle = Zt, e.VertexShurikenParticleBillboard = jt, e.VertexShurikenParticleMesh = qt,
        e.VertexTrail = Wr, e.Viewport = ke, e.WaterPrimaryMaterial = Ie, e.skinnedMatrixCache = ii;
}(window.Laya = window.Laya || {}, Laya);